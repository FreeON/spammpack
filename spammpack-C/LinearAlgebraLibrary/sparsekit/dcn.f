      subroutine dcn(AR,IA,JA,N,NE,IC,NN,IERR)

c*********************************************************************72
c
cc DCN generates sparse square matrices of type D(N,C).
c
c   PURPOSE
c
c   DCN generates sparse (square) matrices of the type
c   D(N,C).  This type of matrix has the following characteristics:
c   1's in the diagonal, three bands at the distance C above the
c   diagonal (and reappearing cyclicly under it), and a 10 x 10
c   triangle of elements in the upper right hand corner.
c   Different software libraries require different storage schemes.
c   This routine generates the matrix in the storage  by
c   indices mode.
c
c
c   Note: If A is the sparse matrix of type D(N,C), then
c
c       min|A(i,j)| = 1,     max|A(i,j)| = max(1000,N + 1)
c
c
c
c   CONTRIBUTOR: Ernest E. Rothman
c                Cornell Theory Center/Cornell National Supercomputer
c                Facility.
c                e-mail address: BITNET:   eer@cornellf
c                                INTERNET: eer@cornellf.tn.cornell.edu
c
c
c   REFERENCE
c
c   1) Zlatev, Zahari; Schaumburg, Kjeld; Wasniewski, Jerzy;
c      "A Testing Scheme for Subroutines Solving Large Linear Problems",
c       Computers and Chemistry, Vol. 5, No. 2-3, pp. 91-100, 1981.
c   2) Osterby, Ole and Zletev, Zahari;
c      "Direct Methods for Sparse Matrices";
c       Springer-Verlag 1983.
c
c
c
c   INPUT PARAMETERS
c
c   N    - Integer. The size of the square matrix.
c          N > 13 must be specified.
c
c   NN   - Integer. The dimension of integer arrays IA and JA and
c          double precision array AR. Must be at least NE.
c
c   IC   - Integer. The sparsity pattern can be changed by means of this
c          parameter.  0 < IC < N-12  must be specified.
c
c
c   OUTPUT PARAMETERS
c
c   NE   - Integer. The number of nonzero elements in the sparse matrix
c          of the type D(N,C). NE = 4*N + 55.
c
c   AR(NN) - Real array. (Double precision)
c            Stored entries of a sparse matrix to be generated by this
c            routine.
c            NN is greater then or equal to, NE, the number of
c            nonzeros including a mandatory diagonal entry for
c            each row. Entries are stored by indices.
c
c   IA(NN) - Integer array.
c            Pointers to specify rows for the stored nonzero entries
c            in AR.
c
c   JA(NN) - Integer array.
c            Pointers to specify columns for the stored nonzero entries
c            in AR.
c
c   IERR   - Error parameter is returned as zero on successful
c             execution of the routine.
c             Error diagnostics are given by means of positive values
c             of this parameter as follows:
c             IERR = 1    -  N       is out of range.
c             IERR = 2    -  IC      is out of range.
c             IERR = 3    -  NN      is out of range.
c
c
c
      double precision ar(nn)
      integer ia(nn), ja(nn), ierr
      ierr = 0
c
c
c  check the input parameters:
c
      if(n.le.13)then
         ierr = 1
         return
      end if
      if(ic .le. 0 .or. ic .ge. n-12)then
         ierr = 2
         return
      end if
      ne = 4*n+55
      if(nn.lt.ne)then
         ierr = 3
         return
      end if
c
c Begin to generate the nonzero elements as well as the row and column
c pointers:
c
      do 20 i=1,n
        ar(i) = 1.0
        ia(i) = i
        ja(i) = i
20    continue
      ilast = n
      do 30 i=1,n-ic
        it = ilast + i
        ar(it) = 1.0 + dble(i)
        ia(it) = i
        ja(it) = i+ic
30    continue
      ilast = ilast + n-ic
      do 40 i=1,n-ic-1
        it = ilast + i
        ar(it) = -dble(i)
        ia(it) = i
        ja(it) = i+ic+1
40    continue
      ilast = ilast + n-ic-1
      do 50 i=1,n-ic-2
        it = ilast + i
        ar(it) = 16.0
        ia(it) = i
        ja(it) = i+ic+2
50    continue
      ilast = ilast + n-ic-2
      icount = 0
      do 70 j=1,10
        do 60 i=1,11-j
         icount = icount + 1
         it = ilast + icount
         ar(it) = 100.0 * dble(j)
         ia(it) = i
         ja(it) = n-11+i+j
60    continue
70    continue
      icount = 0
      ilast = 55 + ilast
      do 80 i=n-ic+1,n
        icount = icount + 1
        it = ilast + icount
        ar(it) = 1.0 + dble(i)
        ia(it) = i
        ja(it) = i-n+ic
80    continue
      ilast = ilast + ic
      icount = 0
      do 90 i=n-ic,n
        icount = icount + 1
        it = ilast + icount
        ar(it) = -dble(i)
        ia(it) = i
        ja(it) = i-n+ic+1
90    continue
      ilast = ilast + ic + 1
      icount = 0
      do 100 i=n-ic-1,n
        icount = icount + 1
        it = ilast + icount
        ar(it) = 16.0
        ia(it) = i
        ja(it) = i-n+ic+2
100   continue
c     ilast = ilast + ic + 2
c     if(ilast.ne.4*n+55) then
c     write(*,*)' ilast equal to ', ilast
c     write(*,*)' ILAST, the number of nonzeros, should = ', 4*n + 55
c     stop
c     end if
c
      return
      end
