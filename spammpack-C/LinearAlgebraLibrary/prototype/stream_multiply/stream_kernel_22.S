# This code was auto-generated by ./generate_SSE_assembly.py.
# The command line given was:
#
#  ./generate_SSE_assembly.py -N 8 --Z-curve --name stream_kernel_22

# Function ABI.
#define number_stream_elements %rdi
#define alpha                  %xmm0
#define tolerance              %xmm1
#define multiply_stream        %rsi

# Define SSE registers used for C matrix
#define C1 %xmm2
#define C2 %xmm3
#define C3 %xmm4
#define C4 %xmm5

# Define SSE registeres used for B matrix
#define B1 %xmm6
#define B2 %xmm7
#define B3 %xmm8
#define B4 %xmm9

# Define SSE registeres used for A matrix
#define A11 %xmm10
#define A12 %xmm11
#define A13 %xmm12
#define A14 %xmm13
#define A21 %xmm14
#define A22 %xmm15
#define A23 %xmm10
#define A24 %xmm11
#define A31 %xmm12
#define A32 %xmm13
#define A33 %xmm14
#define A34 %xmm15
#define A41 %xmm10
#define A42 %xmm11
#define A43 %xmm12
#define A44 %xmm13

# Define loop variables.
#define index        %rax
#define base_pointer %rdx

# Define pointers to matrix blocks in stream.
#define A %r8
#define B %rcx
#define C %r9

# Define offsets into matrix blocks.

#define A_OFFSET_11 (0*8+0)*64*4 // 0 = 0x0
#define A_OFFSET_12 (0*8+1)*64*4 // 64 = 0x40
#define A_OFFSET_13 (0*8+2)*64*4 // 128 = 0x80
#define A_OFFSET_14 (0*8+3)*64*4 // 192 = 0xc0
#define A_OFFSET_15 (0*8+4)*64*4 // 256 = 0x100
#define A_OFFSET_16 (0*8+5)*64*4 // 320 = 0x140
#define A_OFFSET_17 (0*8+6)*64*4 // 384 = 0x180
#define A_OFFSET_18 (0*8+7)*64*4 // 448 = 0x1c0
#define A_OFFSET_21 (1*8+0)*64*4 // 512 = 0x200
#define A_OFFSET_22 (1*8+1)*64*4 // 576 = 0x240
#define A_OFFSET_23 (1*8+2)*64*4 // 640 = 0x280
#define A_OFFSET_24 (1*8+3)*64*4 // 704 = 0x2c0
#define A_OFFSET_25 (1*8+4)*64*4 // 768 = 0x300
#define A_OFFSET_26 (1*8+5)*64*4 // 832 = 0x340
#define A_OFFSET_27 (1*8+6)*64*4 // 896 = 0x380
#define A_OFFSET_28 (1*8+7)*64*4 // 960 = 0x3c0
#define A_OFFSET_31 (2*8+0)*64*4 // 1024 = 0x400
#define A_OFFSET_32 (2*8+1)*64*4 // 1088 = 0x440
#define A_OFFSET_33 (2*8+2)*64*4 // 1152 = 0x480
#define A_OFFSET_34 (2*8+3)*64*4 // 1216 = 0x4c0
#define A_OFFSET_35 (2*8+4)*64*4 // 1280 = 0x500
#define A_OFFSET_36 (2*8+5)*64*4 // 1344 = 0x540
#define A_OFFSET_37 (2*8+6)*64*4 // 1408 = 0x580
#define A_OFFSET_38 (2*8+7)*64*4 // 1472 = 0x5c0
#define A_OFFSET_41 (3*8+0)*64*4 // 1536 = 0x600
#define A_OFFSET_42 (3*8+1)*64*4 // 1600 = 0x640
#define A_OFFSET_43 (3*8+2)*64*4 // 1664 = 0x680
#define A_OFFSET_44 (3*8+3)*64*4 // 1728 = 0x6c0
#define A_OFFSET_45 (3*8+4)*64*4 // 1792 = 0x700
#define A_OFFSET_46 (3*8+5)*64*4 // 1856 = 0x740
#define A_OFFSET_47 (3*8+6)*64*4 // 1920 = 0x780
#define A_OFFSET_48 (3*8+7)*64*4 // 1984 = 0x7c0
#define A_OFFSET_51 (4*8+0)*64*4 // 2048 = 0x800
#define A_OFFSET_52 (4*8+1)*64*4 // 2112 = 0x840
#define A_OFFSET_53 (4*8+2)*64*4 // 2176 = 0x880
#define A_OFFSET_54 (4*8+3)*64*4 // 2240 = 0x8c0
#define A_OFFSET_55 (4*8+4)*64*4 // 2304 = 0x900
#define A_OFFSET_56 (4*8+5)*64*4 // 2368 = 0x940
#define A_OFFSET_57 (4*8+6)*64*4 // 2432 = 0x980
#define A_OFFSET_58 (4*8+7)*64*4 // 2496 = 0x9c0
#define A_OFFSET_61 (5*8+0)*64*4 // 2560 = 0xa00
#define A_OFFSET_62 (5*8+1)*64*4 // 2624 = 0xa40
#define A_OFFSET_63 (5*8+2)*64*4 // 2688 = 0xa80
#define A_OFFSET_64 (5*8+3)*64*4 // 2752 = 0xac0
#define A_OFFSET_65 (5*8+4)*64*4 // 2816 = 0xb00
#define A_OFFSET_66 (5*8+5)*64*4 // 2880 = 0xb40
#define A_OFFSET_67 (5*8+6)*64*4 // 2944 = 0xb80
#define A_OFFSET_68 (5*8+7)*64*4 // 3008 = 0xbc0
#define A_OFFSET_71 (6*8+0)*64*4 // 3072 = 0xc00
#define A_OFFSET_72 (6*8+1)*64*4 // 3136 = 0xc40
#define A_OFFSET_73 (6*8+2)*64*4 // 3200 = 0xc80
#define A_OFFSET_74 (6*8+3)*64*4 // 3264 = 0xcc0
#define A_OFFSET_75 (6*8+4)*64*4 // 3328 = 0xd00
#define A_OFFSET_76 (6*8+5)*64*4 // 3392 = 0xd40
#define A_OFFSET_77 (6*8+6)*64*4 // 3456 = 0xd80
#define A_OFFSET_78 (6*8+7)*64*4 // 3520 = 0xdc0
#define A_OFFSET_81 (7*8+0)*64*4 // 3584 = 0xe00
#define A_OFFSET_82 (7*8+1)*64*4 // 3648 = 0xe40
#define A_OFFSET_83 (7*8+2)*64*4 // 3712 = 0xe80
#define A_OFFSET_84 (7*8+3)*64*4 // 3776 = 0xec0
#define A_OFFSET_85 (7*8+4)*64*4 // 3840 = 0xf00
#define A_OFFSET_86 (7*8+5)*64*4 // 3904 = 0xf40
#define A_OFFSET_87 (7*8+6)*64*4 // 3968 = 0xf80
#define A_OFFSET_88 (7*8+7)*64*4 // 4032 = 0xfc0

#define B_OFFSET_11 (0*8+0)*16*4 // 0 = 0x0
#define B_OFFSET_12 (0*8+1)*16*4 // 16 = 0x10
#define B_OFFSET_13 (0*8+2)*16*4 // 32 = 0x20
#define B_OFFSET_14 (0*8+3)*16*4 // 48 = 0x30
#define B_OFFSET_15 (0*8+4)*16*4 // 64 = 0x40
#define B_OFFSET_16 (0*8+5)*16*4 // 80 = 0x50
#define B_OFFSET_17 (0*8+6)*16*4 // 96 = 0x60
#define B_OFFSET_18 (0*8+7)*16*4 // 112 = 0x70
#define B_OFFSET_21 (1*8+0)*16*4 // 128 = 0x80
#define B_OFFSET_22 (1*8+1)*16*4 // 144 = 0x90
#define B_OFFSET_23 (1*8+2)*16*4 // 160 = 0xa0
#define B_OFFSET_24 (1*8+3)*16*4 // 176 = 0xb0
#define B_OFFSET_25 (1*8+4)*16*4 // 192 = 0xc0
#define B_OFFSET_26 (1*8+5)*16*4 // 208 = 0xd0
#define B_OFFSET_27 (1*8+6)*16*4 // 224 = 0xe0
#define B_OFFSET_28 (1*8+7)*16*4 // 240 = 0xf0
#define B_OFFSET_31 (2*8+0)*16*4 // 256 = 0x100
#define B_OFFSET_32 (2*8+1)*16*4 // 272 = 0x110
#define B_OFFSET_33 (2*8+2)*16*4 // 288 = 0x120
#define B_OFFSET_34 (2*8+3)*16*4 // 304 = 0x130
#define B_OFFSET_35 (2*8+4)*16*4 // 320 = 0x140
#define B_OFFSET_36 (2*8+5)*16*4 // 336 = 0x150
#define B_OFFSET_37 (2*8+6)*16*4 // 352 = 0x160
#define B_OFFSET_38 (2*8+7)*16*4 // 368 = 0x170
#define B_OFFSET_41 (3*8+0)*16*4 // 384 = 0x180
#define B_OFFSET_42 (3*8+1)*16*4 // 400 = 0x190
#define B_OFFSET_43 (3*8+2)*16*4 // 416 = 0x1a0
#define B_OFFSET_44 (3*8+3)*16*4 // 432 = 0x1b0
#define B_OFFSET_45 (3*8+4)*16*4 // 448 = 0x1c0
#define B_OFFSET_46 (3*8+5)*16*4 // 464 = 0x1d0
#define B_OFFSET_47 (3*8+6)*16*4 // 480 = 0x1e0
#define B_OFFSET_48 (3*8+7)*16*4 // 496 = 0x1f0
#define B_OFFSET_51 (4*8+0)*16*4 // 512 = 0x200
#define B_OFFSET_52 (4*8+1)*16*4 // 528 = 0x210
#define B_OFFSET_53 (4*8+2)*16*4 // 544 = 0x220
#define B_OFFSET_54 (4*8+3)*16*4 // 560 = 0x230
#define B_OFFSET_55 (4*8+4)*16*4 // 576 = 0x240
#define B_OFFSET_56 (4*8+5)*16*4 // 592 = 0x250
#define B_OFFSET_57 (4*8+6)*16*4 // 608 = 0x260
#define B_OFFSET_58 (4*8+7)*16*4 // 624 = 0x270
#define B_OFFSET_61 (5*8+0)*16*4 // 640 = 0x280
#define B_OFFSET_62 (5*8+1)*16*4 // 656 = 0x290
#define B_OFFSET_63 (5*8+2)*16*4 // 672 = 0x2a0
#define B_OFFSET_64 (5*8+3)*16*4 // 688 = 0x2b0
#define B_OFFSET_65 (5*8+4)*16*4 // 704 = 0x2c0
#define B_OFFSET_66 (5*8+5)*16*4 // 720 = 0x2d0
#define B_OFFSET_67 (5*8+6)*16*4 // 736 = 0x2e0
#define B_OFFSET_68 (5*8+7)*16*4 // 752 = 0x2f0
#define B_OFFSET_71 (6*8+0)*16*4 // 768 = 0x300
#define B_OFFSET_72 (6*8+1)*16*4 // 784 = 0x310
#define B_OFFSET_73 (6*8+2)*16*4 // 800 = 0x320
#define B_OFFSET_74 (6*8+3)*16*4 // 816 = 0x330
#define B_OFFSET_75 (6*8+4)*16*4 // 832 = 0x340
#define B_OFFSET_76 (6*8+5)*16*4 // 848 = 0x350
#define B_OFFSET_77 (6*8+6)*16*4 // 864 = 0x360
#define B_OFFSET_78 (6*8+7)*16*4 // 880 = 0x370
#define B_OFFSET_81 (7*8+0)*16*4 // 896 = 0x380
#define B_OFFSET_82 (7*8+1)*16*4 // 912 = 0x390
#define B_OFFSET_83 (7*8+2)*16*4 // 928 = 0x3a0
#define B_OFFSET_84 (7*8+3)*16*4 // 944 = 0x3b0
#define B_OFFSET_85 (7*8+4)*16*4 // 960 = 0x3c0
#define B_OFFSET_86 (7*8+5)*16*4 // 976 = 0x3d0
#define B_OFFSET_87 (7*8+6)*16*4 // 992 = 0x3e0
#define B_OFFSET_88 (7*8+7)*16*4 // 1008 = 0x3f0

#define C_OFFSET_11 (0*8+0)*16*4 // 0 = 0x0
#define C_OFFSET_12 (0*8+1)*16*4 // 16 = 0x10
#define C_OFFSET_13 (0*8+2)*16*4 // 32 = 0x20
#define C_OFFSET_14 (0*8+3)*16*4 // 48 = 0x30
#define C_OFFSET_15 (0*8+4)*16*4 // 64 = 0x40
#define C_OFFSET_16 (0*8+5)*16*4 // 80 = 0x50
#define C_OFFSET_17 (0*8+6)*16*4 // 96 = 0x60
#define C_OFFSET_18 (0*8+7)*16*4 // 112 = 0x70
#define C_OFFSET_21 (1*8+0)*16*4 // 128 = 0x80
#define C_OFFSET_22 (1*8+1)*16*4 // 144 = 0x90
#define C_OFFSET_23 (1*8+2)*16*4 // 160 = 0xa0
#define C_OFFSET_24 (1*8+3)*16*4 // 176 = 0xb0
#define C_OFFSET_25 (1*8+4)*16*4 // 192 = 0xc0
#define C_OFFSET_26 (1*8+5)*16*4 // 208 = 0xd0
#define C_OFFSET_27 (1*8+6)*16*4 // 224 = 0xe0
#define C_OFFSET_28 (1*8+7)*16*4 // 240 = 0xf0
#define C_OFFSET_31 (2*8+0)*16*4 // 256 = 0x100
#define C_OFFSET_32 (2*8+1)*16*4 // 272 = 0x110
#define C_OFFSET_33 (2*8+2)*16*4 // 288 = 0x120
#define C_OFFSET_34 (2*8+3)*16*4 // 304 = 0x130
#define C_OFFSET_35 (2*8+4)*16*4 // 320 = 0x140
#define C_OFFSET_36 (2*8+5)*16*4 // 336 = 0x150
#define C_OFFSET_37 (2*8+6)*16*4 // 352 = 0x160
#define C_OFFSET_38 (2*8+7)*16*4 // 368 = 0x170
#define C_OFFSET_41 (3*8+0)*16*4 // 384 = 0x180
#define C_OFFSET_42 (3*8+1)*16*4 // 400 = 0x190
#define C_OFFSET_43 (3*8+2)*16*4 // 416 = 0x1a0
#define C_OFFSET_44 (3*8+3)*16*4 // 432 = 0x1b0
#define C_OFFSET_45 (3*8+4)*16*4 // 448 = 0x1c0
#define C_OFFSET_46 (3*8+5)*16*4 // 464 = 0x1d0
#define C_OFFSET_47 (3*8+6)*16*4 // 480 = 0x1e0
#define C_OFFSET_48 (3*8+7)*16*4 // 496 = 0x1f0
#define C_OFFSET_51 (4*8+0)*16*4 // 512 = 0x200
#define C_OFFSET_52 (4*8+1)*16*4 // 528 = 0x210
#define C_OFFSET_53 (4*8+2)*16*4 // 544 = 0x220
#define C_OFFSET_54 (4*8+3)*16*4 // 560 = 0x230
#define C_OFFSET_55 (4*8+4)*16*4 // 576 = 0x240
#define C_OFFSET_56 (4*8+5)*16*4 // 592 = 0x250
#define C_OFFSET_57 (4*8+6)*16*4 // 608 = 0x260
#define C_OFFSET_58 (4*8+7)*16*4 // 624 = 0x270
#define C_OFFSET_61 (5*8+0)*16*4 // 640 = 0x280
#define C_OFFSET_62 (5*8+1)*16*4 // 656 = 0x290
#define C_OFFSET_63 (5*8+2)*16*4 // 672 = 0x2a0
#define C_OFFSET_64 (5*8+3)*16*4 // 688 = 0x2b0
#define C_OFFSET_65 (5*8+4)*16*4 // 704 = 0x2c0
#define C_OFFSET_66 (5*8+5)*16*4 // 720 = 0x2d0
#define C_OFFSET_67 (5*8+6)*16*4 // 736 = 0x2e0
#define C_OFFSET_68 (5*8+7)*16*4 // 752 = 0x2f0
#define C_OFFSET_71 (6*8+0)*16*4 // 768 = 0x300
#define C_OFFSET_72 (6*8+1)*16*4 // 784 = 0x310
#define C_OFFSET_73 (6*8+2)*16*4 // 800 = 0x320
#define C_OFFSET_74 (6*8+3)*16*4 // 816 = 0x330
#define C_OFFSET_75 (6*8+4)*16*4 // 832 = 0x340
#define C_OFFSET_76 (6*8+5)*16*4 // 848 = 0x350
#define C_OFFSET_77 (6*8+6)*16*4 // 864 = 0x360
#define C_OFFSET_78 (6*8+7)*16*4 // 880 = 0x370
#define C_OFFSET_81 (7*8+0)*16*4 // 896 = 0x380
#define C_OFFSET_82 (7*8+1)*16*4 // 912 = 0x390
#define C_OFFSET_83 (7*8+2)*16*4 // 928 = 0x3a0
#define C_OFFSET_84 (7*8+3)*16*4 // 944 = 0x3b0
#define C_OFFSET_85 (7*8+4)*16*4 // 960 = 0x3c0
#define C_OFFSET_86 (7*8+5)*16*4 // 976 = 0x3d0
#define C_OFFSET_87 (7*8+6)*16*4 // 992 = 0x3e0
#define C_OFFSET_88 (7*8+7)*16*4 // 1008 = 0x3f0

# C function declaration
#
# struct multiply_stream_t
# {
#   float *A_block;
#   float *B_block;
#   float *C_block;
#   float  norm[128];
# };
#
# void
# stream_kernel_22 (const unsigned int number_stream_elements,
#     float alpha,
#     float tolerance,
#     struct multiply_stream_t *multiply_stream);

  # Function prolog.
  .text
  .align 256
  .global stream_kernel_22
  .type stream_kernel_22, @function

stream_kernel_22:

  # Push used registers on stack.
  push index
  push base_pointer
  push A
  push B
  push C

  # Copy alpha into all 4 elements of SSE register.
  shufps $0x0, alpha, alpha

  # Divide number of stream elements by 512 to simulate stride of 512.
  shr $8, number_stream_elements

  # Test whether number_stream_elements is zero.
  test number_stream_elements, number_stream_elements
  jbe done

  # Set loop index to zero.
  xor base_pointer, base_pointer
  xor index, index

  .align 16
loop:

  # Set the base pointer using sizeof(multiply_stream_t) = 0x98.
  imul $0x98, base_pointer, base_pointer

  # Load pointers to stream matrix blocks.
  mov (multiply_stream, base_pointer, 1), A
  mov 0x8(multiply_stream, base_pointer, 1), B
  mov 0x10(multiply_stream, base_pointer, 1), C

  .align 16
block_1:

  # Check norm of product A(1,1)*B(1,1).
  movss 0x18(multiply_stream, base_pointer), B1
  mulss 0x118(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_2

  # Reset C(1,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,1) = A(1,1)*B(1,1).
  movaps 0x0+B_OFFSET_11(B), B1
  movaps 0x10+B_OFFSET_11(B), B2
  movaps 0x20+B_OFFSET_11(B), B3
  movaps 0x30+B_OFFSET_11(B), B4
  movaps 0x0+A_OFFSET_11(A), A11
  movaps 0x10+A_OFFSET_11(A), A12
  movaps 0x20+A_OFFSET_11(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_11(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_11(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_11(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_11(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_11(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_11(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_11(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_11(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_11(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_11(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_11(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_11(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_11(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,1) to already existing.
  addps 0x0+C_OFFSET_11(C), C1
  addps 0x10+C_OFFSET_11(C), C2
  addps 0x20+C_OFFSET_11(C), C3
  addps 0x30+C_OFFSET_11(C), C4

  # Write out C(1,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_11(C)
  movaps C2, 0x10+C_OFFSET_11(C)
  movaps C3, 0x20+C_OFFSET_11(C)
  movaps C4, 0x30+C_OFFSET_11(C)

  .align 16
block_2:

  # Check norm of product A(1,2)*B(2,1).
  movss 0x1c(multiply_stream, base_pointer), B1
  mulss 0x138(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_3

  # Reset C(1,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,1) = A(1,2)*B(2,1).
  movaps 0x0+B_OFFSET_21(B), B1
  movaps 0x10+B_OFFSET_21(B), B2
  movaps 0x20+B_OFFSET_21(B), B3
  movaps 0x30+B_OFFSET_21(B), B4
  movaps 0x0+A_OFFSET_12(A), A11
  movaps 0x10+A_OFFSET_12(A), A12
  movaps 0x20+A_OFFSET_12(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_12(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_12(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_12(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_12(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_12(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_12(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_12(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_12(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_12(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_12(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_12(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_12(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_12(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,1) to already existing.
  addps 0x0+C_OFFSET_11(C), C1
  addps 0x10+C_OFFSET_11(C), C2
  addps 0x20+C_OFFSET_11(C), C3
  addps 0x30+C_OFFSET_11(C), C4

  # Write out C(1,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_11(C)
  movaps C2, 0x10+C_OFFSET_11(C)
  movaps C3, 0x20+C_OFFSET_11(C)
  movaps C4, 0x30+C_OFFSET_11(C)

  .align 16
block_3:

  # Check norm of product A(1,1)*B(1,2).
  movss 0x18(multiply_stream, base_pointer), B1
  mulss 0x11c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_4

  # Reset C(1,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,2) = A(1,1)*B(1,2).
  movaps 0x0+B_OFFSET_12(B), B1
  movaps 0x10+B_OFFSET_12(B), B2
  movaps 0x20+B_OFFSET_12(B), B3
  movaps 0x30+B_OFFSET_12(B), B4
  movaps 0x0+A_OFFSET_11(A), A11
  movaps 0x10+A_OFFSET_11(A), A12
  movaps 0x20+A_OFFSET_11(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_11(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_11(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_11(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_11(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_11(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_11(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_11(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_11(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_11(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_11(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_11(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_11(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_11(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,2) to already existing.
  addps 0x0+C_OFFSET_12(C), C1
  addps 0x10+C_OFFSET_12(C), C2
  addps 0x20+C_OFFSET_12(C), C3
  addps 0x30+C_OFFSET_12(C), C4

  # Write out C(1,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_12(C)
  movaps C2, 0x10+C_OFFSET_12(C)
  movaps C3, 0x20+C_OFFSET_12(C)
  movaps C4, 0x30+C_OFFSET_12(C)

  .align 16
block_4:

  # Check norm of product A(1,2)*B(2,2).
  movss 0x1c(multiply_stream, base_pointer), B1
  mulss 0x13c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_5

  # Reset C(1,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,2) = A(1,2)*B(2,2).
  movaps 0x0+B_OFFSET_22(B), B1
  movaps 0x10+B_OFFSET_22(B), B2
  movaps 0x20+B_OFFSET_22(B), B3
  movaps 0x30+B_OFFSET_22(B), B4
  movaps 0x0+A_OFFSET_12(A), A11
  movaps 0x10+A_OFFSET_12(A), A12
  movaps 0x20+A_OFFSET_12(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_12(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_12(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_12(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_12(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_12(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_12(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_12(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_12(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_12(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_12(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_12(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_12(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_12(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,2) to already existing.
  addps 0x0+C_OFFSET_12(C), C1
  addps 0x10+C_OFFSET_12(C), C2
  addps 0x20+C_OFFSET_12(C), C3
  addps 0x30+C_OFFSET_12(C), C4

  # Write out C(1,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_12(C)
  movaps C2, 0x10+C_OFFSET_12(C)
  movaps C3, 0x20+C_OFFSET_12(C)
  movaps C4, 0x30+C_OFFSET_12(C)

  .align 16
block_5:

  # Check norm of product A(2,1)*B(1,1).
  movss 0x38(multiply_stream, base_pointer), B1
  mulss 0x118(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_6

  # Reset C(2,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,1) = A(2,1)*B(1,1).
  movaps 0x0+B_OFFSET_11(B), B1
  movaps 0x10+B_OFFSET_11(B), B2
  movaps 0x20+B_OFFSET_11(B), B3
  movaps 0x30+B_OFFSET_11(B), B4
  movaps 0x0+A_OFFSET_21(A), A11
  movaps 0x10+A_OFFSET_21(A), A12
  movaps 0x20+A_OFFSET_21(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_21(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_21(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_21(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_21(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_21(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_21(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_21(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_21(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_21(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_21(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_21(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_21(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_21(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,1) to already existing.
  addps 0x0+C_OFFSET_21(C), C1
  addps 0x10+C_OFFSET_21(C), C2
  addps 0x20+C_OFFSET_21(C), C3
  addps 0x30+C_OFFSET_21(C), C4

  # Write out C(2,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_21(C)
  movaps C2, 0x10+C_OFFSET_21(C)
  movaps C3, 0x20+C_OFFSET_21(C)
  movaps C4, 0x30+C_OFFSET_21(C)

  .align 16
block_6:

  # Check norm of product A(2,2)*B(2,1).
  movss 0x3c(multiply_stream, base_pointer), B1
  mulss 0x138(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_7

  # Reset C(2,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,1) = A(2,2)*B(2,1).
  movaps 0x0+B_OFFSET_21(B), B1
  movaps 0x10+B_OFFSET_21(B), B2
  movaps 0x20+B_OFFSET_21(B), B3
  movaps 0x30+B_OFFSET_21(B), B4
  movaps 0x0+A_OFFSET_22(A), A11
  movaps 0x10+A_OFFSET_22(A), A12
  movaps 0x20+A_OFFSET_22(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_22(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_22(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_22(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_22(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_22(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_22(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_22(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_22(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_22(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_22(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_22(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_22(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_22(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,1) to already existing.
  addps 0x0+C_OFFSET_21(C), C1
  addps 0x10+C_OFFSET_21(C), C2
  addps 0x20+C_OFFSET_21(C), C3
  addps 0x30+C_OFFSET_21(C), C4

  # Write out C(2,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_21(C)
  movaps C2, 0x10+C_OFFSET_21(C)
  movaps C3, 0x20+C_OFFSET_21(C)
  movaps C4, 0x30+C_OFFSET_21(C)

  .align 16
block_7:

  # Check norm of product A(2,1)*B(1,2).
  movss 0x38(multiply_stream, base_pointer), B1
  mulss 0x11c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_8

  # Reset C(2,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,2) = A(2,1)*B(1,2).
  movaps 0x0+B_OFFSET_12(B), B1
  movaps 0x10+B_OFFSET_12(B), B2
  movaps 0x20+B_OFFSET_12(B), B3
  movaps 0x30+B_OFFSET_12(B), B4
  movaps 0x0+A_OFFSET_21(A), A11
  movaps 0x10+A_OFFSET_21(A), A12
  movaps 0x20+A_OFFSET_21(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_21(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_21(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_21(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_21(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_21(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_21(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_21(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_21(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_21(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_21(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_21(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_21(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_21(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,2) to already existing.
  addps 0x0+C_OFFSET_22(C), C1
  addps 0x10+C_OFFSET_22(C), C2
  addps 0x20+C_OFFSET_22(C), C3
  addps 0x30+C_OFFSET_22(C), C4

  # Write out C(2,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_22(C)
  movaps C2, 0x10+C_OFFSET_22(C)
  movaps C3, 0x20+C_OFFSET_22(C)
  movaps C4, 0x30+C_OFFSET_22(C)

  .align 16
block_8:

  # Check norm of product A(2,2)*B(2,2).
  movss 0x3c(multiply_stream, base_pointer), B1
  mulss 0x13c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_9

  # Reset C(2,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,2) = A(2,2)*B(2,2).
  movaps 0x0+B_OFFSET_22(B), B1
  movaps 0x10+B_OFFSET_22(B), B2
  movaps 0x20+B_OFFSET_22(B), B3
  movaps 0x30+B_OFFSET_22(B), B4
  movaps 0x0+A_OFFSET_22(A), A11
  movaps 0x10+A_OFFSET_22(A), A12
  movaps 0x20+A_OFFSET_22(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_22(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_22(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_22(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_22(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_22(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_22(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_22(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_22(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_22(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_22(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_22(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_22(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_22(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,2) to already existing.
  addps 0x0+C_OFFSET_22(C), C1
  addps 0x10+C_OFFSET_22(C), C2
  addps 0x20+C_OFFSET_22(C), C3
  addps 0x30+C_OFFSET_22(C), C4

  # Write out C(2,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_22(C)
  movaps C2, 0x10+C_OFFSET_22(C)
  movaps C3, 0x20+C_OFFSET_22(C)
  movaps C4, 0x30+C_OFFSET_22(C)

  .align 16
block_9:

  # Check norm of product A(1,3)*B(3,1).
  movss 0x20(multiply_stream, base_pointer), B1
  mulss 0x158(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_10

  # Reset C(1,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,1) = A(1,3)*B(3,1).
  movaps 0x0+B_OFFSET_31(B), B1
  movaps 0x10+B_OFFSET_31(B), B2
  movaps 0x20+B_OFFSET_31(B), B3
  movaps 0x30+B_OFFSET_31(B), B4
  movaps 0x0+A_OFFSET_13(A), A11
  movaps 0x10+A_OFFSET_13(A), A12
  movaps 0x20+A_OFFSET_13(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_13(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_13(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_13(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_13(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_13(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_13(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_13(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_13(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_13(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_13(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_13(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_13(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_13(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,1) to already existing.
  addps 0x0+C_OFFSET_11(C), C1
  addps 0x10+C_OFFSET_11(C), C2
  addps 0x20+C_OFFSET_11(C), C3
  addps 0x30+C_OFFSET_11(C), C4

  # Write out C(1,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_11(C)
  movaps C2, 0x10+C_OFFSET_11(C)
  movaps C3, 0x20+C_OFFSET_11(C)
  movaps C4, 0x30+C_OFFSET_11(C)

  .align 16
block_10:

  # Check norm of product A(1,4)*B(4,1).
  movss 0x24(multiply_stream, base_pointer), B1
  mulss 0x178(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_11

  # Reset C(1,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,1) = A(1,4)*B(4,1).
  movaps 0x0+B_OFFSET_41(B), B1
  movaps 0x10+B_OFFSET_41(B), B2
  movaps 0x20+B_OFFSET_41(B), B3
  movaps 0x30+B_OFFSET_41(B), B4
  movaps 0x0+A_OFFSET_14(A), A11
  movaps 0x10+A_OFFSET_14(A), A12
  movaps 0x20+A_OFFSET_14(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_14(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_14(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_14(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_14(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_14(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_14(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_14(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_14(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_14(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_14(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_14(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_14(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_14(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,1) to already existing.
  addps 0x0+C_OFFSET_11(C), C1
  addps 0x10+C_OFFSET_11(C), C2
  addps 0x20+C_OFFSET_11(C), C3
  addps 0x30+C_OFFSET_11(C), C4

  # Write out C(1,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_11(C)
  movaps C2, 0x10+C_OFFSET_11(C)
  movaps C3, 0x20+C_OFFSET_11(C)
  movaps C4, 0x30+C_OFFSET_11(C)

  .align 16
block_11:

  # Check norm of product A(1,3)*B(3,2).
  movss 0x20(multiply_stream, base_pointer), B1
  mulss 0x15c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_12

  # Reset C(1,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,2) = A(1,3)*B(3,2).
  movaps 0x0+B_OFFSET_32(B), B1
  movaps 0x10+B_OFFSET_32(B), B2
  movaps 0x20+B_OFFSET_32(B), B3
  movaps 0x30+B_OFFSET_32(B), B4
  movaps 0x0+A_OFFSET_13(A), A11
  movaps 0x10+A_OFFSET_13(A), A12
  movaps 0x20+A_OFFSET_13(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_13(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_13(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_13(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_13(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_13(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_13(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_13(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_13(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_13(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_13(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_13(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_13(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_13(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,2) to already existing.
  addps 0x0+C_OFFSET_12(C), C1
  addps 0x10+C_OFFSET_12(C), C2
  addps 0x20+C_OFFSET_12(C), C3
  addps 0x30+C_OFFSET_12(C), C4

  # Write out C(1,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_12(C)
  movaps C2, 0x10+C_OFFSET_12(C)
  movaps C3, 0x20+C_OFFSET_12(C)
  movaps C4, 0x30+C_OFFSET_12(C)

  .align 16
block_12:

  # Check norm of product A(1,4)*B(4,2).
  movss 0x24(multiply_stream, base_pointer), B1
  mulss 0x17c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_13

  # Reset C(1,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,2) = A(1,4)*B(4,2).
  movaps 0x0+B_OFFSET_42(B), B1
  movaps 0x10+B_OFFSET_42(B), B2
  movaps 0x20+B_OFFSET_42(B), B3
  movaps 0x30+B_OFFSET_42(B), B4
  movaps 0x0+A_OFFSET_14(A), A11
  movaps 0x10+A_OFFSET_14(A), A12
  movaps 0x20+A_OFFSET_14(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_14(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_14(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_14(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_14(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_14(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_14(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_14(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_14(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_14(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_14(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_14(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_14(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_14(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,2) to already existing.
  addps 0x0+C_OFFSET_12(C), C1
  addps 0x10+C_OFFSET_12(C), C2
  addps 0x20+C_OFFSET_12(C), C3
  addps 0x30+C_OFFSET_12(C), C4

  # Write out C(1,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_12(C)
  movaps C2, 0x10+C_OFFSET_12(C)
  movaps C3, 0x20+C_OFFSET_12(C)
  movaps C4, 0x30+C_OFFSET_12(C)

  .align 16
block_13:

  # Check norm of product A(2,3)*B(3,1).
  movss 0x40(multiply_stream, base_pointer), B1
  mulss 0x158(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_14

  # Reset C(2,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,1) = A(2,3)*B(3,1).
  movaps 0x0+B_OFFSET_31(B), B1
  movaps 0x10+B_OFFSET_31(B), B2
  movaps 0x20+B_OFFSET_31(B), B3
  movaps 0x30+B_OFFSET_31(B), B4
  movaps 0x0+A_OFFSET_23(A), A11
  movaps 0x10+A_OFFSET_23(A), A12
  movaps 0x20+A_OFFSET_23(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_23(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_23(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_23(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_23(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_23(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_23(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_23(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_23(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_23(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_23(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_23(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_23(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_23(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,1) to already existing.
  addps 0x0+C_OFFSET_21(C), C1
  addps 0x10+C_OFFSET_21(C), C2
  addps 0x20+C_OFFSET_21(C), C3
  addps 0x30+C_OFFSET_21(C), C4

  # Write out C(2,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_21(C)
  movaps C2, 0x10+C_OFFSET_21(C)
  movaps C3, 0x20+C_OFFSET_21(C)
  movaps C4, 0x30+C_OFFSET_21(C)

  .align 16
block_14:

  # Check norm of product A(2,4)*B(4,1).
  movss 0x44(multiply_stream, base_pointer), B1
  mulss 0x178(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_15

  # Reset C(2,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,1) = A(2,4)*B(4,1).
  movaps 0x0+B_OFFSET_41(B), B1
  movaps 0x10+B_OFFSET_41(B), B2
  movaps 0x20+B_OFFSET_41(B), B3
  movaps 0x30+B_OFFSET_41(B), B4
  movaps 0x0+A_OFFSET_24(A), A11
  movaps 0x10+A_OFFSET_24(A), A12
  movaps 0x20+A_OFFSET_24(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_24(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_24(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_24(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_24(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_24(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_24(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_24(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_24(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_24(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_24(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_24(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_24(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_24(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,1) to already existing.
  addps 0x0+C_OFFSET_21(C), C1
  addps 0x10+C_OFFSET_21(C), C2
  addps 0x20+C_OFFSET_21(C), C3
  addps 0x30+C_OFFSET_21(C), C4

  # Write out C(2,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_21(C)
  movaps C2, 0x10+C_OFFSET_21(C)
  movaps C3, 0x20+C_OFFSET_21(C)
  movaps C4, 0x30+C_OFFSET_21(C)

  .align 16
block_15:

  # Check norm of product A(2,3)*B(3,2).
  movss 0x40(multiply_stream, base_pointer), B1
  mulss 0x15c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_16

  # Reset C(2,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,2) = A(2,3)*B(3,2).
  movaps 0x0+B_OFFSET_32(B), B1
  movaps 0x10+B_OFFSET_32(B), B2
  movaps 0x20+B_OFFSET_32(B), B3
  movaps 0x30+B_OFFSET_32(B), B4
  movaps 0x0+A_OFFSET_23(A), A11
  movaps 0x10+A_OFFSET_23(A), A12
  movaps 0x20+A_OFFSET_23(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_23(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_23(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_23(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_23(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_23(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_23(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_23(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_23(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_23(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_23(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_23(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_23(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_23(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,2) to already existing.
  addps 0x0+C_OFFSET_22(C), C1
  addps 0x10+C_OFFSET_22(C), C2
  addps 0x20+C_OFFSET_22(C), C3
  addps 0x30+C_OFFSET_22(C), C4

  # Write out C(2,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_22(C)
  movaps C2, 0x10+C_OFFSET_22(C)
  movaps C3, 0x20+C_OFFSET_22(C)
  movaps C4, 0x30+C_OFFSET_22(C)

  .align 16
block_16:

  # Check norm of product A(2,4)*B(4,2).
  movss 0x44(multiply_stream, base_pointer), B1
  mulss 0x17c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_17

  # Reset C(2,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,2) = A(2,4)*B(4,2).
  movaps 0x0+B_OFFSET_42(B), B1
  movaps 0x10+B_OFFSET_42(B), B2
  movaps 0x20+B_OFFSET_42(B), B3
  movaps 0x30+B_OFFSET_42(B), B4
  movaps 0x0+A_OFFSET_24(A), A11
  movaps 0x10+A_OFFSET_24(A), A12
  movaps 0x20+A_OFFSET_24(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_24(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_24(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_24(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_24(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_24(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_24(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_24(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_24(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_24(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_24(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_24(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_24(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_24(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,2) to already existing.
  addps 0x0+C_OFFSET_22(C), C1
  addps 0x10+C_OFFSET_22(C), C2
  addps 0x20+C_OFFSET_22(C), C3
  addps 0x30+C_OFFSET_22(C), C4

  # Write out C(2,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_22(C)
  movaps C2, 0x10+C_OFFSET_22(C)
  movaps C3, 0x20+C_OFFSET_22(C)
  movaps C4, 0x30+C_OFFSET_22(C)

  .align 16
block_17:

  # Check norm of product A(1,1)*B(1,3).
  movss 0x18(multiply_stream, base_pointer), B1
  mulss 0x120(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_18

  # Reset C(1,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,3) = A(1,1)*B(1,3).
  movaps 0x0+B_OFFSET_13(B), B1
  movaps 0x10+B_OFFSET_13(B), B2
  movaps 0x20+B_OFFSET_13(B), B3
  movaps 0x30+B_OFFSET_13(B), B4
  movaps 0x0+A_OFFSET_11(A), A11
  movaps 0x10+A_OFFSET_11(A), A12
  movaps 0x20+A_OFFSET_11(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_11(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_11(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_11(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_11(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_11(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_11(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_11(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_11(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_11(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_11(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_11(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_11(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_11(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,3) to already existing.
  addps 0x0+C_OFFSET_13(C), C1
  addps 0x10+C_OFFSET_13(C), C2
  addps 0x20+C_OFFSET_13(C), C3
  addps 0x30+C_OFFSET_13(C), C4

  # Write out C(1,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_13(C)
  movaps C2, 0x10+C_OFFSET_13(C)
  movaps C3, 0x20+C_OFFSET_13(C)
  movaps C4, 0x30+C_OFFSET_13(C)

  .align 16
block_18:

  # Check norm of product A(1,2)*B(2,3).
  movss 0x1c(multiply_stream, base_pointer), B1
  mulss 0x140(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_19

  # Reset C(1,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,3) = A(1,2)*B(2,3).
  movaps 0x0+B_OFFSET_23(B), B1
  movaps 0x10+B_OFFSET_23(B), B2
  movaps 0x20+B_OFFSET_23(B), B3
  movaps 0x30+B_OFFSET_23(B), B4
  movaps 0x0+A_OFFSET_12(A), A11
  movaps 0x10+A_OFFSET_12(A), A12
  movaps 0x20+A_OFFSET_12(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_12(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_12(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_12(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_12(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_12(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_12(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_12(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_12(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_12(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_12(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_12(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_12(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_12(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,3) to already existing.
  addps 0x0+C_OFFSET_13(C), C1
  addps 0x10+C_OFFSET_13(C), C2
  addps 0x20+C_OFFSET_13(C), C3
  addps 0x30+C_OFFSET_13(C), C4

  # Write out C(1,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_13(C)
  movaps C2, 0x10+C_OFFSET_13(C)
  movaps C3, 0x20+C_OFFSET_13(C)
  movaps C4, 0x30+C_OFFSET_13(C)

  .align 16
block_19:

  # Check norm of product A(1,1)*B(1,4).
  movss 0x18(multiply_stream, base_pointer), B1
  mulss 0x124(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_20

  # Reset C(1,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,4) = A(1,1)*B(1,4).
  movaps 0x0+B_OFFSET_14(B), B1
  movaps 0x10+B_OFFSET_14(B), B2
  movaps 0x20+B_OFFSET_14(B), B3
  movaps 0x30+B_OFFSET_14(B), B4
  movaps 0x0+A_OFFSET_11(A), A11
  movaps 0x10+A_OFFSET_11(A), A12
  movaps 0x20+A_OFFSET_11(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_11(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_11(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_11(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_11(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_11(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_11(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_11(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_11(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_11(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_11(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_11(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_11(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_11(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,4) to already existing.
  addps 0x0+C_OFFSET_14(C), C1
  addps 0x10+C_OFFSET_14(C), C2
  addps 0x20+C_OFFSET_14(C), C3
  addps 0x30+C_OFFSET_14(C), C4

  # Write out C(1,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_14(C)
  movaps C2, 0x10+C_OFFSET_14(C)
  movaps C3, 0x20+C_OFFSET_14(C)
  movaps C4, 0x30+C_OFFSET_14(C)

  .align 16
block_20:

  # Check norm of product A(1,2)*B(2,4).
  movss 0x1c(multiply_stream, base_pointer), B1
  mulss 0x144(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_21

  # Reset C(1,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,4) = A(1,2)*B(2,4).
  movaps 0x0+B_OFFSET_24(B), B1
  movaps 0x10+B_OFFSET_24(B), B2
  movaps 0x20+B_OFFSET_24(B), B3
  movaps 0x30+B_OFFSET_24(B), B4
  movaps 0x0+A_OFFSET_12(A), A11
  movaps 0x10+A_OFFSET_12(A), A12
  movaps 0x20+A_OFFSET_12(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_12(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_12(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_12(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_12(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_12(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_12(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_12(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_12(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_12(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_12(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_12(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_12(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_12(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,4) to already existing.
  addps 0x0+C_OFFSET_14(C), C1
  addps 0x10+C_OFFSET_14(C), C2
  addps 0x20+C_OFFSET_14(C), C3
  addps 0x30+C_OFFSET_14(C), C4

  # Write out C(1,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_14(C)
  movaps C2, 0x10+C_OFFSET_14(C)
  movaps C3, 0x20+C_OFFSET_14(C)
  movaps C4, 0x30+C_OFFSET_14(C)

  .align 16
block_21:

  # Check norm of product A(2,1)*B(1,3).
  movss 0x38(multiply_stream, base_pointer), B1
  mulss 0x120(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_22

  # Reset C(2,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,3) = A(2,1)*B(1,3).
  movaps 0x0+B_OFFSET_13(B), B1
  movaps 0x10+B_OFFSET_13(B), B2
  movaps 0x20+B_OFFSET_13(B), B3
  movaps 0x30+B_OFFSET_13(B), B4
  movaps 0x0+A_OFFSET_21(A), A11
  movaps 0x10+A_OFFSET_21(A), A12
  movaps 0x20+A_OFFSET_21(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_21(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_21(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_21(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_21(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_21(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_21(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_21(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_21(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_21(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_21(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_21(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_21(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_21(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,3) to already existing.
  addps 0x0+C_OFFSET_23(C), C1
  addps 0x10+C_OFFSET_23(C), C2
  addps 0x20+C_OFFSET_23(C), C3
  addps 0x30+C_OFFSET_23(C), C4

  # Write out C(2,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_23(C)
  movaps C2, 0x10+C_OFFSET_23(C)
  movaps C3, 0x20+C_OFFSET_23(C)
  movaps C4, 0x30+C_OFFSET_23(C)

  .align 16
block_22:

  # Check norm of product A(2,2)*B(2,3).
  movss 0x3c(multiply_stream, base_pointer), B1
  mulss 0x140(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_23

  # Reset C(2,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,3) = A(2,2)*B(2,3).
  movaps 0x0+B_OFFSET_23(B), B1
  movaps 0x10+B_OFFSET_23(B), B2
  movaps 0x20+B_OFFSET_23(B), B3
  movaps 0x30+B_OFFSET_23(B), B4
  movaps 0x0+A_OFFSET_22(A), A11
  movaps 0x10+A_OFFSET_22(A), A12
  movaps 0x20+A_OFFSET_22(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_22(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_22(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_22(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_22(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_22(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_22(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_22(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_22(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_22(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_22(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_22(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_22(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_22(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,3) to already existing.
  addps 0x0+C_OFFSET_23(C), C1
  addps 0x10+C_OFFSET_23(C), C2
  addps 0x20+C_OFFSET_23(C), C3
  addps 0x30+C_OFFSET_23(C), C4

  # Write out C(2,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_23(C)
  movaps C2, 0x10+C_OFFSET_23(C)
  movaps C3, 0x20+C_OFFSET_23(C)
  movaps C4, 0x30+C_OFFSET_23(C)

  .align 16
block_23:

  # Check norm of product A(2,1)*B(1,4).
  movss 0x38(multiply_stream, base_pointer), B1
  mulss 0x124(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_24

  # Reset C(2,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,4) = A(2,1)*B(1,4).
  movaps 0x0+B_OFFSET_14(B), B1
  movaps 0x10+B_OFFSET_14(B), B2
  movaps 0x20+B_OFFSET_14(B), B3
  movaps 0x30+B_OFFSET_14(B), B4
  movaps 0x0+A_OFFSET_21(A), A11
  movaps 0x10+A_OFFSET_21(A), A12
  movaps 0x20+A_OFFSET_21(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_21(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_21(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_21(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_21(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_21(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_21(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_21(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_21(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_21(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_21(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_21(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_21(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_21(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,4) to already existing.
  addps 0x0+C_OFFSET_24(C), C1
  addps 0x10+C_OFFSET_24(C), C2
  addps 0x20+C_OFFSET_24(C), C3
  addps 0x30+C_OFFSET_24(C), C4

  # Write out C(2,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_24(C)
  movaps C2, 0x10+C_OFFSET_24(C)
  movaps C3, 0x20+C_OFFSET_24(C)
  movaps C4, 0x30+C_OFFSET_24(C)

  .align 16
block_24:

  # Check norm of product A(2,2)*B(2,4).
  movss 0x3c(multiply_stream, base_pointer), B1
  mulss 0x144(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_25

  # Reset C(2,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,4) = A(2,2)*B(2,4).
  movaps 0x0+B_OFFSET_24(B), B1
  movaps 0x10+B_OFFSET_24(B), B2
  movaps 0x20+B_OFFSET_24(B), B3
  movaps 0x30+B_OFFSET_24(B), B4
  movaps 0x0+A_OFFSET_22(A), A11
  movaps 0x10+A_OFFSET_22(A), A12
  movaps 0x20+A_OFFSET_22(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_22(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_22(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_22(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_22(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_22(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_22(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_22(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_22(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_22(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_22(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_22(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_22(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_22(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,4) to already existing.
  addps 0x0+C_OFFSET_24(C), C1
  addps 0x10+C_OFFSET_24(C), C2
  addps 0x20+C_OFFSET_24(C), C3
  addps 0x30+C_OFFSET_24(C), C4

  # Write out C(2,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_24(C)
  movaps C2, 0x10+C_OFFSET_24(C)
  movaps C3, 0x20+C_OFFSET_24(C)
  movaps C4, 0x30+C_OFFSET_24(C)

  .align 16
block_25:

  # Check norm of product A(1,3)*B(3,3).
  movss 0x20(multiply_stream, base_pointer), B1
  mulss 0x160(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_26

  # Reset C(1,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,3) = A(1,3)*B(3,3).
  movaps 0x0+B_OFFSET_33(B), B1
  movaps 0x10+B_OFFSET_33(B), B2
  movaps 0x20+B_OFFSET_33(B), B3
  movaps 0x30+B_OFFSET_33(B), B4
  movaps 0x0+A_OFFSET_13(A), A11
  movaps 0x10+A_OFFSET_13(A), A12
  movaps 0x20+A_OFFSET_13(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_13(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_13(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_13(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_13(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_13(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_13(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_13(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_13(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_13(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_13(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_13(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_13(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_13(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,3) to already existing.
  addps 0x0+C_OFFSET_13(C), C1
  addps 0x10+C_OFFSET_13(C), C2
  addps 0x20+C_OFFSET_13(C), C3
  addps 0x30+C_OFFSET_13(C), C4

  # Write out C(1,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_13(C)
  movaps C2, 0x10+C_OFFSET_13(C)
  movaps C3, 0x20+C_OFFSET_13(C)
  movaps C4, 0x30+C_OFFSET_13(C)

  .align 16
block_26:

  # Check norm of product A(1,4)*B(4,3).
  movss 0x24(multiply_stream, base_pointer), B1
  mulss 0x180(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_27

  # Reset C(1,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,3) = A(1,4)*B(4,3).
  movaps 0x0+B_OFFSET_43(B), B1
  movaps 0x10+B_OFFSET_43(B), B2
  movaps 0x20+B_OFFSET_43(B), B3
  movaps 0x30+B_OFFSET_43(B), B4
  movaps 0x0+A_OFFSET_14(A), A11
  movaps 0x10+A_OFFSET_14(A), A12
  movaps 0x20+A_OFFSET_14(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_14(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_14(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_14(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_14(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_14(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_14(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_14(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_14(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_14(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_14(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_14(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_14(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_14(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,3) to already existing.
  addps 0x0+C_OFFSET_13(C), C1
  addps 0x10+C_OFFSET_13(C), C2
  addps 0x20+C_OFFSET_13(C), C3
  addps 0x30+C_OFFSET_13(C), C4

  # Write out C(1,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_13(C)
  movaps C2, 0x10+C_OFFSET_13(C)
  movaps C3, 0x20+C_OFFSET_13(C)
  movaps C4, 0x30+C_OFFSET_13(C)

  .align 16
block_27:

  # Check norm of product A(1,3)*B(3,4).
  movss 0x20(multiply_stream, base_pointer), B1
  mulss 0x164(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_28

  # Reset C(1,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,4) = A(1,3)*B(3,4).
  movaps 0x0+B_OFFSET_34(B), B1
  movaps 0x10+B_OFFSET_34(B), B2
  movaps 0x20+B_OFFSET_34(B), B3
  movaps 0x30+B_OFFSET_34(B), B4
  movaps 0x0+A_OFFSET_13(A), A11
  movaps 0x10+A_OFFSET_13(A), A12
  movaps 0x20+A_OFFSET_13(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_13(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_13(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_13(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_13(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_13(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_13(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_13(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_13(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_13(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_13(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_13(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_13(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_13(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,4) to already existing.
  addps 0x0+C_OFFSET_14(C), C1
  addps 0x10+C_OFFSET_14(C), C2
  addps 0x20+C_OFFSET_14(C), C3
  addps 0x30+C_OFFSET_14(C), C4

  # Write out C(1,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_14(C)
  movaps C2, 0x10+C_OFFSET_14(C)
  movaps C3, 0x20+C_OFFSET_14(C)
  movaps C4, 0x30+C_OFFSET_14(C)

  .align 16
block_28:

  # Check norm of product A(1,4)*B(4,4).
  movss 0x24(multiply_stream, base_pointer), B1
  mulss 0x184(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_29

  # Reset C(1,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,4) = A(1,4)*B(4,4).
  movaps 0x0+B_OFFSET_44(B), B1
  movaps 0x10+B_OFFSET_44(B), B2
  movaps 0x20+B_OFFSET_44(B), B3
  movaps 0x30+B_OFFSET_44(B), B4
  movaps 0x0+A_OFFSET_14(A), A11
  movaps 0x10+A_OFFSET_14(A), A12
  movaps 0x20+A_OFFSET_14(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_14(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_14(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_14(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_14(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_14(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_14(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_14(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_14(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_14(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_14(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_14(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_14(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_14(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,4) to already existing.
  addps 0x0+C_OFFSET_14(C), C1
  addps 0x10+C_OFFSET_14(C), C2
  addps 0x20+C_OFFSET_14(C), C3
  addps 0x30+C_OFFSET_14(C), C4

  # Write out C(1,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_14(C)
  movaps C2, 0x10+C_OFFSET_14(C)
  movaps C3, 0x20+C_OFFSET_14(C)
  movaps C4, 0x30+C_OFFSET_14(C)

  .align 16
block_29:

  # Check norm of product A(2,3)*B(3,3).
  movss 0x40(multiply_stream, base_pointer), B1
  mulss 0x160(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_30

  # Reset C(2,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,3) = A(2,3)*B(3,3).
  movaps 0x0+B_OFFSET_33(B), B1
  movaps 0x10+B_OFFSET_33(B), B2
  movaps 0x20+B_OFFSET_33(B), B3
  movaps 0x30+B_OFFSET_33(B), B4
  movaps 0x0+A_OFFSET_23(A), A11
  movaps 0x10+A_OFFSET_23(A), A12
  movaps 0x20+A_OFFSET_23(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_23(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_23(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_23(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_23(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_23(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_23(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_23(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_23(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_23(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_23(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_23(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_23(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_23(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,3) to already existing.
  addps 0x0+C_OFFSET_23(C), C1
  addps 0x10+C_OFFSET_23(C), C2
  addps 0x20+C_OFFSET_23(C), C3
  addps 0x30+C_OFFSET_23(C), C4

  # Write out C(2,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_23(C)
  movaps C2, 0x10+C_OFFSET_23(C)
  movaps C3, 0x20+C_OFFSET_23(C)
  movaps C4, 0x30+C_OFFSET_23(C)

  .align 16
block_30:

  # Check norm of product A(2,4)*B(4,3).
  movss 0x44(multiply_stream, base_pointer), B1
  mulss 0x180(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_31

  # Reset C(2,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,3) = A(2,4)*B(4,3).
  movaps 0x0+B_OFFSET_43(B), B1
  movaps 0x10+B_OFFSET_43(B), B2
  movaps 0x20+B_OFFSET_43(B), B3
  movaps 0x30+B_OFFSET_43(B), B4
  movaps 0x0+A_OFFSET_24(A), A11
  movaps 0x10+A_OFFSET_24(A), A12
  movaps 0x20+A_OFFSET_24(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_24(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_24(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_24(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_24(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_24(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_24(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_24(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_24(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_24(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_24(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_24(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_24(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_24(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,3) to already existing.
  addps 0x0+C_OFFSET_23(C), C1
  addps 0x10+C_OFFSET_23(C), C2
  addps 0x20+C_OFFSET_23(C), C3
  addps 0x30+C_OFFSET_23(C), C4

  # Write out C(2,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_23(C)
  movaps C2, 0x10+C_OFFSET_23(C)
  movaps C3, 0x20+C_OFFSET_23(C)
  movaps C4, 0x30+C_OFFSET_23(C)

  .align 16
block_31:

  # Check norm of product A(2,3)*B(3,4).
  movss 0x40(multiply_stream, base_pointer), B1
  mulss 0x164(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_32

  # Reset C(2,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,4) = A(2,3)*B(3,4).
  movaps 0x0+B_OFFSET_34(B), B1
  movaps 0x10+B_OFFSET_34(B), B2
  movaps 0x20+B_OFFSET_34(B), B3
  movaps 0x30+B_OFFSET_34(B), B4
  movaps 0x0+A_OFFSET_23(A), A11
  movaps 0x10+A_OFFSET_23(A), A12
  movaps 0x20+A_OFFSET_23(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_23(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_23(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_23(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_23(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_23(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_23(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_23(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_23(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_23(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_23(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_23(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_23(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_23(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,4) to already existing.
  addps 0x0+C_OFFSET_24(C), C1
  addps 0x10+C_OFFSET_24(C), C2
  addps 0x20+C_OFFSET_24(C), C3
  addps 0x30+C_OFFSET_24(C), C4

  # Write out C(2,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_24(C)
  movaps C2, 0x10+C_OFFSET_24(C)
  movaps C3, 0x20+C_OFFSET_24(C)
  movaps C4, 0x30+C_OFFSET_24(C)

  .align 16
block_32:

  # Check norm of product A(2,4)*B(4,4).
  movss 0x44(multiply_stream, base_pointer), B1
  mulss 0x184(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_33

  # Reset C(2,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,4) = A(2,4)*B(4,4).
  movaps 0x0+B_OFFSET_44(B), B1
  movaps 0x10+B_OFFSET_44(B), B2
  movaps 0x20+B_OFFSET_44(B), B3
  movaps 0x30+B_OFFSET_44(B), B4
  movaps 0x0+A_OFFSET_24(A), A11
  movaps 0x10+A_OFFSET_24(A), A12
  movaps 0x20+A_OFFSET_24(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_24(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_24(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_24(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_24(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_24(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_24(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_24(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_24(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_24(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_24(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_24(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_24(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_24(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,4) to already existing.
  addps 0x0+C_OFFSET_24(C), C1
  addps 0x10+C_OFFSET_24(C), C2
  addps 0x20+C_OFFSET_24(C), C3
  addps 0x30+C_OFFSET_24(C), C4

  # Write out C(2,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_24(C)
  movaps C2, 0x10+C_OFFSET_24(C)
  movaps C3, 0x20+C_OFFSET_24(C)
  movaps C4, 0x30+C_OFFSET_24(C)

  .align 16
block_33:

  # Check norm of product A(3,1)*B(1,1).
  movss 0x58(multiply_stream, base_pointer), B1
  mulss 0x118(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_34

  # Reset C(3,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,1) = A(3,1)*B(1,1).
  movaps 0x0+B_OFFSET_11(B), B1
  movaps 0x10+B_OFFSET_11(B), B2
  movaps 0x20+B_OFFSET_11(B), B3
  movaps 0x30+B_OFFSET_11(B), B4
  movaps 0x0+A_OFFSET_31(A), A11
  movaps 0x10+A_OFFSET_31(A), A12
  movaps 0x20+A_OFFSET_31(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_31(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_31(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_31(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_31(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_31(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_31(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_31(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_31(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_31(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_31(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_31(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_31(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_31(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,1) to already existing.
  addps 0x0+C_OFFSET_31(C), C1
  addps 0x10+C_OFFSET_31(C), C2
  addps 0x20+C_OFFSET_31(C), C3
  addps 0x30+C_OFFSET_31(C), C4

  # Write out C(3,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_31(C)
  movaps C2, 0x10+C_OFFSET_31(C)
  movaps C3, 0x20+C_OFFSET_31(C)
  movaps C4, 0x30+C_OFFSET_31(C)

  .align 16
block_34:

  # Check norm of product A(3,2)*B(2,1).
  movss 0x5c(multiply_stream, base_pointer), B1
  mulss 0x138(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_35

  # Reset C(3,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,1) = A(3,2)*B(2,1).
  movaps 0x0+B_OFFSET_21(B), B1
  movaps 0x10+B_OFFSET_21(B), B2
  movaps 0x20+B_OFFSET_21(B), B3
  movaps 0x30+B_OFFSET_21(B), B4
  movaps 0x0+A_OFFSET_32(A), A11
  movaps 0x10+A_OFFSET_32(A), A12
  movaps 0x20+A_OFFSET_32(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_32(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_32(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_32(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_32(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_32(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_32(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_32(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_32(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_32(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_32(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_32(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_32(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_32(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,1) to already existing.
  addps 0x0+C_OFFSET_31(C), C1
  addps 0x10+C_OFFSET_31(C), C2
  addps 0x20+C_OFFSET_31(C), C3
  addps 0x30+C_OFFSET_31(C), C4

  # Write out C(3,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_31(C)
  movaps C2, 0x10+C_OFFSET_31(C)
  movaps C3, 0x20+C_OFFSET_31(C)
  movaps C4, 0x30+C_OFFSET_31(C)

  .align 16
block_35:

  # Check norm of product A(3,1)*B(1,2).
  movss 0x58(multiply_stream, base_pointer), B1
  mulss 0x11c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_36

  # Reset C(3,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,2) = A(3,1)*B(1,2).
  movaps 0x0+B_OFFSET_12(B), B1
  movaps 0x10+B_OFFSET_12(B), B2
  movaps 0x20+B_OFFSET_12(B), B3
  movaps 0x30+B_OFFSET_12(B), B4
  movaps 0x0+A_OFFSET_31(A), A11
  movaps 0x10+A_OFFSET_31(A), A12
  movaps 0x20+A_OFFSET_31(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_31(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_31(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_31(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_31(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_31(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_31(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_31(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_31(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_31(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_31(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_31(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_31(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_31(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,2) to already existing.
  addps 0x0+C_OFFSET_32(C), C1
  addps 0x10+C_OFFSET_32(C), C2
  addps 0x20+C_OFFSET_32(C), C3
  addps 0x30+C_OFFSET_32(C), C4

  # Write out C(3,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_32(C)
  movaps C2, 0x10+C_OFFSET_32(C)
  movaps C3, 0x20+C_OFFSET_32(C)
  movaps C4, 0x30+C_OFFSET_32(C)

  .align 16
block_36:

  # Check norm of product A(3,2)*B(2,2).
  movss 0x5c(multiply_stream, base_pointer), B1
  mulss 0x13c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_37

  # Reset C(3,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,2) = A(3,2)*B(2,2).
  movaps 0x0+B_OFFSET_22(B), B1
  movaps 0x10+B_OFFSET_22(B), B2
  movaps 0x20+B_OFFSET_22(B), B3
  movaps 0x30+B_OFFSET_22(B), B4
  movaps 0x0+A_OFFSET_32(A), A11
  movaps 0x10+A_OFFSET_32(A), A12
  movaps 0x20+A_OFFSET_32(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_32(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_32(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_32(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_32(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_32(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_32(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_32(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_32(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_32(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_32(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_32(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_32(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_32(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,2) to already existing.
  addps 0x0+C_OFFSET_32(C), C1
  addps 0x10+C_OFFSET_32(C), C2
  addps 0x20+C_OFFSET_32(C), C3
  addps 0x30+C_OFFSET_32(C), C4

  # Write out C(3,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_32(C)
  movaps C2, 0x10+C_OFFSET_32(C)
  movaps C3, 0x20+C_OFFSET_32(C)
  movaps C4, 0x30+C_OFFSET_32(C)

  .align 16
block_37:

  # Check norm of product A(4,1)*B(1,1).
  movss 0x78(multiply_stream, base_pointer), B1
  mulss 0x118(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_38

  # Reset C(4,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,1) = A(4,1)*B(1,1).
  movaps 0x0+B_OFFSET_11(B), B1
  movaps 0x10+B_OFFSET_11(B), B2
  movaps 0x20+B_OFFSET_11(B), B3
  movaps 0x30+B_OFFSET_11(B), B4
  movaps 0x0+A_OFFSET_41(A), A11
  movaps 0x10+A_OFFSET_41(A), A12
  movaps 0x20+A_OFFSET_41(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_41(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_41(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_41(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_41(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_41(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_41(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_41(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_41(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_41(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_41(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_41(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_41(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_41(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,1) to already existing.
  addps 0x0+C_OFFSET_41(C), C1
  addps 0x10+C_OFFSET_41(C), C2
  addps 0x20+C_OFFSET_41(C), C3
  addps 0x30+C_OFFSET_41(C), C4

  # Write out C(4,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_41(C)
  movaps C2, 0x10+C_OFFSET_41(C)
  movaps C3, 0x20+C_OFFSET_41(C)
  movaps C4, 0x30+C_OFFSET_41(C)

  .align 16
block_38:

  # Check norm of product A(4,2)*B(2,1).
  movss 0x7c(multiply_stream, base_pointer), B1
  mulss 0x138(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_39

  # Reset C(4,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,1) = A(4,2)*B(2,1).
  movaps 0x0+B_OFFSET_21(B), B1
  movaps 0x10+B_OFFSET_21(B), B2
  movaps 0x20+B_OFFSET_21(B), B3
  movaps 0x30+B_OFFSET_21(B), B4
  movaps 0x0+A_OFFSET_42(A), A11
  movaps 0x10+A_OFFSET_42(A), A12
  movaps 0x20+A_OFFSET_42(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_42(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_42(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_42(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_42(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_42(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_42(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_42(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_42(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_42(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_42(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_42(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_42(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_42(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,1) to already existing.
  addps 0x0+C_OFFSET_41(C), C1
  addps 0x10+C_OFFSET_41(C), C2
  addps 0x20+C_OFFSET_41(C), C3
  addps 0x30+C_OFFSET_41(C), C4

  # Write out C(4,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_41(C)
  movaps C2, 0x10+C_OFFSET_41(C)
  movaps C3, 0x20+C_OFFSET_41(C)
  movaps C4, 0x30+C_OFFSET_41(C)

  .align 16
block_39:

  # Check norm of product A(4,1)*B(1,2).
  movss 0x78(multiply_stream, base_pointer), B1
  mulss 0x11c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_40

  # Reset C(4,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,2) = A(4,1)*B(1,2).
  movaps 0x0+B_OFFSET_12(B), B1
  movaps 0x10+B_OFFSET_12(B), B2
  movaps 0x20+B_OFFSET_12(B), B3
  movaps 0x30+B_OFFSET_12(B), B4
  movaps 0x0+A_OFFSET_41(A), A11
  movaps 0x10+A_OFFSET_41(A), A12
  movaps 0x20+A_OFFSET_41(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_41(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_41(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_41(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_41(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_41(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_41(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_41(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_41(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_41(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_41(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_41(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_41(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_41(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,2) to already existing.
  addps 0x0+C_OFFSET_42(C), C1
  addps 0x10+C_OFFSET_42(C), C2
  addps 0x20+C_OFFSET_42(C), C3
  addps 0x30+C_OFFSET_42(C), C4

  # Write out C(4,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_42(C)
  movaps C2, 0x10+C_OFFSET_42(C)
  movaps C3, 0x20+C_OFFSET_42(C)
  movaps C4, 0x30+C_OFFSET_42(C)

  .align 16
block_40:

  # Check norm of product A(4,2)*B(2,2).
  movss 0x7c(multiply_stream, base_pointer), B1
  mulss 0x13c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_41

  # Reset C(4,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,2) = A(4,2)*B(2,2).
  movaps 0x0+B_OFFSET_22(B), B1
  movaps 0x10+B_OFFSET_22(B), B2
  movaps 0x20+B_OFFSET_22(B), B3
  movaps 0x30+B_OFFSET_22(B), B4
  movaps 0x0+A_OFFSET_42(A), A11
  movaps 0x10+A_OFFSET_42(A), A12
  movaps 0x20+A_OFFSET_42(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_42(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_42(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_42(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_42(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_42(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_42(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_42(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_42(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_42(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_42(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_42(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_42(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_42(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,2) to already existing.
  addps 0x0+C_OFFSET_42(C), C1
  addps 0x10+C_OFFSET_42(C), C2
  addps 0x20+C_OFFSET_42(C), C3
  addps 0x30+C_OFFSET_42(C), C4

  # Write out C(4,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_42(C)
  movaps C2, 0x10+C_OFFSET_42(C)
  movaps C3, 0x20+C_OFFSET_42(C)
  movaps C4, 0x30+C_OFFSET_42(C)

  .align 16
block_41:

  # Check norm of product A(3,3)*B(3,1).
  movss 0x60(multiply_stream, base_pointer), B1
  mulss 0x158(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_42

  # Reset C(3,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,1) = A(3,3)*B(3,1).
  movaps 0x0+B_OFFSET_31(B), B1
  movaps 0x10+B_OFFSET_31(B), B2
  movaps 0x20+B_OFFSET_31(B), B3
  movaps 0x30+B_OFFSET_31(B), B4
  movaps 0x0+A_OFFSET_33(A), A11
  movaps 0x10+A_OFFSET_33(A), A12
  movaps 0x20+A_OFFSET_33(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_33(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_33(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_33(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_33(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_33(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_33(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_33(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_33(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_33(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_33(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_33(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_33(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_33(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,1) to already existing.
  addps 0x0+C_OFFSET_31(C), C1
  addps 0x10+C_OFFSET_31(C), C2
  addps 0x20+C_OFFSET_31(C), C3
  addps 0x30+C_OFFSET_31(C), C4

  # Write out C(3,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_31(C)
  movaps C2, 0x10+C_OFFSET_31(C)
  movaps C3, 0x20+C_OFFSET_31(C)
  movaps C4, 0x30+C_OFFSET_31(C)

  .align 16
block_42:

  # Check norm of product A(3,4)*B(4,1).
  movss 0x64(multiply_stream, base_pointer), B1
  mulss 0x178(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_43

  # Reset C(3,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,1) = A(3,4)*B(4,1).
  movaps 0x0+B_OFFSET_41(B), B1
  movaps 0x10+B_OFFSET_41(B), B2
  movaps 0x20+B_OFFSET_41(B), B3
  movaps 0x30+B_OFFSET_41(B), B4
  movaps 0x0+A_OFFSET_34(A), A11
  movaps 0x10+A_OFFSET_34(A), A12
  movaps 0x20+A_OFFSET_34(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_34(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_34(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_34(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_34(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_34(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_34(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_34(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_34(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_34(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_34(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_34(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_34(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_34(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,1) to already existing.
  addps 0x0+C_OFFSET_31(C), C1
  addps 0x10+C_OFFSET_31(C), C2
  addps 0x20+C_OFFSET_31(C), C3
  addps 0x30+C_OFFSET_31(C), C4

  # Write out C(3,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_31(C)
  movaps C2, 0x10+C_OFFSET_31(C)
  movaps C3, 0x20+C_OFFSET_31(C)
  movaps C4, 0x30+C_OFFSET_31(C)

  .align 16
block_43:

  # Check norm of product A(3,3)*B(3,2).
  movss 0x60(multiply_stream, base_pointer), B1
  mulss 0x15c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_44

  # Reset C(3,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,2) = A(3,3)*B(3,2).
  movaps 0x0+B_OFFSET_32(B), B1
  movaps 0x10+B_OFFSET_32(B), B2
  movaps 0x20+B_OFFSET_32(B), B3
  movaps 0x30+B_OFFSET_32(B), B4
  movaps 0x0+A_OFFSET_33(A), A11
  movaps 0x10+A_OFFSET_33(A), A12
  movaps 0x20+A_OFFSET_33(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_33(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_33(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_33(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_33(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_33(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_33(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_33(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_33(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_33(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_33(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_33(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_33(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_33(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,2) to already existing.
  addps 0x0+C_OFFSET_32(C), C1
  addps 0x10+C_OFFSET_32(C), C2
  addps 0x20+C_OFFSET_32(C), C3
  addps 0x30+C_OFFSET_32(C), C4

  # Write out C(3,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_32(C)
  movaps C2, 0x10+C_OFFSET_32(C)
  movaps C3, 0x20+C_OFFSET_32(C)
  movaps C4, 0x30+C_OFFSET_32(C)

  .align 16
block_44:

  # Check norm of product A(3,4)*B(4,2).
  movss 0x64(multiply_stream, base_pointer), B1
  mulss 0x17c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_45

  # Reset C(3,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,2) = A(3,4)*B(4,2).
  movaps 0x0+B_OFFSET_42(B), B1
  movaps 0x10+B_OFFSET_42(B), B2
  movaps 0x20+B_OFFSET_42(B), B3
  movaps 0x30+B_OFFSET_42(B), B4
  movaps 0x0+A_OFFSET_34(A), A11
  movaps 0x10+A_OFFSET_34(A), A12
  movaps 0x20+A_OFFSET_34(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_34(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_34(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_34(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_34(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_34(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_34(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_34(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_34(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_34(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_34(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_34(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_34(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_34(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,2) to already existing.
  addps 0x0+C_OFFSET_32(C), C1
  addps 0x10+C_OFFSET_32(C), C2
  addps 0x20+C_OFFSET_32(C), C3
  addps 0x30+C_OFFSET_32(C), C4

  # Write out C(3,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_32(C)
  movaps C2, 0x10+C_OFFSET_32(C)
  movaps C3, 0x20+C_OFFSET_32(C)
  movaps C4, 0x30+C_OFFSET_32(C)

  .align 16
block_45:

  # Check norm of product A(4,3)*B(3,1).
  movss 0x80(multiply_stream, base_pointer), B1
  mulss 0x158(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_46

  # Reset C(4,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,1) = A(4,3)*B(3,1).
  movaps 0x0+B_OFFSET_31(B), B1
  movaps 0x10+B_OFFSET_31(B), B2
  movaps 0x20+B_OFFSET_31(B), B3
  movaps 0x30+B_OFFSET_31(B), B4
  movaps 0x0+A_OFFSET_43(A), A11
  movaps 0x10+A_OFFSET_43(A), A12
  movaps 0x20+A_OFFSET_43(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_43(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_43(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_43(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_43(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_43(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_43(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_43(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_43(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_43(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_43(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_43(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_43(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_43(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,1) to already existing.
  addps 0x0+C_OFFSET_41(C), C1
  addps 0x10+C_OFFSET_41(C), C2
  addps 0x20+C_OFFSET_41(C), C3
  addps 0x30+C_OFFSET_41(C), C4

  # Write out C(4,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_41(C)
  movaps C2, 0x10+C_OFFSET_41(C)
  movaps C3, 0x20+C_OFFSET_41(C)
  movaps C4, 0x30+C_OFFSET_41(C)

  .align 16
block_46:

  # Check norm of product A(4,4)*B(4,1).
  movss 0x84(multiply_stream, base_pointer), B1
  mulss 0x178(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_47

  # Reset C(4,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,1) = A(4,4)*B(4,1).
  movaps 0x0+B_OFFSET_41(B), B1
  movaps 0x10+B_OFFSET_41(B), B2
  movaps 0x20+B_OFFSET_41(B), B3
  movaps 0x30+B_OFFSET_41(B), B4
  movaps 0x0+A_OFFSET_44(A), A11
  movaps 0x10+A_OFFSET_44(A), A12
  movaps 0x20+A_OFFSET_44(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_44(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_44(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_44(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_44(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_44(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_44(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_44(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_44(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_44(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_44(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_44(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_44(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_44(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,1) to already existing.
  addps 0x0+C_OFFSET_41(C), C1
  addps 0x10+C_OFFSET_41(C), C2
  addps 0x20+C_OFFSET_41(C), C3
  addps 0x30+C_OFFSET_41(C), C4

  # Write out C(4,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_41(C)
  movaps C2, 0x10+C_OFFSET_41(C)
  movaps C3, 0x20+C_OFFSET_41(C)
  movaps C4, 0x30+C_OFFSET_41(C)

  .align 16
block_47:

  # Check norm of product A(4,3)*B(3,2).
  movss 0x80(multiply_stream, base_pointer), B1
  mulss 0x15c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_48

  # Reset C(4,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,2) = A(4,3)*B(3,2).
  movaps 0x0+B_OFFSET_32(B), B1
  movaps 0x10+B_OFFSET_32(B), B2
  movaps 0x20+B_OFFSET_32(B), B3
  movaps 0x30+B_OFFSET_32(B), B4
  movaps 0x0+A_OFFSET_43(A), A11
  movaps 0x10+A_OFFSET_43(A), A12
  movaps 0x20+A_OFFSET_43(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_43(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_43(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_43(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_43(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_43(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_43(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_43(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_43(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_43(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_43(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_43(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_43(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_43(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,2) to already existing.
  addps 0x0+C_OFFSET_42(C), C1
  addps 0x10+C_OFFSET_42(C), C2
  addps 0x20+C_OFFSET_42(C), C3
  addps 0x30+C_OFFSET_42(C), C4

  # Write out C(4,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_42(C)
  movaps C2, 0x10+C_OFFSET_42(C)
  movaps C3, 0x20+C_OFFSET_42(C)
  movaps C4, 0x30+C_OFFSET_42(C)

  .align 16
block_48:

  # Check norm of product A(4,4)*B(4,2).
  movss 0x84(multiply_stream, base_pointer), B1
  mulss 0x17c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_49

  # Reset C(4,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,2) = A(4,4)*B(4,2).
  movaps 0x0+B_OFFSET_42(B), B1
  movaps 0x10+B_OFFSET_42(B), B2
  movaps 0x20+B_OFFSET_42(B), B3
  movaps 0x30+B_OFFSET_42(B), B4
  movaps 0x0+A_OFFSET_44(A), A11
  movaps 0x10+A_OFFSET_44(A), A12
  movaps 0x20+A_OFFSET_44(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_44(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_44(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_44(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_44(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_44(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_44(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_44(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_44(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_44(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_44(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_44(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_44(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_44(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,2) to already existing.
  addps 0x0+C_OFFSET_42(C), C1
  addps 0x10+C_OFFSET_42(C), C2
  addps 0x20+C_OFFSET_42(C), C3
  addps 0x30+C_OFFSET_42(C), C4

  # Write out C(4,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_42(C)
  movaps C2, 0x10+C_OFFSET_42(C)
  movaps C3, 0x20+C_OFFSET_42(C)
  movaps C4, 0x30+C_OFFSET_42(C)

  .align 16
block_49:

  # Check norm of product A(3,1)*B(1,3).
  movss 0x58(multiply_stream, base_pointer), B1
  mulss 0x120(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_50

  # Reset C(3,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,3) = A(3,1)*B(1,3).
  movaps 0x0+B_OFFSET_13(B), B1
  movaps 0x10+B_OFFSET_13(B), B2
  movaps 0x20+B_OFFSET_13(B), B3
  movaps 0x30+B_OFFSET_13(B), B4
  movaps 0x0+A_OFFSET_31(A), A11
  movaps 0x10+A_OFFSET_31(A), A12
  movaps 0x20+A_OFFSET_31(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_31(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_31(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_31(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_31(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_31(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_31(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_31(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_31(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_31(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_31(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_31(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_31(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_31(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,3) to already existing.
  addps 0x0+C_OFFSET_33(C), C1
  addps 0x10+C_OFFSET_33(C), C2
  addps 0x20+C_OFFSET_33(C), C3
  addps 0x30+C_OFFSET_33(C), C4

  # Write out C(3,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_33(C)
  movaps C2, 0x10+C_OFFSET_33(C)
  movaps C3, 0x20+C_OFFSET_33(C)
  movaps C4, 0x30+C_OFFSET_33(C)

  .align 16
block_50:

  # Check norm of product A(3,2)*B(2,3).
  movss 0x5c(multiply_stream, base_pointer), B1
  mulss 0x140(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_51

  # Reset C(3,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,3) = A(3,2)*B(2,3).
  movaps 0x0+B_OFFSET_23(B), B1
  movaps 0x10+B_OFFSET_23(B), B2
  movaps 0x20+B_OFFSET_23(B), B3
  movaps 0x30+B_OFFSET_23(B), B4
  movaps 0x0+A_OFFSET_32(A), A11
  movaps 0x10+A_OFFSET_32(A), A12
  movaps 0x20+A_OFFSET_32(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_32(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_32(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_32(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_32(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_32(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_32(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_32(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_32(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_32(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_32(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_32(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_32(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_32(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,3) to already existing.
  addps 0x0+C_OFFSET_33(C), C1
  addps 0x10+C_OFFSET_33(C), C2
  addps 0x20+C_OFFSET_33(C), C3
  addps 0x30+C_OFFSET_33(C), C4

  # Write out C(3,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_33(C)
  movaps C2, 0x10+C_OFFSET_33(C)
  movaps C3, 0x20+C_OFFSET_33(C)
  movaps C4, 0x30+C_OFFSET_33(C)

  .align 16
block_51:

  # Check norm of product A(3,1)*B(1,4).
  movss 0x58(multiply_stream, base_pointer), B1
  mulss 0x124(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_52

  # Reset C(3,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,4) = A(3,1)*B(1,4).
  movaps 0x0+B_OFFSET_14(B), B1
  movaps 0x10+B_OFFSET_14(B), B2
  movaps 0x20+B_OFFSET_14(B), B3
  movaps 0x30+B_OFFSET_14(B), B4
  movaps 0x0+A_OFFSET_31(A), A11
  movaps 0x10+A_OFFSET_31(A), A12
  movaps 0x20+A_OFFSET_31(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_31(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_31(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_31(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_31(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_31(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_31(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_31(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_31(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_31(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_31(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_31(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_31(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_31(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,4) to already existing.
  addps 0x0+C_OFFSET_34(C), C1
  addps 0x10+C_OFFSET_34(C), C2
  addps 0x20+C_OFFSET_34(C), C3
  addps 0x30+C_OFFSET_34(C), C4

  # Write out C(3,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_34(C)
  movaps C2, 0x10+C_OFFSET_34(C)
  movaps C3, 0x20+C_OFFSET_34(C)
  movaps C4, 0x30+C_OFFSET_34(C)

  .align 16
block_52:

  # Check norm of product A(3,2)*B(2,4).
  movss 0x5c(multiply_stream, base_pointer), B1
  mulss 0x144(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_53

  # Reset C(3,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,4) = A(3,2)*B(2,4).
  movaps 0x0+B_OFFSET_24(B), B1
  movaps 0x10+B_OFFSET_24(B), B2
  movaps 0x20+B_OFFSET_24(B), B3
  movaps 0x30+B_OFFSET_24(B), B4
  movaps 0x0+A_OFFSET_32(A), A11
  movaps 0x10+A_OFFSET_32(A), A12
  movaps 0x20+A_OFFSET_32(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_32(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_32(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_32(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_32(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_32(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_32(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_32(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_32(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_32(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_32(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_32(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_32(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_32(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,4) to already existing.
  addps 0x0+C_OFFSET_34(C), C1
  addps 0x10+C_OFFSET_34(C), C2
  addps 0x20+C_OFFSET_34(C), C3
  addps 0x30+C_OFFSET_34(C), C4

  # Write out C(3,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_34(C)
  movaps C2, 0x10+C_OFFSET_34(C)
  movaps C3, 0x20+C_OFFSET_34(C)
  movaps C4, 0x30+C_OFFSET_34(C)

  .align 16
block_53:

  # Check norm of product A(4,1)*B(1,3).
  movss 0x78(multiply_stream, base_pointer), B1
  mulss 0x120(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_54

  # Reset C(4,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,3) = A(4,1)*B(1,3).
  movaps 0x0+B_OFFSET_13(B), B1
  movaps 0x10+B_OFFSET_13(B), B2
  movaps 0x20+B_OFFSET_13(B), B3
  movaps 0x30+B_OFFSET_13(B), B4
  movaps 0x0+A_OFFSET_41(A), A11
  movaps 0x10+A_OFFSET_41(A), A12
  movaps 0x20+A_OFFSET_41(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_41(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_41(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_41(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_41(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_41(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_41(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_41(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_41(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_41(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_41(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_41(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_41(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_41(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,3) to already existing.
  addps 0x0+C_OFFSET_43(C), C1
  addps 0x10+C_OFFSET_43(C), C2
  addps 0x20+C_OFFSET_43(C), C3
  addps 0x30+C_OFFSET_43(C), C4

  # Write out C(4,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_43(C)
  movaps C2, 0x10+C_OFFSET_43(C)
  movaps C3, 0x20+C_OFFSET_43(C)
  movaps C4, 0x30+C_OFFSET_43(C)

  .align 16
block_54:

  # Check norm of product A(4,2)*B(2,3).
  movss 0x7c(multiply_stream, base_pointer), B1
  mulss 0x140(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_55

  # Reset C(4,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,3) = A(4,2)*B(2,3).
  movaps 0x0+B_OFFSET_23(B), B1
  movaps 0x10+B_OFFSET_23(B), B2
  movaps 0x20+B_OFFSET_23(B), B3
  movaps 0x30+B_OFFSET_23(B), B4
  movaps 0x0+A_OFFSET_42(A), A11
  movaps 0x10+A_OFFSET_42(A), A12
  movaps 0x20+A_OFFSET_42(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_42(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_42(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_42(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_42(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_42(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_42(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_42(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_42(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_42(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_42(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_42(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_42(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_42(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,3) to already existing.
  addps 0x0+C_OFFSET_43(C), C1
  addps 0x10+C_OFFSET_43(C), C2
  addps 0x20+C_OFFSET_43(C), C3
  addps 0x30+C_OFFSET_43(C), C4

  # Write out C(4,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_43(C)
  movaps C2, 0x10+C_OFFSET_43(C)
  movaps C3, 0x20+C_OFFSET_43(C)
  movaps C4, 0x30+C_OFFSET_43(C)

  .align 16
block_55:

  # Check norm of product A(4,1)*B(1,4).
  movss 0x78(multiply_stream, base_pointer), B1
  mulss 0x124(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_56

  # Reset C(4,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,4) = A(4,1)*B(1,4).
  movaps 0x0+B_OFFSET_14(B), B1
  movaps 0x10+B_OFFSET_14(B), B2
  movaps 0x20+B_OFFSET_14(B), B3
  movaps 0x30+B_OFFSET_14(B), B4
  movaps 0x0+A_OFFSET_41(A), A11
  movaps 0x10+A_OFFSET_41(A), A12
  movaps 0x20+A_OFFSET_41(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_41(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_41(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_41(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_41(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_41(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_41(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_41(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_41(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_41(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_41(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_41(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_41(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_41(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,4) to already existing.
  addps 0x0+C_OFFSET_44(C), C1
  addps 0x10+C_OFFSET_44(C), C2
  addps 0x20+C_OFFSET_44(C), C3
  addps 0x30+C_OFFSET_44(C), C4

  # Write out C(4,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_44(C)
  movaps C2, 0x10+C_OFFSET_44(C)
  movaps C3, 0x20+C_OFFSET_44(C)
  movaps C4, 0x30+C_OFFSET_44(C)

  .align 16
block_56:

  # Check norm of product A(4,2)*B(2,4).
  movss 0x7c(multiply_stream, base_pointer), B1
  mulss 0x144(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_57

  # Reset C(4,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,4) = A(4,2)*B(2,4).
  movaps 0x0+B_OFFSET_24(B), B1
  movaps 0x10+B_OFFSET_24(B), B2
  movaps 0x20+B_OFFSET_24(B), B3
  movaps 0x30+B_OFFSET_24(B), B4
  movaps 0x0+A_OFFSET_42(A), A11
  movaps 0x10+A_OFFSET_42(A), A12
  movaps 0x20+A_OFFSET_42(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_42(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_42(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_42(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_42(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_42(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_42(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_42(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_42(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_42(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_42(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_42(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_42(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_42(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,4) to already existing.
  addps 0x0+C_OFFSET_44(C), C1
  addps 0x10+C_OFFSET_44(C), C2
  addps 0x20+C_OFFSET_44(C), C3
  addps 0x30+C_OFFSET_44(C), C4

  # Write out C(4,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_44(C)
  movaps C2, 0x10+C_OFFSET_44(C)
  movaps C3, 0x20+C_OFFSET_44(C)
  movaps C4, 0x30+C_OFFSET_44(C)

  .align 16
block_57:

  # Check norm of product A(3,3)*B(3,3).
  movss 0x60(multiply_stream, base_pointer), B1
  mulss 0x160(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_58

  # Reset C(3,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,3) = A(3,3)*B(3,3).
  movaps 0x0+B_OFFSET_33(B), B1
  movaps 0x10+B_OFFSET_33(B), B2
  movaps 0x20+B_OFFSET_33(B), B3
  movaps 0x30+B_OFFSET_33(B), B4
  movaps 0x0+A_OFFSET_33(A), A11
  movaps 0x10+A_OFFSET_33(A), A12
  movaps 0x20+A_OFFSET_33(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_33(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_33(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_33(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_33(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_33(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_33(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_33(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_33(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_33(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_33(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_33(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_33(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_33(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,3) to already existing.
  addps 0x0+C_OFFSET_33(C), C1
  addps 0x10+C_OFFSET_33(C), C2
  addps 0x20+C_OFFSET_33(C), C3
  addps 0x30+C_OFFSET_33(C), C4

  # Write out C(3,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_33(C)
  movaps C2, 0x10+C_OFFSET_33(C)
  movaps C3, 0x20+C_OFFSET_33(C)
  movaps C4, 0x30+C_OFFSET_33(C)

  .align 16
block_58:

  # Check norm of product A(3,4)*B(4,3).
  movss 0x64(multiply_stream, base_pointer), B1
  mulss 0x180(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_59

  # Reset C(3,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,3) = A(3,4)*B(4,3).
  movaps 0x0+B_OFFSET_43(B), B1
  movaps 0x10+B_OFFSET_43(B), B2
  movaps 0x20+B_OFFSET_43(B), B3
  movaps 0x30+B_OFFSET_43(B), B4
  movaps 0x0+A_OFFSET_34(A), A11
  movaps 0x10+A_OFFSET_34(A), A12
  movaps 0x20+A_OFFSET_34(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_34(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_34(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_34(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_34(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_34(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_34(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_34(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_34(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_34(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_34(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_34(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_34(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_34(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,3) to already existing.
  addps 0x0+C_OFFSET_33(C), C1
  addps 0x10+C_OFFSET_33(C), C2
  addps 0x20+C_OFFSET_33(C), C3
  addps 0x30+C_OFFSET_33(C), C4

  # Write out C(3,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_33(C)
  movaps C2, 0x10+C_OFFSET_33(C)
  movaps C3, 0x20+C_OFFSET_33(C)
  movaps C4, 0x30+C_OFFSET_33(C)

  .align 16
block_59:

  # Check norm of product A(3,3)*B(3,4).
  movss 0x60(multiply_stream, base_pointer), B1
  mulss 0x164(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_60

  # Reset C(3,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,4) = A(3,3)*B(3,4).
  movaps 0x0+B_OFFSET_34(B), B1
  movaps 0x10+B_OFFSET_34(B), B2
  movaps 0x20+B_OFFSET_34(B), B3
  movaps 0x30+B_OFFSET_34(B), B4
  movaps 0x0+A_OFFSET_33(A), A11
  movaps 0x10+A_OFFSET_33(A), A12
  movaps 0x20+A_OFFSET_33(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_33(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_33(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_33(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_33(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_33(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_33(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_33(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_33(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_33(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_33(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_33(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_33(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_33(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,4) to already existing.
  addps 0x0+C_OFFSET_34(C), C1
  addps 0x10+C_OFFSET_34(C), C2
  addps 0x20+C_OFFSET_34(C), C3
  addps 0x30+C_OFFSET_34(C), C4

  # Write out C(3,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_34(C)
  movaps C2, 0x10+C_OFFSET_34(C)
  movaps C3, 0x20+C_OFFSET_34(C)
  movaps C4, 0x30+C_OFFSET_34(C)

  .align 16
block_60:

  # Check norm of product A(3,4)*B(4,4).
  movss 0x64(multiply_stream, base_pointer), B1
  mulss 0x184(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_61

  # Reset C(3,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,4) = A(3,4)*B(4,4).
  movaps 0x0+B_OFFSET_44(B), B1
  movaps 0x10+B_OFFSET_44(B), B2
  movaps 0x20+B_OFFSET_44(B), B3
  movaps 0x30+B_OFFSET_44(B), B4
  movaps 0x0+A_OFFSET_34(A), A11
  movaps 0x10+A_OFFSET_34(A), A12
  movaps 0x20+A_OFFSET_34(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_34(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_34(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_34(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_34(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_34(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_34(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_34(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_34(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_34(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_34(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_34(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_34(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_34(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,4) to already existing.
  addps 0x0+C_OFFSET_34(C), C1
  addps 0x10+C_OFFSET_34(C), C2
  addps 0x20+C_OFFSET_34(C), C3
  addps 0x30+C_OFFSET_34(C), C4

  # Write out C(3,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_34(C)
  movaps C2, 0x10+C_OFFSET_34(C)
  movaps C3, 0x20+C_OFFSET_34(C)
  movaps C4, 0x30+C_OFFSET_34(C)

  .align 16
block_61:

  # Check norm of product A(4,3)*B(3,3).
  movss 0x80(multiply_stream, base_pointer), B1
  mulss 0x160(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_62

  # Reset C(4,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,3) = A(4,3)*B(3,3).
  movaps 0x0+B_OFFSET_33(B), B1
  movaps 0x10+B_OFFSET_33(B), B2
  movaps 0x20+B_OFFSET_33(B), B3
  movaps 0x30+B_OFFSET_33(B), B4
  movaps 0x0+A_OFFSET_43(A), A11
  movaps 0x10+A_OFFSET_43(A), A12
  movaps 0x20+A_OFFSET_43(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_43(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_43(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_43(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_43(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_43(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_43(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_43(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_43(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_43(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_43(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_43(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_43(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_43(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,3) to already existing.
  addps 0x0+C_OFFSET_43(C), C1
  addps 0x10+C_OFFSET_43(C), C2
  addps 0x20+C_OFFSET_43(C), C3
  addps 0x30+C_OFFSET_43(C), C4

  # Write out C(4,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_43(C)
  movaps C2, 0x10+C_OFFSET_43(C)
  movaps C3, 0x20+C_OFFSET_43(C)
  movaps C4, 0x30+C_OFFSET_43(C)

  .align 16
block_62:

  # Check norm of product A(4,4)*B(4,3).
  movss 0x84(multiply_stream, base_pointer), B1
  mulss 0x180(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_63

  # Reset C(4,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,3) = A(4,4)*B(4,3).
  movaps 0x0+B_OFFSET_43(B), B1
  movaps 0x10+B_OFFSET_43(B), B2
  movaps 0x20+B_OFFSET_43(B), B3
  movaps 0x30+B_OFFSET_43(B), B4
  movaps 0x0+A_OFFSET_44(A), A11
  movaps 0x10+A_OFFSET_44(A), A12
  movaps 0x20+A_OFFSET_44(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_44(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_44(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_44(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_44(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_44(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_44(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_44(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_44(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_44(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_44(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_44(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_44(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_44(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,3) to already existing.
  addps 0x0+C_OFFSET_43(C), C1
  addps 0x10+C_OFFSET_43(C), C2
  addps 0x20+C_OFFSET_43(C), C3
  addps 0x30+C_OFFSET_43(C), C4

  # Write out C(4,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_43(C)
  movaps C2, 0x10+C_OFFSET_43(C)
  movaps C3, 0x20+C_OFFSET_43(C)
  movaps C4, 0x30+C_OFFSET_43(C)

  .align 16
block_63:

  # Check norm of product A(4,3)*B(3,4).
  movss 0x80(multiply_stream, base_pointer), B1
  mulss 0x164(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_64

  # Reset C(4,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,4) = A(4,3)*B(3,4).
  movaps 0x0+B_OFFSET_34(B), B1
  movaps 0x10+B_OFFSET_34(B), B2
  movaps 0x20+B_OFFSET_34(B), B3
  movaps 0x30+B_OFFSET_34(B), B4
  movaps 0x0+A_OFFSET_43(A), A11
  movaps 0x10+A_OFFSET_43(A), A12
  movaps 0x20+A_OFFSET_43(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_43(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_43(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_43(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_43(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_43(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_43(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_43(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_43(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_43(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_43(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_43(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_43(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_43(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,4) to already existing.
  addps 0x0+C_OFFSET_44(C), C1
  addps 0x10+C_OFFSET_44(C), C2
  addps 0x20+C_OFFSET_44(C), C3
  addps 0x30+C_OFFSET_44(C), C4

  # Write out C(4,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_44(C)
  movaps C2, 0x10+C_OFFSET_44(C)
  movaps C3, 0x20+C_OFFSET_44(C)
  movaps C4, 0x30+C_OFFSET_44(C)

  .align 16
block_64:

  # Check norm of product A(4,4)*B(4,4).
  movss 0x84(multiply_stream, base_pointer), B1
  mulss 0x184(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_65

  # Reset C(4,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,4) = A(4,4)*B(4,4).
  movaps 0x0+B_OFFSET_44(B), B1
  movaps 0x10+B_OFFSET_44(B), B2
  movaps 0x20+B_OFFSET_44(B), B3
  movaps 0x30+B_OFFSET_44(B), B4
  movaps 0x0+A_OFFSET_44(A), A11
  movaps 0x10+A_OFFSET_44(A), A12
  movaps 0x20+A_OFFSET_44(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_44(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_44(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_44(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_44(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_44(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_44(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_44(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_44(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_44(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_44(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_44(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_44(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_44(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,4) to already existing.
  addps 0x0+C_OFFSET_44(C), C1
  addps 0x10+C_OFFSET_44(C), C2
  addps 0x20+C_OFFSET_44(C), C3
  addps 0x30+C_OFFSET_44(C), C4

  # Write out C(4,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_44(C)
  movaps C2, 0x10+C_OFFSET_44(C)
  movaps C3, 0x20+C_OFFSET_44(C)
  movaps C4, 0x30+C_OFFSET_44(C)

  .align 16
block_65:

  # Check norm of product A(1,5)*B(5,1).
  movss 0x28(multiply_stream, base_pointer), B1
  mulss 0x198(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_66

  # Reset C(1,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,1) = A(1,5)*B(5,1).
  movaps 0x0+B_OFFSET_51(B), B1
  movaps 0x10+B_OFFSET_51(B), B2
  movaps 0x20+B_OFFSET_51(B), B3
  movaps 0x30+B_OFFSET_51(B), B4
  movaps 0x0+A_OFFSET_15(A), A11
  movaps 0x10+A_OFFSET_15(A), A12
  movaps 0x20+A_OFFSET_15(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_15(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_15(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_15(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_15(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_15(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_15(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_15(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_15(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_15(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_15(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_15(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_15(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_15(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,1) to already existing.
  addps 0x0+C_OFFSET_11(C), C1
  addps 0x10+C_OFFSET_11(C), C2
  addps 0x20+C_OFFSET_11(C), C3
  addps 0x30+C_OFFSET_11(C), C4

  # Write out C(1,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_11(C)
  movaps C2, 0x10+C_OFFSET_11(C)
  movaps C3, 0x20+C_OFFSET_11(C)
  movaps C4, 0x30+C_OFFSET_11(C)

  .align 16
block_66:

  # Check norm of product A(1,6)*B(6,1).
  movss 0x2c(multiply_stream, base_pointer), B1
  mulss 0x1b8(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_67

  # Reset C(1,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,1) = A(1,6)*B(6,1).
  movaps 0x0+B_OFFSET_61(B), B1
  movaps 0x10+B_OFFSET_61(B), B2
  movaps 0x20+B_OFFSET_61(B), B3
  movaps 0x30+B_OFFSET_61(B), B4
  movaps 0x0+A_OFFSET_16(A), A11
  movaps 0x10+A_OFFSET_16(A), A12
  movaps 0x20+A_OFFSET_16(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_16(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_16(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_16(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_16(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_16(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_16(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_16(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_16(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_16(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_16(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_16(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_16(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_16(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,1) to already existing.
  addps 0x0+C_OFFSET_11(C), C1
  addps 0x10+C_OFFSET_11(C), C2
  addps 0x20+C_OFFSET_11(C), C3
  addps 0x30+C_OFFSET_11(C), C4

  # Write out C(1,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_11(C)
  movaps C2, 0x10+C_OFFSET_11(C)
  movaps C3, 0x20+C_OFFSET_11(C)
  movaps C4, 0x30+C_OFFSET_11(C)

  .align 16
block_67:

  # Check norm of product A(1,5)*B(5,2).
  movss 0x28(multiply_stream, base_pointer), B1
  mulss 0x19c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_68

  # Reset C(1,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,2) = A(1,5)*B(5,2).
  movaps 0x0+B_OFFSET_52(B), B1
  movaps 0x10+B_OFFSET_52(B), B2
  movaps 0x20+B_OFFSET_52(B), B3
  movaps 0x30+B_OFFSET_52(B), B4
  movaps 0x0+A_OFFSET_15(A), A11
  movaps 0x10+A_OFFSET_15(A), A12
  movaps 0x20+A_OFFSET_15(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_15(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_15(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_15(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_15(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_15(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_15(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_15(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_15(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_15(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_15(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_15(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_15(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_15(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,2) to already existing.
  addps 0x0+C_OFFSET_12(C), C1
  addps 0x10+C_OFFSET_12(C), C2
  addps 0x20+C_OFFSET_12(C), C3
  addps 0x30+C_OFFSET_12(C), C4

  # Write out C(1,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_12(C)
  movaps C2, 0x10+C_OFFSET_12(C)
  movaps C3, 0x20+C_OFFSET_12(C)
  movaps C4, 0x30+C_OFFSET_12(C)

  .align 16
block_68:

  # Check norm of product A(1,6)*B(6,2).
  movss 0x2c(multiply_stream, base_pointer), B1
  mulss 0x1bc(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_69

  # Reset C(1,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,2) = A(1,6)*B(6,2).
  movaps 0x0+B_OFFSET_62(B), B1
  movaps 0x10+B_OFFSET_62(B), B2
  movaps 0x20+B_OFFSET_62(B), B3
  movaps 0x30+B_OFFSET_62(B), B4
  movaps 0x0+A_OFFSET_16(A), A11
  movaps 0x10+A_OFFSET_16(A), A12
  movaps 0x20+A_OFFSET_16(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_16(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_16(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_16(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_16(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_16(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_16(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_16(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_16(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_16(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_16(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_16(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_16(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_16(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,2) to already existing.
  addps 0x0+C_OFFSET_12(C), C1
  addps 0x10+C_OFFSET_12(C), C2
  addps 0x20+C_OFFSET_12(C), C3
  addps 0x30+C_OFFSET_12(C), C4

  # Write out C(1,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_12(C)
  movaps C2, 0x10+C_OFFSET_12(C)
  movaps C3, 0x20+C_OFFSET_12(C)
  movaps C4, 0x30+C_OFFSET_12(C)

  .align 16
block_69:

  # Check norm of product A(2,5)*B(5,1).
  movss 0x48(multiply_stream, base_pointer), B1
  mulss 0x198(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_70

  # Reset C(2,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,1) = A(2,5)*B(5,1).
  movaps 0x0+B_OFFSET_51(B), B1
  movaps 0x10+B_OFFSET_51(B), B2
  movaps 0x20+B_OFFSET_51(B), B3
  movaps 0x30+B_OFFSET_51(B), B4
  movaps 0x0+A_OFFSET_25(A), A11
  movaps 0x10+A_OFFSET_25(A), A12
  movaps 0x20+A_OFFSET_25(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_25(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_25(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_25(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_25(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_25(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_25(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_25(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_25(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_25(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_25(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_25(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_25(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_25(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,1) to already existing.
  addps 0x0+C_OFFSET_21(C), C1
  addps 0x10+C_OFFSET_21(C), C2
  addps 0x20+C_OFFSET_21(C), C3
  addps 0x30+C_OFFSET_21(C), C4

  # Write out C(2,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_21(C)
  movaps C2, 0x10+C_OFFSET_21(C)
  movaps C3, 0x20+C_OFFSET_21(C)
  movaps C4, 0x30+C_OFFSET_21(C)

  .align 16
block_70:

  # Check norm of product A(2,6)*B(6,1).
  movss 0x4c(multiply_stream, base_pointer), B1
  mulss 0x1b8(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_71

  # Reset C(2,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,1) = A(2,6)*B(6,1).
  movaps 0x0+B_OFFSET_61(B), B1
  movaps 0x10+B_OFFSET_61(B), B2
  movaps 0x20+B_OFFSET_61(B), B3
  movaps 0x30+B_OFFSET_61(B), B4
  movaps 0x0+A_OFFSET_26(A), A11
  movaps 0x10+A_OFFSET_26(A), A12
  movaps 0x20+A_OFFSET_26(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_26(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_26(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_26(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_26(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_26(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_26(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_26(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_26(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_26(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_26(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_26(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_26(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_26(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,1) to already existing.
  addps 0x0+C_OFFSET_21(C), C1
  addps 0x10+C_OFFSET_21(C), C2
  addps 0x20+C_OFFSET_21(C), C3
  addps 0x30+C_OFFSET_21(C), C4

  # Write out C(2,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_21(C)
  movaps C2, 0x10+C_OFFSET_21(C)
  movaps C3, 0x20+C_OFFSET_21(C)
  movaps C4, 0x30+C_OFFSET_21(C)

  .align 16
block_71:

  # Check norm of product A(2,5)*B(5,2).
  movss 0x48(multiply_stream, base_pointer), B1
  mulss 0x19c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_72

  # Reset C(2,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,2) = A(2,5)*B(5,2).
  movaps 0x0+B_OFFSET_52(B), B1
  movaps 0x10+B_OFFSET_52(B), B2
  movaps 0x20+B_OFFSET_52(B), B3
  movaps 0x30+B_OFFSET_52(B), B4
  movaps 0x0+A_OFFSET_25(A), A11
  movaps 0x10+A_OFFSET_25(A), A12
  movaps 0x20+A_OFFSET_25(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_25(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_25(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_25(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_25(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_25(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_25(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_25(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_25(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_25(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_25(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_25(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_25(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_25(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,2) to already existing.
  addps 0x0+C_OFFSET_22(C), C1
  addps 0x10+C_OFFSET_22(C), C2
  addps 0x20+C_OFFSET_22(C), C3
  addps 0x30+C_OFFSET_22(C), C4

  # Write out C(2,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_22(C)
  movaps C2, 0x10+C_OFFSET_22(C)
  movaps C3, 0x20+C_OFFSET_22(C)
  movaps C4, 0x30+C_OFFSET_22(C)

  .align 16
block_72:

  # Check norm of product A(2,6)*B(6,2).
  movss 0x4c(multiply_stream, base_pointer), B1
  mulss 0x1bc(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_73

  # Reset C(2,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,2) = A(2,6)*B(6,2).
  movaps 0x0+B_OFFSET_62(B), B1
  movaps 0x10+B_OFFSET_62(B), B2
  movaps 0x20+B_OFFSET_62(B), B3
  movaps 0x30+B_OFFSET_62(B), B4
  movaps 0x0+A_OFFSET_26(A), A11
  movaps 0x10+A_OFFSET_26(A), A12
  movaps 0x20+A_OFFSET_26(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_26(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_26(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_26(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_26(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_26(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_26(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_26(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_26(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_26(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_26(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_26(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_26(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_26(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,2) to already existing.
  addps 0x0+C_OFFSET_22(C), C1
  addps 0x10+C_OFFSET_22(C), C2
  addps 0x20+C_OFFSET_22(C), C3
  addps 0x30+C_OFFSET_22(C), C4

  # Write out C(2,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_22(C)
  movaps C2, 0x10+C_OFFSET_22(C)
  movaps C3, 0x20+C_OFFSET_22(C)
  movaps C4, 0x30+C_OFFSET_22(C)

  .align 16
block_73:

  # Check norm of product A(1,7)*B(7,1).
  movss 0x30(multiply_stream, base_pointer), B1
  mulss 0x1d8(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_74

  # Reset C(1,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,1) = A(1,7)*B(7,1).
  movaps 0x0+B_OFFSET_71(B), B1
  movaps 0x10+B_OFFSET_71(B), B2
  movaps 0x20+B_OFFSET_71(B), B3
  movaps 0x30+B_OFFSET_71(B), B4
  movaps 0x0+A_OFFSET_17(A), A11
  movaps 0x10+A_OFFSET_17(A), A12
  movaps 0x20+A_OFFSET_17(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_17(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_17(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_17(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_17(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_17(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_17(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_17(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_17(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_17(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_17(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_17(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_17(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_17(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,1) to already existing.
  addps 0x0+C_OFFSET_11(C), C1
  addps 0x10+C_OFFSET_11(C), C2
  addps 0x20+C_OFFSET_11(C), C3
  addps 0x30+C_OFFSET_11(C), C4

  # Write out C(1,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_11(C)
  movaps C2, 0x10+C_OFFSET_11(C)
  movaps C3, 0x20+C_OFFSET_11(C)
  movaps C4, 0x30+C_OFFSET_11(C)

  .align 16
block_74:

  # Check norm of product A(1,8)*B(8,1).
  movss 0x34(multiply_stream, base_pointer), B1
  mulss 0x1f8(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_75

  # Reset C(1,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,1) = A(1,8)*B(8,1).
  movaps 0x0+B_OFFSET_81(B), B1
  movaps 0x10+B_OFFSET_81(B), B2
  movaps 0x20+B_OFFSET_81(B), B3
  movaps 0x30+B_OFFSET_81(B), B4
  movaps 0x0+A_OFFSET_18(A), A11
  movaps 0x10+A_OFFSET_18(A), A12
  movaps 0x20+A_OFFSET_18(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_18(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_18(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_18(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_18(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_18(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_18(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_18(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_18(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_18(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_18(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_18(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_18(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_18(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,1) to already existing.
  addps 0x0+C_OFFSET_11(C), C1
  addps 0x10+C_OFFSET_11(C), C2
  addps 0x20+C_OFFSET_11(C), C3
  addps 0x30+C_OFFSET_11(C), C4

  # Write out C(1,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_11(C)
  movaps C2, 0x10+C_OFFSET_11(C)
  movaps C3, 0x20+C_OFFSET_11(C)
  movaps C4, 0x30+C_OFFSET_11(C)

  .align 16
block_75:

  # Check norm of product A(1,7)*B(7,2).
  movss 0x30(multiply_stream, base_pointer), B1
  mulss 0x1dc(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_76

  # Reset C(1,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,2) = A(1,7)*B(7,2).
  movaps 0x0+B_OFFSET_72(B), B1
  movaps 0x10+B_OFFSET_72(B), B2
  movaps 0x20+B_OFFSET_72(B), B3
  movaps 0x30+B_OFFSET_72(B), B4
  movaps 0x0+A_OFFSET_17(A), A11
  movaps 0x10+A_OFFSET_17(A), A12
  movaps 0x20+A_OFFSET_17(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_17(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_17(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_17(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_17(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_17(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_17(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_17(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_17(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_17(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_17(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_17(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_17(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_17(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,2) to already existing.
  addps 0x0+C_OFFSET_12(C), C1
  addps 0x10+C_OFFSET_12(C), C2
  addps 0x20+C_OFFSET_12(C), C3
  addps 0x30+C_OFFSET_12(C), C4

  # Write out C(1,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_12(C)
  movaps C2, 0x10+C_OFFSET_12(C)
  movaps C3, 0x20+C_OFFSET_12(C)
  movaps C4, 0x30+C_OFFSET_12(C)

  .align 16
block_76:

  # Check norm of product A(1,8)*B(8,2).
  movss 0x34(multiply_stream, base_pointer), B1
  mulss 0x1fc(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_77

  # Reset C(1,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,2) = A(1,8)*B(8,2).
  movaps 0x0+B_OFFSET_82(B), B1
  movaps 0x10+B_OFFSET_82(B), B2
  movaps 0x20+B_OFFSET_82(B), B3
  movaps 0x30+B_OFFSET_82(B), B4
  movaps 0x0+A_OFFSET_18(A), A11
  movaps 0x10+A_OFFSET_18(A), A12
  movaps 0x20+A_OFFSET_18(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_18(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_18(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_18(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_18(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_18(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_18(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_18(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_18(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_18(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_18(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_18(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_18(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_18(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,2) to already existing.
  addps 0x0+C_OFFSET_12(C), C1
  addps 0x10+C_OFFSET_12(C), C2
  addps 0x20+C_OFFSET_12(C), C3
  addps 0x30+C_OFFSET_12(C), C4

  # Write out C(1,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_12(C)
  movaps C2, 0x10+C_OFFSET_12(C)
  movaps C3, 0x20+C_OFFSET_12(C)
  movaps C4, 0x30+C_OFFSET_12(C)

  .align 16
block_77:

  # Check norm of product A(2,7)*B(7,1).
  movss 0x50(multiply_stream, base_pointer), B1
  mulss 0x1d8(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_78

  # Reset C(2,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,1) = A(2,7)*B(7,1).
  movaps 0x0+B_OFFSET_71(B), B1
  movaps 0x10+B_OFFSET_71(B), B2
  movaps 0x20+B_OFFSET_71(B), B3
  movaps 0x30+B_OFFSET_71(B), B4
  movaps 0x0+A_OFFSET_27(A), A11
  movaps 0x10+A_OFFSET_27(A), A12
  movaps 0x20+A_OFFSET_27(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_27(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_27(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_27(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_27(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_27(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_27(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_27(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_27(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_27(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_27(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_27(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_27(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_27(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,1) to already existing.
  addps 0x0+C_OFFSET_21(C), C1
  addps 0x10+C_OFFSET_21(C), C2
  addps 0x20+C_OFFSET_21(C), C3
  addps 0x30+C_OFFSET_21(C), C4

  # Write out C(2,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_21(C)
  movaps C2, 0x10+C_OFFSET_21(C)
  movaps C3, 0x20+C_OFFSET_21(C)
  movaps C4, 0x30+C_OFFSET_21(C)

  .align 16
block_78:

  # Check norm of product A(2,8)*B(8,1).
  movss 0x54(multiply_stream, base_pointer), B1
  mulss 0x1f8(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_79

  # Reset C(2,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,1) = A(2,8)*B(8,1).
  movaps 0x0+B_OFFSET_81(B), B1
  movaps 0x10+B_OFFSET_81(B), B2
  movaps 0x20+B_OFFSET_81(B), B3
  movaps 0x30+B_OFFSET_81(B), B4
  movaps 0x0+A_OFFSET_28(A), A11
  movaps 0x10+A_OFFSET_28(A), A12
  movaps 0x20+A_OFFSET_28(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_28(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_28(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_28(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_28(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_28(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_28(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_28(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_28(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_28(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_28(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_28(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_28(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_28(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,1) to already existing.
  addps 0x0+C_OFFSET_21(C), C1
  addps 0x10+C_OFFSET_21(C), C2
  addps 0x20+C_OFFSET_21(C), C3
  addps 0x30+C_OFFSET_21(C), C4

  # Write out C(2,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_21(C)
  movaps C2, 0x10+C_OFFSET_21(C)
  movaps C3, 0x20+C_OFFSET_21(C)
  movaps C4, 0x30+C_OFFSET_21(C)

  .align 16
block_79:

  # Check norm of product A(2,7)*B(7,2).
  movss 0x50(multiply_stream, base_pointer), B1
  mulss 0x1dc(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_80

  # Reset C(2,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,2) = A(2,7)*B(7,2).
  movaps 0x0+B_OFFSET_72(B), B1
  movaps 0x10+B_OFFSET_72(B), B2
  movaps 0x20+B_OFFSET_72(B), B3
  movaps 0x30+B_OFFSET_72(B), B4
  movaps 0x0+A_OFFSET_27(A), A11
  movaps 0x10+A_OFFSET_27(A), A12
  movaps 0x20+A_OFFSET_27(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_27(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_27(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_27(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_27(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_27(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_27(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_27(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_27(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_27(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_27(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_27(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_27(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_27(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,2) to already existing.
  addps 0x0+C_OFFSET_22(C), C1
  addps 0x10+C_OFFSET_22(C), C2
  addps 0x20+C_OFFSET_22(C), C3
  addps 0x30+C_OFFSET_22(C), C4

  # Write out C(2,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_22(C)
  movaps C2, 0x10+C_OFFSET_22(C)
  movaps C3, 0x20+C_OFFSET_22(C)
  movaps C4, 0x30+C_OFFSET_22(C)

  .align 16
block_80:

  # Check norm of product A(2,8)*B(8,2).
  movss 0x54(multiply_stream, base_pointer), B1
  mulss 0x1fc(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_81

  # Reset C(2,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,2) = A(2,8)*B(8,2).
  movaps 0x0+B_OFFSET_82(B), B1
  movaps 0x10+B_OFFSET_82(B), B2
  movaps 0x20+B_OFFSET_82(B), B3
  movaps 0x30+B_OFFSET_82(B), B4
  movaps 0x0+A_OFFSET_28(A), A11
  movaps 0x10+A_OFFSET_28(A), A12
  movaps 0x20+A_OFFSET_28(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_28(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_28(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_28(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_28(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_28(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_28(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_28(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_28(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_28(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_28(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_28(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_28(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_28(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,2) to already existing.
  addps 0x0+C_OFFSET_22(C), C1
  addps 0x10+C_OFFSET_22(C), C2
  addps 0x20+C_OFFSET_22(C), C3
  addps 0x30+C_OFFSET_22(C), C4

  # Write out C(2,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_22(C)
  movaps C2, 0x10+C_OFFSET_22(C)
  movaps C3, 0x20+C_OFFSET_22(C)
  movaps C4, 0x30+C_OFFSET_22(C)

  .align 16
block_81:

  # Check norm of product A(1,5)*B(5,3).
  movss 0x28(multiply_stream, base_pointer), B1
  mulss 0x1a0(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_82

  # Reset C(1,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,3) = A(1,5)*B(5,3).
  movaps 0x0+B_OFFSET_53(B), B1
  movaps 0x10+B_OFFSET_53(B), B2
  movaps 0x20+B_OFFSET_53(B), B3
  movaps 0x30+B_OFFSET_53(B), B4
  movaps 0x0+A_OFFSET_15(A), A11
  movaps 0x10+A_OFFSET_15(A), A12
  movaps 0x20+A_OFFSET_15(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_15(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_15(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_15(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_15(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_15(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_15(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_15(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_15(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_15(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_15(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_15(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_15(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_15(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,3) to already existing.
  addps 0x0+C_OFFSET_13(C), C1
  addps 0x10+C_OFFSET_13(C), C2
  addps 0x20+C_OFFSET_13(C), C3
  addps 0x30+C_OFFSET_13(C), C4

  # Write out C(1,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_13(C)
  movaps C2, 0x10+C_OFFSET_13(C)
  movaps C3, 0x20+C_OFFSET_13(C)
  movaps C4, 0x30+C_OFFSET_13(C)

  .align 16
block_82:

  # Check norm of product A(1,6)*B(6,3).
  movss 0x2c(multiply_stream, base_pointer), B1
  mulss 0x1c0(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_83

  # Reset C(1,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,3) = A(1,6)*B(6,3).
  movaps 0x0+B_OFFSET_63(B), B1
  movaps 0x10+B_OFFSET_63(B), B2
  movaps 0x20+B_OFFSET_63(B), B3
  movaps 0x30+B_OFFSET_63(B), B4
  movaps 0x0+A_OFFSET_16(A), A11
  movaps 0x10+A_OFFSET_16(A), A12
  movaps 0x20+A_OFFSET_16(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_16(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_16(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_16(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_16(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_16(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_16(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_16(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_16(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_16(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_16(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_16(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_16(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_16(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,3) to already existing.
  addps 0x0+C_OFFSET_13(C), C1
  addps 0x10+C_OFFSET_13(C), C2
  addps 0x20+C_OFFSET_13(C), C3
  addps 0x30+C_OFFSET_13(C), C4

  # Write out C(1,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_13(C)
  movaps C2, 0x10+C_OFFSET_13(C)
  movaps C3, 0x20+C_OFFSET_13(C)
  movaps C4, 0x30+C_OFFSET_13(C)

  .align 16
block_83:

  # Check norm of product A(1,5)*B(5,4).
  movss 0x28(multiply_stream, base_pointer), B1
  mulss 0x1a4(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_84

  # Reset C(1,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,4) = A(1,5)*B(5,4).
  movaps 0x0+B_OFFSET_54(B), B1
  movaps 0x10+B_OFFSET_54(B), B2
  movaps 0x20+B_OFFSET_54(B), B3
  movaps 0x30+B_OFFSET_54(B), B4
  movaps 0x0+A_OFFSET_15(A), A11
  movaps 0x10+A_OFFSET_15(A), A12
  movaps 0x20+A_OFFSET_15(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_15(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_15(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_15(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_15(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_15(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_15(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_15(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_15(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_15(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_15(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_15(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_15(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_15(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,4) to already existing.
  addps 0x0+C_OFFSET_14(C), C1
  addps 0x10+C_OFFSET_14(C), C2
  addps 0x20+C_OFFSET_14(C), C3
  addps 0x30+C_OFFSET_14(C), C4

  # Write out C(1,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_14(C)
  movaps C2, 0x10+C_OFFSET_14(C)
  movaps C3, 0x20+C_OFFSET_14(C)
  movaps C4, 0x30+C_OFFSET_14(C)

  .align 16
block_84:

  # Check norm of product A(1,6)*B(6,4).
  movss 0x2c(multiply_stream, base_pointer), B1
  mulss 0x1c4(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_85

  # Reset C(1,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,4) = A(1,6)*B(6,4).
  movaps 0x0+B_OFFSET_64(B), B1
  movaps 0x10+B_OFFSET_64(B), B2
  movaps 0x20+B_OFFSET_64(B), B3
  movaps 0x30+B_OFFSET_64(B), B4
  movaps 0x0+A_OFFSET_16(A), A11
  movaps 0x10+A_OFFSET_16(A), A12
  movaps 0x20+A_OFFSET_16(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_16(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_16(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_16(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_16(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_16(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_16(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_16(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_16(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_16(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_16(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_16(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_16(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_16(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,4) to already existing.
  addps 0x0+C_OFFSET_14(C), C1
  addps 0x10+C_OFFSET_14(C), C2
  addps 0x20+C_OFFSET_14(C), C3
  addps 0x30+C_OFFSET_14(C), C4

  # Write out C(1,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_14(C)
  movaps C2, 0x10+C_OFFSET_14(C)
  movaps C3, 0x20+C_OFFSET_14(C)
  movaps C4, 0x30+C_OFFSET_14(C)

  .align 16
block_85:

  # Check norm of product A(2,5)*B(5,3).
  movss 0x48(multiply_stream, base_pointer), B1
  mulss 0x1a0(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_86

  # Reset C(2,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,3) = A(2,5)*B(5,3).
  movaps 0x0+B_OFFSET_53(B), B1
  movaps 0x10+B_OFFSET_53(B), B2
  movaps 0x20+B_OFFSET_53(B), B3
  movaps 0x30+B_OFFSET_53(B), B4
  movaps 0x0+A_OFFSET_25(A), A11
  movaps 0x10+A_OFFSET_25(A), A12
  movaps 0x20+A_OFFSET_25(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_25(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_25(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_25(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_25(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_25(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_25(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_25(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_25(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_25(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_25(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_25(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_25(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_25(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,3) to already existing.
  addps 0x0+C_OFFSET_23(C), C1
  addps 0x10+C_OFFSET_23(C), C2
  addps 0x20+C_OFFSET_23(C), C3
  addps 0x30+C_OFFSET_23(C), C4

  # Write out C(2,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_23(C)
  movaps C2, 0x10+C_OFFSET_23(C)
  movaps C3, 0x20+C_OFFSET_23(C)
  movaps C4, 0x30+C_OFFSET_23(C)

  .align 16
block_86:

  # Check norm of product A(2,6)*B(6,3).
  movss 0x4c(multiply_stream, base_pointer), B1
  mulss 0x1c0(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_87

  # Reset C(2,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,3) = A(2,6)*B(6,3).
  movaps 0x0+B_OFFSET_63(B), B1
  movaps 0x10+B_OFFSET_63(B), B2
  movaps 0x20+B_OFFSET_63(B), B3
  movaps 0x30+B_OFFSET_63(B), B4
  movaps 0x0+A_OFFSET_26(A), A11
  movaps 0x10+A_OFFSET_26(A), A12
  movaps 0x20+A_OFFSET_26(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_26(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_26(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_26(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_26(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_26(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_26(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_26(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_26(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_26(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_26(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_26(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_26(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_26(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,3) to already existing.
  addps 0x0+C_OFFSET_23(C), C1
  addps 0x10+C_OFFSET_23(C), C2
  addps 0x20+C_OFFSET_23(C), C3
  addps 0x30+C_OFFSET_23(C), C4

  # Write out C(2,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_23(C)
  movaps C2, 0x10+C_OFFSET_23(C)
  movaps C3, 0x20+C_OFFSET_23(C)
  movaps C4, 0x30+C_OFFSET_23(C)

  .align 16
block_87:

  # Check norm of product A(2,5)*B(5,4).
  movss 0x48(multiply_stream, base_pointer), B1
  mulss 0x1a4(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_88

  # Reset C(2,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,4) = A(2,5)*B(5,4).
  movaps 0x0+B_OFFSET_54(B), B1
  movaps 0x10+B_OFFSET_54(B), B2
  movaps 0x20+B_OFFSET_54(B), B3
  movaps 0x30+B_OFFSET_54(B), B4
  movaps 0x0+A_OFFSET_25(A), A11
  movaps 0x10+A_OFFSET_25(A), A12
  movaps 0x20+A_OFFSET_25(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_25(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_25(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_25(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_25(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_25(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_25(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_25(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_25(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_25(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_25(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_25(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_25(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_25(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,4) to already existing.
  addps 0x0+C_OFFSET_24(C), C1
  addps 0x10+C_OFFSET_24(C), C2
  addps 0x20+C_OFFSET_24(C), C3
  addps 0x30+C_OFFSET_24(C), C4

  # Write out C(2,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_24(C)
  movaps C2, 0x10+C_OFFSET_24(C)
  movaps C3, 0x20+C_OFFSET_24(C)
  movaps C4, 0x30+C_OFFSET_24(C)

  .align 16
block_88:

  # Check norm of product A(2,6)*B(6,4).
  movss 0x4c(multiply_stream, base_pointer), B1
  mulss 0x1c4(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_89

  # Reset C(2,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,4) = A(2,6)*B(6,4).
  movaps 0x0+B_OFFSET_64(B), B1
  movaps 0x10+B_OFFSET_64(B), B2
  movaps 0x20+B_OFFSET_64(B), B3
  movaps 0x30+B_OFFSET_64(B), B4
  movaps 0x0+A_OFFSET_26(A), A11
  movaps 0x10+A_OFFSET_26(A), A12
  movaps 0x20+A_OFFSET_26(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_26(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_26(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_26(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_26(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_26(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_26(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_26(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_26(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_26(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_26(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_26(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_26(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_26(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,4) to already existing.
  addps 0x0+C_OFFSET_24(C), C1
  addps 0x10+C_OFFSET_24(C), C2
  addps 0x20+C_OFFSET_24(C), C3
  addps 0x30+C_OFFSET_24(C), C4

  # Write out C(2,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_24(C)
  movaps C2, 0x10+C_OFFSET_24(C)
  movaps C3, 0x20+C_OFFSET_24(C)
  movaps C4, 0x30+C_OFFSET_24(C)

  .align 16
block_89:

  # Check norm of product A(1,7)*B(7,3).
  movss 0x30(multiply_stream, base_pointer), B1
  mulss 0x1e0(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_90

  # Reset C(1,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,3) = A(1,7)*B(7,3).
  movaps 0x0+B_OFFSET_73(B), B1
  movaps 0x10+B_OFFSET_73(B), B2
  movaps 0x20+B_OFFSET_73(B), B3
  movaps 0x30+B_OFFSET_73(B), B4
  movaps 0x0+A_OFFSET_17(A), A11
  movaps 0x10+A_OFFSET_17(A), A12
  movaps 0x20+A_OFFSET_17(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_17(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_17(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_17(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_17(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_17(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_17(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_17(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_17(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_17(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_17(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_17(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_17(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_17(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,3) to already existing.
  addps 0x0+C_OFFSET_13(C), C1
  addps 0x10+C_OFFSET_13(C), C2
  addps 0x20+C_OFFSET_13(C), C3
  addps 0x30+C_OFFSET_13(C), C4

  # Write out C(1,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_13(C)
  movaps C2, 0x10+C_OFFSET_13(C)
  movaps C3, 0x20+C_OFFSET_13(C)
  movaps C4, 0x30+C_OFFSET_13(C)

  .align 16
block_90:

  # Check norm of product A(1,8)*B(8,3).
  movss 0x34(multiply_stream, base_pointer), B1
  mulss 0x200(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_91

  # Reset C(1,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,3) = A(1,8)*B(8,3).
  movaps 0x0+B_OFFSET_83(B), B1
  movaps 0x10+B_OFFSET_83(B), B2
  movaps 0x20+B_OFFSET_83(B), B3
  movaps 0x30+B_OFFSET_83(B), B4
  movaps 0x0+A_OFFSET_18(A), A11
  movaps 0x10+A_OFFSET_18(A), A12
  movaps 0x20+A_OFFSET_18(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_18(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_18(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_18(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_18(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_18(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_18(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_18(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_18(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_18(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_18(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_18(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_18(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_18(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,3) to already existing.
  addps 0x0+C_OFFSET_13(C), C1
  addps 0x10+C_OFFSET_13(C), C2
  addps 0x20+C_OFFSET_13(C), C3
  addps 0x30+C_OFFSET_13(C), C4

  # Write out C(1,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_13(C)
  movaps C2, 0x10+C_OFFSET_13(C)
  movaps C3, 0x20+C_OFFSET_13(C)
  movaps C4, 0x30+C_OFFSET_13(C)

  .align 16
block_91:

  # Check norm of product A(1,7)*B(7,4).
  movss 0x30(multiply_stream, base_pointer), B1
  mulss 0x1e4(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_92

  # Reset C(1,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,4) = A(1,7)*B(7,4).
  movaps 0x0+B_OFFSET_74(B), B1
  movaps 0x10+B_OFFSET_74(B), B2
  movaps 0x20+B_OFFSET_74(B), B3
  movaps 0x30+B_OFFSET_74(B), B4
  movaps 0x0+A_OFFSET_17(A), A11
  movaps 0x10+A_OFFSET_17(A), A12
  movaps 0x20+A_OFFSET_17(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_17(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_17(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_17(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_17(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_17(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_17(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_17(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_17(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_17(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_17(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_17(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_17(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_17(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,4) to already existing.
  addps 0x0+C_OFFSET_14(C), C1
  addps 0x10+C_OFFSET_14(C), C2
  addps 0x20+C_OFFSET_14(C), C3
  addps 0x30+C_OFFSET_14(C), C4

  # Write out C(1,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_14(C)
  movaps C2, 0x10+C_OFFSET_14(C)
  movaps C3, 0x20+C_OFFSET_14(C)
  movaps C4, 0x30+C_OFFSET_14(C)

  .align 16
block_92:

  # Check norm of product A(1,8)*B(8,4).
  movss 0x34(multiply_stream, base_pointer), B1
  mulss 0x204(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_93

  # Reset C(1,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,4) = A(1,8)*B(8,4).
  movaps 0x0+B_OFFSET_84(B), B1
  movaps 0x10+B_OFFSET_84(B), B2
  movaps 0x20+B_OFFSET_84(B), B3
  movaps 0x30+B_OFFSET_84(B), B4
  movaps 0x0+A_OFFSET_18(A), A11
  movaps 0x10+A_OFFSET_18(A), A12
  movaps 0x20+A_OFFSET_18(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_18(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_18(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_18(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_18(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_18(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_18(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_18(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_18(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_18(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_18(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_18(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_18(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_18(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,4) to already existing.
  addps 0x0+C_OFFSET_14(C), C1
  addps 0x10+C_OFFSET_14(C), C2
  addps 0x20+C_OFFSET_14(C), C3
  addps 0x30+C_OFFSET_14(C), C4

  # Write out C(1,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_14(C)
  movaps C2, 0x10+C_OFFSET_14(C)
  movaps C3, 0x20+C_OFFSET_14(C)
  movaps C4, 0x30+C_OFFSET_14(C)

  .align 16
block_93:

  # Check norm of product A(2,7)*B(7,3).
  movss 0x50(multiply_stream, base_pointer), B1
  mulss 0x1e0(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_94

  # Reset C(2,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,3) = A(2,7)*B(7,3).
  movaps 0x0+B_OFFSET_73(B), B1
  movaps 0x10+B_OFFSET_73(B), B2
  movaps 0x20+B_OFFSET_73(B), B3
  movaps 0x30+B_OFFSET_73(B), B4
  movaps 0x0+A_OFFSET_27(A), A11
  movaps 0x10+A_OFFSET_27(A), A12
  movaps 0x20+A_OFFSET_27(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_27(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_27(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_27(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_27(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_27(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_27(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_27(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_27(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_27(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_27(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_27(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_27(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_27(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,3) to already existing.
  addps 0x0+C_OFFSET_23(C), C1
  addps 0x10+C_OFFSET_23(C), C2
  addps 0x20+C_OFFSET_23(C), C3
  addps 0x30+C_OFFSET_23(C), C4

  # Write out C(2,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_23(C)
  movaps C2, 0x10+C_OFFSET_23(C)
  movaps C3, 0x20+C_OFFSET_23(C)
  movaps C4, 0x30+C_OFFSET_23(C)

  .align 16
block_94:

  # Check norm of product A(2,8)*B(8,3).
  movss 0x54(multiply_stream, base_pointer), B1
  mulss 0x200(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_95

  # Reset C(2,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,3) = A(2,8)*B(8,3).
  movaps 0x0+B_OFFSET_83(B), B1
  movaps 0x10+B_OFFSET_83(B), B2
  movaps 0x20+B_OFFSET_83(B), B3
  movaps 0x30+B_OFFSET_83(B), B4
  movaps 0x0+A_OFFSET_28(A), A11
  movaps 0x10+A_OFFSET_28(A), A12
  movaps 0x20+A_OFFSET_28(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_28(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_28(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_28(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_28(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_28(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_28(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_28(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_28(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_28(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_28(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_28(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_28(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_28(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,3) to already existing.
  addps 0x0+C_OFFSET_23(C), C1
  addps 0x10+C_OFFSET_23(C), C2
  addps 0x20+C_OFFSET_23(C), C3
  addps 0x30+C_OFFSET_23(C), C4

  # Write out C(2,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_23(C)
  movaps C2, 0x10+C_OFFSET_23(C)
  movaps C3, 0x20+C_OFFSET_23(C)
  movaps C4, 0x30+C_OFFSET_23(C)

  .align 16
block_95:

  # Check norm of product A(2,7)*B(7,4).
  movss 0x50(multiply_stream, base_pointer), B1
  mulss 0x1e4(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_96

  # Reset C(2,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,4) = A(2,7)*B(7,4).
  movaps 0x0+B_OFFSET_74(B), B1
  movaps 0x10+B_OFFSET_74(B), B2
  movaps 0x20+B_OFFSET_74(B), B3
  movaps 0x30+B_OFFSET_74(B), B4
  movaps 0x0+A_OFFSET_27(A), A11
  movaps 0x10+A_OFFSET_27(A), A12
  movaps 0x20+A_OFFSET_27(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_27(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_27(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_27(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_27(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_27(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_27(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_27(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_27(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_27(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_27(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_27(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_27(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_27(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,4) to already existing.
  addps 0x0+C_OFFSET_24(C), C1
  addps 0x10+C_OFFSET_24(C), C2
  addps 0x20+C_OFFSET_24(C), C3
  addps 0x30+C_OFFSET_24(C), C4

  # Write out C(2,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_24(C)
  movaps C2, 0x10+C_OFFSET_24(C)
  movaps C3, 0x20+C_OFFSET_24(C)
  movaps C4, 0x30+C_OFFSET_24(C)

  .align 16
block_96:

  # Check norm of product A(2,8)*B(8,4).
  movss 0x54(multiply_stream, base_pointer), B1
  mulss 0x204(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_97

  # Reset C(2,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,4) = A(2,8)*B(8,4).
  movaps 0x0+B_OFFSET_84(B), B1
  movaps 0x10+B_OFFSET_84(B), B2
  movaps 0x20+B_OFFSET_84(B), B3
  movaps 0x30+B_OFFSET_84(B), B4
  movaps 0x0+A_OFFSET_28(A), A11
  movaps 0x10+A_OFFSET_28(A), A12
  movaps 0x20+A_OFFSET_28(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_28(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_28(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_28(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_28(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_28(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_28(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_28(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_28(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_28(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_28(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_28(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_28(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_28(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,4) to already existing.
  addps 0x0+C_OFFSET_24(C), C1
  addps 0x10+C_OFFSET_24(C), C2
  addps 0x20+C_OFFSET_24(C), C3
  addps 0x30+C_OFFSET_24(C), C4

  # Write out C(2,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_24(C)
  movaps C2, 0x10+C_OFFSET_24(C)
  movaps C3, 0x20+C_OFFSET_24(C)
  movaps C4, 0x30+C_OFFSET_24(C)

  .align 16
block_97:

  # Check norm of product A(3,5)*B(5,1).
  movss 0x68(multiply_stream, base_pointer), B1
  mulss 0x198(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_98

  # Reset C(3,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,1) = A(3,5)*B(5,1).
  movaps 0x0+B_OFFSET_51(B), B1
  movaps 0x10+B_OFFSET_51(B), B2
  movaps 0x20+B_OFFSET_51(B), B3
  movaps 0x30+B_OFFSET_51(B), B4
  movaps 0x0+A_OFFSET_35(A), A11
  movaps 0x10+A_OFFSET_35(A), A12
  movaps 0x20+A_OFFSET_35(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_35(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_35(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_35(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_35(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_35(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_35(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_35(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_35(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_35(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_35(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_35(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_35(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_35(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,1) to already existing.
  addps 0x0+C_OFFSET_31(C), C1
  addps 0x10+C_OFFSET_31(C), C2
  addps 0x20+C_OFFSET_31(C), C3
  addps 0x30+C_OFFSET_31(C), C4

  # Write out C(3,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_31(C)
  movaps C2, 0x10+C_OFFSET_31(C)
  movaps C3, 0x20+C_OFFSET_31(C)
  movaps C4, 0x30+C_OFFSET_31(C)

  .align 16
block_98:

  # Check norm of product A(3,6)*B(6,1).
  movss 0x6c(multiply_stream, base_pointer), B1
  mulss 0x1b8(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_99

  # Reset C(3,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,1) = A(3,6)*B(6,1).
  movaps 0x0+B_OFFSET_61(B), B1
  movaps 0x10+B_OFFSET_61(B), B2
  movaps 0x20+B_OFFSET_61(B), B3
  movaps 0x30+B_OFFSET_61(B), B4
  movaps 0x0+A_OFFSET_36(A), A11
  movaps 0x10+A_OFFSET_36(A), A12
  movaps 0x20+A_OFFSET_36(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_36(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_36(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_36(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_36(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_36(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_36(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_36(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_36(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_36(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_36(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_36(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_36(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_36(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,1) to already existing.
  addps 0x0+C_OFFSET_31(C), C1
  addps 0x10+C_OFFSET_31(C), C2
  addps 0x20+C_OFFSET_31(C), C3
  addps 0x30+C_OFFSET_31(C), C4

  # Write out C(3,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_31(C)
  movaps C2, 0x10+C_OFFSET_31(C)
  movaps C3, 0x20+C_OFFSET_31(C)
  movaps C4, 0x30+C_OFFSET_31(C)

  .align 16
block_99:

  # Check norm of product A(3,5)*B(5,2).
  movss 0x68(multiply_stream, base_pointer), B1
  mulss 0x19c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_100

  # Reset C(3,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,2) = A(3,5)*B(5,2).
  movaps 0x0+B_OFFSET_52(B), B1
  movaps 0x10+B_OFFSET_52(B), B2
  movaps 0x20+B_OFFSET_52(B), B3
  movaps 0x30+B_OFFSET_52(B), B4
  movaps 0x0+A_OFFSET_35(A), A11
  movaps 0x10+A_OFFSET_35(A), A12
  movaps 0x20+A_OFFSET_35(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_35(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_35(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_35(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_35(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_35(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_35(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_35(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_35(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_35(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_35(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_35(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_35(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_35(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,2) to already existing.
  addps 0x0+C_OFFSET_32(C), C1
  addps 0x10+C_OFFSET_32(C), C2
  addps 0x20+C_OFFSET_32(C), C3
  addps 0x30+C_OFFSET_32(C), C4

  # Write out C(3,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_32(C)
  movaps C2, 0x10+C_OFFSET_32(C)
  movaps C3, 0x20+C_OFFSET_32(C)
  movaps C4, 0x30+C_OFFSET_32(C)

  .align 16
block_100:

  # Check norm of product A(3,6)*B(6,2).
  movss 0x6c(multiply_stream, base_pointer), B1
  mulss 0x1bc(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_101

  # Reset C(3,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,2) = A(3,6)*B(6,2).
  movaps 0x0+B_OFFSET_62(B), B1
  movaps 0x10+B_OFFSET_62(B), B2
  movaps 0x20+B_OFFSET_62(B), B3
  movaps 0x30+B_OFFSET_62(B), B4
  movaps 0x0+A_OFFSET_36(A), A11
  movaps 0x10+A_OFFSET_36(A), A12
  movaps 0x20+A_OFFSET_36(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_36(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_36(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_36(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_36(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_36(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_36(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_36(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_36(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_36(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_36(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_36(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_36(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_36(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,2) to already existing.
  addps 0x0+C_OFFSET_32(C), C1
  addps 0x10+C_OFFSET_32(C), C2
  addps 0x20+C_OFFSET_32(C), C3
  addps 0x30+C_OFFSET_32(C), C4

  # Write out C(3,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_32(C)
  movaps C2, 0x10+C_OFFSET_32(C)
  movaps C3, 0x20+C_OFFSET_32(C)
  movaps C4, 0x30+C_OFFSET_32(C)

  .align 16
block_101:

  # Check norm of product A(4,5)*B(5,1).
  movss 0x88(multiply_stream, base_pointer), B1
  mulss 0x198(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_102

  # Reset C(4,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,1) = A(4,5)*B(5,1).
  movaps 0x0+B_OFFSET_51(B), B1
  movaps 0x10+B_OFFSET_51(B), B2
  movaps 0x20+B_OFFSET_51(B), B3
  movaps 0x30+B_OFFSET_51(B), B4
  movaps 0x0+A_OFFSET_45(A), A11
  movaps 0x10+A_OFFSET_45(A), A12
  movaps 0x20+A_OFFSET_45(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_45(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_45(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_45(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_45(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_45(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_45(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_45(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_45(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_45(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_45(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_45(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_45(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_45(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,1) to already existing.
  addps 0x0+C_OFFSET_41(C), C1
  addps 0x10+C_OFFSET_41(C), C2
  addps 0x20+C_OFFSET_41(C), C3
  addps 0x30+C_OFFSET_41(C), C4

  # Write out C(4,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_41(C)
  movaps C2, 0x10+C_OFFSET_41(C)
  movaps C3, 0x20+C_OFFSET_41(C)
  movaps C4, 0x30+C_OFFSET_41(C)

  .align 16
block_102:

  # Check norm of product A(4,6)*B(6,1).
  movss 0x8c(multiply_stream, base_pointer), B1
  mulss 0x1b8(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_103

  # Reset C(4,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,1) = A(4,6)*B(6,1).
  movaps 0x0+B_OFFSET_61(B), B1
  movaps 0x10+B_OFFSET_61(B), B2
  movaps 0x20+B_OFFSET_61(B), B3
  movaps 0x30+B_OFFSET_61(B), B4
  movaps 0x0+A_OFFSET_46(A), A11
  movaps 0x10+A_OFFSET_46(A), A12
  movaps 0x20+A_OFFSET_46(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_46(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_46(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_46(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_46(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_46(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_46(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_46(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_46(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_46(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_46(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_46(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_46(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_46(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,1) to already existing.
  addps 0x0+C_OFFSET_41(C), C1
  addps 0x10+C_OFFSET_41(C), C2
  addps 0x20+C_OFFSET_41(C), C3
  addps 0x30+C_OFFSET_41(C), C4

  # Write out C(4,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_41(C)
  movaps C2, 0x10+C_OFFSET_41(C)
  movaps C3, 0x20+C_OFFSET_41(C)
  movaps C4, 0x30+C_OFFSET_41(C)

  .align 16
block_103:

  # Check norm of product A(4,5)*B(5,2).
  movss 0x88(multiply_stream, base_pointer), B1
  mulss 0x19c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_104

  # Reset C(4,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,2) = A(4,5)*B(5,2).
  movaps 0x0+B_OFFSET_52(B), B1
  movaps 0x10+B_OFFSET_52(B), B2
  movaps 0x20+B_OFFSET_52(B), B3
  movaps 0x30+B_OFFSET_52(B), B4
  movaps 0x0+A_OFFSET_45(A), A11
  movaps 0x10+A_OFFSET_45(A), A12
  movaps 0x20+A_OFFSET_45(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_45(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_45(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_45(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_45(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_45(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_45(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_45(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_45(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_45(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_45(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_45(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_45(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_45(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,2) to already existing.
  addps 0x0+C_OFFSET_42(C), C1
  addps 0x10+C_OFFSET_42(C), C2
  addps 0x20+C_OFFSET_42(C), C3
  addps 0x30+C_OFFSET_42(C), C4

  # Write out C(4,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_42(C)
  movaps C2, 0x10+C_OFFSET_42(C)
  movaps C3, 0x20+C_OFFSET_42(C)
  movaps C4, 0x30+C_OFFSET_42(C)

  .align 16
block_104:

  # Check norm of product A(4,6)*B(6,2).
  movss 0x8c(multiply_stream, base_pointer), B1
  mulss 0x1bc(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_105

  # Reset C(4,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,2) = A(4,6)*B(6,2).
  movaps 0x0+B_OFFSET_62(B), B1
  movaps 0x10+B_OFFSET_62(B), B2
  movaps 0x20+B_OFFSET_62(B), B3
  movaps 0x30+B_OFFSET_62(B), B4
  movaps 0x0+A_OFFSET_46(A), A11
  movaps 0x10+A_OFFSET_46(A), A12
  movaps 0x20+A_OFFSET_46(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_46(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_46(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_46(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_46(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_46(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_46(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_46(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_46(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_46(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_46(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_46(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_46(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_46(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,2) to already existing.
  addps 0x0+C_OFFSET_42(C), C1
  addps 0x10+C_OFFSET_42(C), C2
  addps 0x20+C_OFFSET_42(C), C3
  addps 0x30+C_OFFSET_42(C), C4

  # Write out C(4,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_42(C)
  movaps C2, 0x10+C_OFFSET_42(C)
  movaps C3, 0x20+C_OFFSET_42(C)
  movaps C4, 0x30+C_OFFSET_42(C)

  .align 16
block_105:

  # Check norm of product A(3,7)*B(7,1).
  movss 0x70(multiply_stream, base_pointer), B1
  mulss 0x1d8(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_106

  # Reset C(3,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,1) = A(3,7)*B(7,1).
  movaps 0x0+B_OFFSET_71(B), B1
  movaps 0x10+B_OFFSET_71(B), B2
  movaps 0x20+B_OFFSET_71(B), B3
  movaps 0x30+B_OFFSET_71(B), B4
  movaps 0x0+A_OFFSET_37(A), A11
  movaps 0x10+A_OFFSET_37(A), A12
  movaps 0x20+A_OFFSET_37(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_37(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_37(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_37(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_37(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_37(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_37(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_37(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_37(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_37(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_37(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_37(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_37(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_37(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,1) to already existing.
  addps 0x0+C_OFFSET_31(C), C1
  addps 0x10+C_OFFSET_31(C), C2
  addps 0x20+C_OFFSET_31(C), C3
  addps 0x30+C_OFFSET_31(C), C4

  # Write out C(3,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_31(C)
  movaps C2, 0x10+C_OFFSET_31(C)
  movaps C3, 0x20+C_OFFSET_31(C)
  movaps C4, 0x30+C_OFFSET_31(C)

  .align 16
block_106:

  # Check norm of product A(3,8)*B(8,1).
  movss 0x74(multiply_stream, base_pointer), B1
  mulss 0x1f8(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_107

  # Reset C(3,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,1) = A(3,8)*B(8,1).
  movaps 0x0+B_OFFSET_81(B), B1
  movaps 0x10+B_OFFSET_81(B), B2
  movaps 0x20+B_OFFSET_81(B), B3
  movaps 0x30+B_OFFSET_81(B), B4
  movaps 0x0+A_OFFSET_38(A), A11
  movaps 0x10+A_OFFSET_38(A), A12
  movaps 0x20+A_OFFSET_38(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_38(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_38(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_38(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_38(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_38(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_38(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_38(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_38(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_38(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_38(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_38(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_38(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_38(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,1) to already existing.
  addps 0x0+C_OFFSET_31(C), C1
  addps 0x10+C_OFFSET_31(C), C2
  addps 0x20+C_OFFSET_31(C), C3
  addps 0x30+C_OFFSET_31(C), C4

  # Write out C(3,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_31(C)
  movaps C2, 0x10+C_OFFSET_31(C)
  movaps C3, 0x20+C_OFFSET_31(C)
  movaps C4, 0x30+C_OFFSET_31(C)

  .align 16
block_107:

  # Check norm of product A(3,7)*B(7,2).
  movss 0x70(multiply_stream, base_pointer), B1
  mulss 0x1dc(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_108

  # Reset C(3,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,2) = A(3,7)*B(7,2).
  movaps 0x0+B_OFFSET_72(B), B1
  movaps 0x10+B_OFFSET_72(B), B2
  movaps 0x20+B_OFFSET_72(B), B3
  movaps 0x30+B_OFFSET_72(B), B4
  movaps 0x0+A_OFFSET_37(A), A11
  movaps 0x10+A_OFFSET_37(A), A12
  movaps 0x20+A_OFFSET_37(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_37(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_37(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_37(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_37(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_37(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_37(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_37(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_37(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_37(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_37(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_37(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_37(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_37(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,2) to already existing.
  addps 0x0+C_OFFSET_32(C), C1
  addps 0x10+C_OFFSET_32(C), C2
  addps 0x20+C_OFFSET_32(C), C3
  addps 0x30+C_OFFSET_32(C), C4

  # Write out C(3,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_32(C)
  movaps C2, 0x10+C_OFFSET_32(C)
  movaps C3, 0x20+C_OFFSET_32(C)
  movaps C4, 0x30+C_OFFSET_32(C)

  .align 16
block_108:

  # Check norm of product A(3,8)*B(8,2).
  movss 0x74(multiply_stream, base_pointer), B1
  mulss 0x1fc(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_109

  # Reset C(3,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,2) = A(3,8)*B(8,2).
  movaps 0x0+B_OFFSET_82(B), B1
  movaps 0x10+B_OFFSET_82(B), B2
  movaps 0x20+B_OFFSET_82(B), B3
  movaps 0x30+B_OFFSET_82(B), B4
  movaps 0x0+A_OFFSET_38(A), A11
  movaps 0x10+A_OFFSET_38(A), A12
  movaps 0x20+A_OFFSET_38(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_38(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_38(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_38(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_38(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_38(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_38(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_38(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_38(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_38(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_38(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_38(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_38(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_38(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,2) to already existing.
  addps 0x0+C_OFFSET_32(C), C1
  addps 0x10+C_OFFSET_32(C), C2
  addps 0x20+C_OFFSET_32(C), C3
  addps 0x30+C_OFFSET_32(C), C4

  # Write out C(3,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_32(C)
  movaps C2, 0x10+C_OFFSET_32(C)
  movaps C3, 0x20+C_OFFSET_32(C)
  movaps C4, 0x30+C_OFFSET_32(C)

  .align 16
block_109:

  # Check norm of product A(4,7)*B(7,1).
  movss 0x90(multiply_stream, base_pointer), B1
  mulss 0x1d8(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_110

  # Reset C(4,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,1) = A(4,7)*B(7,1).
  movaps 0x0+B_OFFSET_71(B), B1
  movaps 0x10+B_OFFSET_71(B), B2
  movaps 0x20+B_OFFSET_71(B), B3
  movaps 0x30+B_OFFSET_71(B), B4
  movaps 0x0+A_OFFSET_47(A), A11
  movaps 0x10+A_OFFSET_47(A), A12
  movaps 0x20+A_OFFSET_47(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_47(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_47(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_47(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_47(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_47(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_47(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_47(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_47(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_47(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_47(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_47(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_47(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_47(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,1) to already existing.
  addps 0x0+C_OFFSET_41(C), C1
  addps 0x10+C_OFFSET_41(C), C2
  addps 0x20+C_OFFSET_41(C), C3
  addps 0x30+C_OFFSET_41(C), C4

  # Write out C(4,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_41(C)
  movaps C2, 0x10+C_OFFSET_41(C)
  movaps C3, 0x20+C_OFFSET_41(C)
  movaps C4, 0x30+C_OFFSET_41(C)

  .align 16
block_110:

  # Check norm of product A(4,8)*B(8,1).
  movss 0x94(multiply_stream, base_pointer), B1
  mulss 0x1f8(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_111

  # Reset C(4,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,1) = A(4,8)*B(8,1).
  movaps 0x0+B_OFFSET_81(B), B1
  movaps 0x10+B_OFFSET_81(B), B2
  movaps 0x20+B_OFFSET_81(B), B3
  movaps 0x30+B_OFFSET_81(B), B4
  movaps 0x0+A_OFFSET_48(A), A11
  movaps 0x10+A_OFFSET_48(A), A12
  movaps 0x20+A_OFFSET_48(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_48(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_48(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_48(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_48(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_48(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_48(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_48(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_48(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_48(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_48(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_48(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_48(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_48(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,1) to already existing.
  addps 0x0+C_OFFSET_41(C), C1
  addps 0x10+C_OFFSET_41(C), C2
  addps 0x20+C_OFFSET_41(C), C3
  addps 0x30+C_OFFSET_41(C), C4

  # Write out C(4,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_41(C)
  movaps C2, 0x10+C_OFFSET_41(C)
  movaps C3, 0x20+C_OFFSET_41(C)
  movaps C4, 0x30+C_OFFSET_41(C)

  .align 16
block_111:

  # Check norm of product A(4,7)*B(7,2).
  movss 0x90(multiply_stream, base_pointer), B1
  mulss 0x1dc(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_112

  # Reset C(4,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,2) = A(4,7)*B(7,2).
  movaps 0x0+B_OFFSET_72(B), B1
  movaps 0x10+B_OFFSET_72(B), B2
  movaps 0x20+B_OFFSET_72(B), B3
  movaps 0x30+B_OFFSET_72(B), B4
  movaps 0x0+A_OFFSET_47(A), A11
  movaps 0x10+A_OFFSET_47(A), A12
  movaps 0x20+A_OFFSET_47(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_47(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_47(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_47(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_47(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_47(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_47(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_47(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_47(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_47(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_47(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_47(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_47(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_47(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,2) to already existing.
  addps 0x0+C_OFFSET_42(C), C1
  addps 0x10+C_OFFSET_42(C), C2
  addps 0x20+C_OFFSET_42(C), C3
  addps 0x30+C_OFFSET_42(C), C4

  # Write out C(4,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_42(C)
  movaps C2, 0x10+C_OFFSET_42(C)
  movaps C3, 0x20+C_OFFSET_42(C)
  movaps C4, 0x30+C_OFFSET_42(C)

  .align 16
block_112:

  # Check norm of product A(4,8)*B(8,2).
  movss 0x94(multiply_stream, base_pointer), B1
  mulss 0x1fc(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_113

  # Reset C(4,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,2) = A(4,8)*B(8,2).
  movaps 0x0+B_OFFSET_82(B), B1
  movaps 0x10+B_OFFSET_82(B), B2
  movaps 0x20+B_OFFSET_82(B), B3
  movaps 0x30+B_OFFSET_82(B), B4
  movaps 0x0+A_OFFSET_48(A), A11
  movaps 0x10+A_OFFSET_48(A), A12
  movaps 0x20+A_OFFSET_48(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_48(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_48(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_48(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_48(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_48(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_48(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_48(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_48(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_48(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_48(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_48(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_48(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_48(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,2) to already existing.
  addps 0x0+C_OFFSET_42(C), C1
  addps 0x10+C_OFFSET_42(C), C2
  addps 0x20+C_OFFSET_42(C), C3
  addps 0x30+C_OFFSET_42(C), C4

  # Write out C(4,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_42(C)
  movaps C2, 0x10+C_OFFSET_42(C)
  movaps C3, 0x20+C_OFFSET_42(C)
  movaps C4, 0x30+C_OFFSET_42(C)

  .align 16
block_113:

  # Check norm of product A(3,5)*B(5,3).
  movss 0x68(multiply_stream, base_pointer), B1
  mulss 0x1a0(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_114

  # Reset C(3,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,3) = A(3,5)*B(5,3).
  movaps 0x0+B_OFFSET_53(B), B1
  movaps 0x10+B_OFFSET_53(B), B2
  movaps 0x20+B_OFFSET_53(B), B3
  movaps 0x30+B_OFFSET_53(B), B4
  movaps 0x0+A_OFFSET_35(A), A11
  movaps 0x10+A_OFFSET_35(A), A12
  movaps 0x20+A_OFFSET_35(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_35(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_35(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_35(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_35(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_35(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_35(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_35(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_35(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_35(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_35(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_35(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_35(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_35(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,3) to already existing.
  addps 0x0+C_OFFSET_33(C), C1
  addps 0x10+C_OFFSET_33(C), C2
  addps 0x20+C_OFFSET_33(C), C3
  addps 0x30+C_OFFSET_33(C), C4

  # Write out C(3,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_33(C)
  movaps C2, 0x10+C_OFFSET_33(C)
  movaps C3, 0x20+C_OFFSET_33(C)
  movaps C4, 0x30+C_OFFSET_33(C)

  .align 16
block_114:

  # Check norm of product A(3,6)*B(6,3).
  movss 0x6c(multiply_stream, base_pointer), B1
  mulss 0x1c0(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_115

  # Reset C(3,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,3) = A(3,6)*B(6,3).
  movaps 0x0+B_OFFSET_63(B), B1
  movaps 0x10+B_OFFSET_63(B), B2
  movaps 0x20+B_OFFSET_63(B), B3
  movaps 0x30+B_OFFSET_63(B), B4
  movaps 0x0+A_OFFSET_36(A), A11
  movaps 0x10+A_OFFSET_36(A), A12
  movaps 0x20+A_OFFSET_36(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_36(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_36(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_36(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_36(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_36(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_36(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_36(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_36(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_36(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_36(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_36(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_36(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_36(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,3) to already existing.
  addps 0x0+C_OFFSET_33(C), C1
  addps 0x10+C_OFFSET_33(C), C2
  addps 0x20+C_OFFSET_33(C), C3
  addps 0x30+C_OFFSET_33(C), C4

  # Write out C(3,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_33(C)
  movaps C2, 0x10+C_OFFSET_33(C)
  movaps C3, 0x20+C_OFFSET_33(C)
  movaps C4, 0x30+C_OFFSET_33(C)

  .align 16
block_115:

  # Check norm of product A(3,5)*B(5,4).
  movss 0x68(multiply_stream, base_pointer), B1
  mulss 0x1a4(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_116

  # Reset C(3,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,4) = A(3,5)*B(5,4).
  movaps 0x0+B_OFFSET_54(B), B1
  movaps 0x10+B_OFFSET_54(B), B2
  movaps 0x20+B_OFFSET_54(B), B3
  movaps 0x30+B_OFFSET_54(B), B4
  movaps 0x0+A_OFFSET_35(A), A11
  movaps 0x10+A_OFFSET_35(A), A12
  movaps 0x20+A_OFFSET_35(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_35(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_35(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_35(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_35(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_35(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_35(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_35(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_35(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_35(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_35(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_35(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_35(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_35(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,4) to already existing.
  addps 0x0+C_OFFSET_34(C), C1
  addps 0x10+C_OFFSET_34(C), C2
  addps 0x20+C_OFFSET_34(C), C3
  addps 0x30+C_OFFSET_34(C), C4

  # Write out C(3,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_34(C)
  movaps C2, 0x10+C_OFFSET_34(C)
  movaps C3, 0x20+C_OFFSET_34(C)
  movaps C4, 0x30+C_OFFSET_34(C)

  .align 16
block_116:

  # Check norm of product A(3,6)*B(6,4).
  movss 0x6c(multiply_stream, base_pointer), B1
  mulss 0x1c4(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_117

  # Reset C(3,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,4) = A(3,6)*B(6,4).
  movaps 0x0+B_OFFSET_64(B), B1
  movaps 0x10+B_OFFSET_64(B), B2
  movaps 0x20+B_OFFSET_64(B), B3
  movaps 0x30+B_OFFSET_64(B), B4
  movaps 0x0+A_OFFSET_36(A), A11
  movaps 0x10+A_OFFSET_36(A), A12
  movaps 0x20+A_OFFSET_36(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_36(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_36(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_36(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_36(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_36(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_36(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_36(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_36(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_36(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_36(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_36(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_36(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_36(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,4) to already existing.
  addps 0x0+C_OFFSET_34(C), C1
  addps 0x10+C_OFFSET_34(C), C2
  addps 0x20+C_OFFSET_34(C), C3
  addps 0x30+C_OFFSET_34(C), C4

  # Write out C(3,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_34(C)
  movaps C2, 0x10+C_OFFSET_34(C)
  movaps C3, 0x20+C_OFFSET_34(C)
  movaps C4, 0x30+C_OFFSET_34(C)

  .align 16
block_117:

  # Check norm of product A(4,5)*B(5,3).
  movss 0x88(multiply_stream, base_pointer), B1
  mulss 0x1a0(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_118

  # Reset C(4,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,3) = A(4,5)*B(5,3).
  movaps 0x0+B_OFFSET_53(B), B1
  movaps 0x10+B_OFFSET_53(B), B2
  movaps 0x20+B_OFFSET_53(B), B3
  movaps 0x30+B_OFFSET_53(B), B4
  movaps 0x0+A_OFFSET_45(A), A11
  movaps 0x10+A_OFFSET_45(A), A12
  movaps 0x20+A_OFFSET_45(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_45(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_45(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_45(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_45(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_45(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_45(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_45(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_45(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_45(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_45(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_45(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_45(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_45(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,3) to already existing.
  addps 0x0+C_OFFSET_43(C), C1
  addps 0x10+C_OFFSET_43(C), C2
  addps 0x20+C_OFFSET_43(C), C3
  addps 0x30+C_OFFSET_43(C), C4

  # Write out C(4,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_43(C)
  movaps C2, 0x10+C_OFFSET_43(C)
  movaps C3, 0x20+C_OFFSET_43(C)
  movaps C4, 0x30+C_OFFSET_43(C)

  .align 16
block_118:

  # Check norm of product A(4,6)*B(6,3).
  movss 0x8c(multiply_stream, base_pointer), B1
  mulss 0x1c0(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_119

  # Reset C(4,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,3) = A(4,6)*B(6,3).
  movaps 0x0+B_OFFSET_63(B), B1
  movaps 0x10+B_OFFSET_63(B), B2
  movaps 0x20+B_OFFSET_63(B), B3
  movaps 0x30+B_OFFSET_63(B), B4
  movaps 0x0+A_OFFSET_46(A), A11
  movaps 0x10+A_OFFSET_46(A), A12
  movaps 0x20+A_OFFSET_46(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_46(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_46(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_46(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_46(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_46(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_46(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_46(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_46(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_46(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_46(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_46(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_46(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_46(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,3) to already existing.
  addps 0x0+C_OFFSET_43(C), C1
  addps 0x10+C_OFFSET_43(C), C2
  addps 0x20+C_OFFSET_43(C), C3
  addps 0x30+C_OFFSET_43(C), C4

  # Write out C(4,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_43(C)
  movaps C2, 0x10+C_OFFSET_43(C)
  movaps C3, 0x20+C_OFFSET_43(C)
  movaps C4, 0x30+C_OFFSET_43(C)

  .align 16
block_119:

  # Check norm of product A(4,5)*B(5,4).
  movss 0x88(multiply_stream, base_pointer), B1
  mulss 0x1a4(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_120

  # Reset C(4,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,4) = A(4,5)*B(5,4).
  movaps 0x0+B_OFFSET_54(B), B1
  movaps 0x10+B_OFFSET_54(B), B2
  movaps 0x20+B_OFFSET_54(B), B3
  movaps 0x30+B_OFFSET_54(B), B4
  movaps 0x0+A_OFFSET_45(A), A11
  movaps 0x10+A_OFFSET_45(A), A12
  movaps 0x20+A_OFFSET_45(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_45(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_45(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_45(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_45(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_45(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_45(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_45(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_45(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_45(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_45(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_45(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_45(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_45(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,4) to already existing.
  addps 0x0+C_OFFSET_44(C), C1
  addps 0x10+C_OFFSET_44(C), C2
  addps 0x20+C_OFFSET_44(C), C3
  addps 0x30+C_OFFSET_44(C), C4

  # Write out C(4,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_44(C)
  movaps C2, 0x10+C_OFFSET_44(C)
  movaps C3, 0x20+C_OFFSET_44(C)
  movaps C4, 0x30+C_OFFSET_44(C)

  .align 16
block_120:

  # Check norm of product A(4,6)*B(6,4).
  movss 0x8c(multiply_stream, base_pointer), B1
  mulss 0x1c4(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_121

  # Reset C(4,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,4) = A(4,6)*B(6,4).
  movaps 0x0+B_OFFSET_64(B), B1
  movaps 0x10+B_OFFSET_64(B), B2
  movaps 0x20+B_OFFSET_64(B), B3
  movaps 0x30+B_OFFSET_64(B), B4
  movaps 0x0+A_OFFSET_46(A), A11
  movaps 0x10+A_OFFSET_46(A), A12
  movaps 0x20+A_OFFSET_46(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_46(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_46(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_46(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_46(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_46(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_46(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_46(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_46(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_46(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_46(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_46(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_46(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_46(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,4) to already existing.
  addps 0x0+C_OFFSET_44(C), C1
  addps 0x10+C_OFFSET_44(C), C2
  addps 0x20+C_OFFSET_44(C), C3
  addps 0x30+C_OFFSET_44(C), C4

  # Write out C(4,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_44(C)
  movaps C2, 0x10+C_OFFSET_44(C)
  movaps C3, 0x20+C_OFFSET_44(C)
  movaps C4, 0x30+C_OFFSET_44(C)

  .align 16
block_121:

  # Check norm of product A(3,7)*B(7,3).
  movss 0x70(multiply_stream, base_pointer), B1
  mulss 0x1e0(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_122

  # Reset C(3,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,3) = A(3,7)*B(7,3).
  movaps 0x0+B_OFFSET_73(B), B1
  movaps 0x10+B_OFFSET_73(B), B2
  movaps 0x20+B_OFFSET_73(B), B3
  movaps 0x30+B_OFFSET_73(B), B4
  movaps 0x0+A_OFFSET_37(A), A11
  movaps 0x10+A_OFFSET_37(A), A12
  movaps 0x20+A_OFFSET_37(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_37(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_37(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_37(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_37(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_37(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_37(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_37(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_37(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_37(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_37(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_37(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_37(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_37(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,3) to already existing.
  addps 0x0+C_OFFSET_33(C), C1
  addps 0x10+C_OFFSET_33(C), C2
  addps 0x20+C_OFFSET_33(C), C3
  addps 0x30+C_OFFSET_33(C), C4

  # Write out C(3,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_33(C)
  movaps C2, 0x10+C_OFFSET_33(C)
  movaps C3, 0x20+C_OFFSET_33(C)
  movaps C4, 0x30+C_OFFSET_33(C)

  .align 16
block_122:

  # Check norm of product A(3,8)*B(8,3).
  movss 0x74(multiply_stream, base_pointer), B1
  mulss 0x200(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_123

  # Reset C(3,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,3) = A(3,8)*B(8,3).
  movaps 0x0+B_OFFSET_83(B), B1
  movaps 0x10+B_OFFSET_83(B), B2
  movaps 0x20+B_OFFSET_83(B), B3
  movaps 0x30+B_OFFSET_83(B), B4
  movaps 0x0+A_OFFSET_38(A), A11
  movaps 0x10+A_OFFSET_38(A), A12
  movaps 0x20+A_OFFSET_38(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_38(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_38(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_38(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_38(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_38(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_38(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_38(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_38(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_38(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_38(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_38(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_38(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_38(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,3) to already existing.
  addps 0x0+C_OFFSET_33(C), C1
  addps 0x10+C_OFFSET_33(C), C2
  addps 0x20+C_OFFSET_33(C), C3
  addps 0x30+C_OFFSET_33(C), C4

  # Write out C(3,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_33(C)
  movaps C2, 0x10+C_OFFSET_33(C)
  movaps C3, 0x20+C_OFFSET_33(C)
  movaps C4, 0x30+C_OFFSET_33(C)

  .align 16
block_123:

  # Check norm of product A(3,7)*B(7,4).
  movss 0x70(multiply_stream, base_pointer), B1
  mulss 0x1e4(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_124

  # Reset C(3,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,4) = A(3,7)*B(7,4).
  movaps 0x0+B_OFFSET_74(B), B1
  movaps 0x10+B_OFFSET_74(B), B2
  movaps 0x20+B_OFFSET_74(B), B3
  movaps 0x30+B_OFFSET_74(B), B4
  movaps 0x0+A_OFFSET_37(A), A11
  movaps 0x10+A_OFFSET_37(A), A12
  movaps 0x20+A_OFFSET_37(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_37(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_37(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_37(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_37(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_37(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_37(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_37(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_37(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_37(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_37(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_37(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_37(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_37(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,4) to already existing.
  addps 0x0+C_OFFSET_34(C), C1
  addps 0x10+C_OFFSET_34(C), C2
  addps 0x20+C_OFFSET_34(C), C3
  addps 0x30+C_OFFSET_34(C), C4

  # Write out C(3,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_34(C)
  movaps C2, 0x10+C_OFFSET_34(C)
  movaps C3, 0x20+C_OFFSET_34(C)
  movaps C4, 0x30+C_OFFSET_34(C)

  .align 16
block_124:

  # Check norm of product A(3,8)*B(8,4).
  movss 0x74(multiply_stream, base_pointer), B1
  mulss 0x204(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_125

  # Reset C(3,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,4) = A(3,8)*B(8,4).
  movaps 0x0+B_OFFSET_84(B), B1
  movaps 0x10+B_OFFSET_84(B), B2
  movaps 0x20+B_OFFSET_84(B), B3
  movaps 0x30+B_OFFSET_84(B), B4
  movaps 0x0+A_OFFSET_38(A), A11
  movaps 0x10+A_OFFSET_38(A), A12
  movaps 0x20+A_OFFSET_38(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_38(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_38(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_38(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_38(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_38(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_38(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_38(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_38(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_38(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_38(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_38(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_38(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_38(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,4) to already existing.
  addps 0x0+C_OFFSET_34(C), C1
  addps 0x10+C_OFFSET_34(C), C2
  addps 0x20+C_OFFSET_34(C), C3
  addps 0x30+C_OFFSET_34(C), C4

  # Write out C(3,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_34(C)
  movaps C2, 0x10+C_OFFSET_34(C)
  movaps C3, 0x20+C_OFFSET_34(C)
  movaps C4, 0x30+C_OFFSET_34(C)

  .align 16
block_125:

  # Check norm of product A(4,7)*B(7,3).
  movss 0x90(multiply_stream, base_pointer), B1
  mulss 0x1e0(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_126

  # Reset C(4,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,3) = A(4,7)*B(7,3).
  movaps 0x0+B_OFFSET_73(B), B1
  movaps 0x10+B_OFFSET_73(B), B2
  movaps 0x20+B_OFFSET_73(B), B3
  movaps 0x30+B_OFFSET_73(B), B4
  movaps 0x0+A_OFFSET_47(A), A11
  movaps 0x10+A_OFFSET_47(A), A12
  movaps 0x20+A_OFFSET_47(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_47(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_47(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_47(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_47(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_47(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_47(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_47(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_47(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_47(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_47(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_47(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_47(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_47(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,3) to already existing.
  addps 0x0+C_OFFSET_43(C), C1
  addps 0x10+C_OFFSET_43(C), C2
  addps 0x20+C_OFFSET_43(C), C3
  addps 0x30+C_OFFSET_43(C), C4

  # Write out C(4,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_43(C)
  movaps C2, 0x10+C_OFFSET_43(C)
  movaps C3, 0x20+C_OFFSET_43(C)
  movaps C4, 0x30+C_OFFSET_43(C)

  .align 16
block_126:

  # Check norm of product A(4,8)*B(8,3).
  movss 0x94(multiply_stream, base_pointer), B1
  mulss 0x200(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_127

  # Reset C(4,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,3) = A(4,8)*B(8,3).
  movaps 0x0+B_OFFSET_83(B), B1
  movaps 0x10+B_OFFSET_83(B), B2
  movaps 0x20+B_OFFSET_83(B), B3
  movaps 0x30+B_OFFSET_83(B), B4
  movaps 0x0+A_OFFSET_48(A), A11
  movaps 0x10+A_OFFSET_48(A), A12
  movaps 0x20+A_OFFSET_48(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_48(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_48(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_48(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_48(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_48(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_48(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_48(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_48(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_48(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_48(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_48(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_48(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_48(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,3) to already existing.
  addps 0x0+C_OFFSET_43(C), C1
  addps 0x10+C_OFFSET_43(C), C2
  addps 0x20+C_OFFSET_43(C), C3
  addps 0x30+C_OFFSET_43(C), C4

  # Write out C(4,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_43(C)
  movaps C2, 0x10+C_OFFSET_43(C)
  movaps C3, 0x20+C_OFFSET_43(C)
  movaps C4, 0x30+C_OFFSET_43(C)

  .align 16
block_127:

  # Check norm of product A(4,7)*B(7,4).
  movss 0x90(multiply_stream, base_pointer), B1
  mulss 0x1e4(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_128

  # Reset C(4,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,4) = A(4,7)*B(7,4).
  movaps 0x0+B_OFFSET_74(B), B1
  movaps 0x10+B_OFFSET_74(B), B2
  movaps 0x20+B_OFFSET_74(B), B3
  movaps 0x30+B_OFFSET_74(B), B4
  movaps 0x0+A_OFFSET_47(A), A11
  movaps 0x10+A_OFFSET_47(A), A12
  movaps 0x20+A_OFFSET_47(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_47(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_47(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_47(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_47(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_47(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_47(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_47(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_47(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_47(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_47(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_47(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_47(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_47(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,4) to already existing.
  addps 0x0+C_OFFSET_44(C), C1
  addps 0x10+C_OFFSET_44(C), C2
  addps 0x20+C_OFFSET_44(C), C3
  addps 0x30+C_OFFSET_44(C), C4

  # Write out C(4,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_44(C)
  movaps C2, 0x10+C_OFFSET_44(C)
  movaps C3, 0x20+C_OFFSET_44(C)
  movaps C4, 0x30+C_OFFSET_44(C)

  .align 16
block_128:

  # Check norm of product A(4,8)*B(8,4).
  movss 0x94(multiply_stream, base_pointer), B1
  mulss 0x204(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_129

  # Reset C(4,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,4) = A(4,8)*B(8,4).
  movaps 0x0+B_OFFSET_84(B), B1
  movaps 0x10+B_OFFSET_84(B), B2
  movaps 0x20+B_OFFSET_84(B), B3
  movaps 0x30+B_OFFSET_84(B), B4
  movaps 0x0+A_OFFSET_48(A), A11
  movaps 0x10+A_OFFSET_48(A), A12
  movaps 0x20+A_OFFSET_48(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_48(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_48(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_48(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_48(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_48(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_48(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_48(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_48(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_48(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_48(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_48(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_48(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_48(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,4) to already existing.
  addps 0x0+C_OFFSET_44(C), C1
  addps 0x10+C_OFFSET_44(C), C2
  addps 0x20+C_OFFSET_44(C), C3
  addps 0x30+C_OFFSET_44(C), C4

  # Write out C(4,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_44(C)
  movaps C2, 0x10+C_OFFSET_44(C)
  movaps C3, 0x20+C_OFFSET_44(C)
  movaps C4, 0x30+C_OFFSET_44(C)

  .align 16
block_129:

  # Check norm of product A(1,1)*B(1,5).
  movss 0x18(multiply_stream, base_pointer), B1
  mulss 0x128(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_130

  # Reset C(1,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,5) = A(1,1)*B(1,5).
  movaps 0x0+B_OFFSET_15(B), B1
  movaps 0x10+B_OFFSET_15(B), B2
  movaps 0x20+B_OFFSET_15(B), B3
  movaps 0x30+B_OFFSET_15(B), B4
  movaps 0x0+A_OFFSET_11(A), A11
  movaps 0x10+A_OFFSET_11(A), A12
  movaps 0x20+A_OFFSET_11(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_11(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_11(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_11(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_11(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_11(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_11(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_11(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_11(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_11(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_11(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_11(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_11(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_11(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,5) to already existing.
  addps 0x0+C_OFFSET_15(C), C1
  addps 0x10+C_OFFSET_15(C), C2
  addps 0x20+C_OFFSET_15(C), C3
  addps 0x30+C_OFFSET_15(C), C4

  # Write out C(1,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_15(C)
  movaps C2, 0x10+C_OFFSET_15(C)
  movaps C3, 0x20+C_OFFSET_15(C)
  movaps C4, 0x30+C_OFFSET_15(C)

  .align 16
block_130:

  # Check norm of product A(1,2)*B(2,5).
  movss 0x1c(multiply_stream, base_pointer), B1
  mulss 0x148(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_131

  # Reset C(1,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,5) = A(1,2)*B(2,5).
  movaps 0x0+B_OFFSET_25(B), B1
  movaps 0x10+B_OFFSET_25(B), B2
  movaps 0x20+B_OFFSET_25(B), B3
  movaps 0x30+B_OFFSET_25(B), B4
  movaps 0x0+A_OFFSET_12(A), A11
  movaps 0x10+A_OFFSET_12(A), A12
  movaps 0x20+A_OFFSET_12(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_12(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_12(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_12(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_12(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_12(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_12(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_12(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_12(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_12(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_12(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_12(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_12(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_12(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,5) to already existing.
  addps 0x0+C_OFFSET_15(C), C1
  addps 0x10+C_OFFSET_15(C), C2
  addps 0x20+C_OFFSET_15(C), C3
  addps 0x30+C_OFFSET_15(C), C4

  # Write out C(1,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_15(C)
  movaps C2, 0x10+C_OFFSET_15(C)
  movaps C3, 0x20+C_OFFSET_15(C)
  movaps C4, 0x30+C_OFFSET_15(C)

  .align 16
block_131:

  # Check norm of product A(1,1)*B(1,6).
  movss 0x18(multiply_stream, base_pointer), B1
  mulss 0x12c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_132

  # Reset C(1,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,6) = A(1,1)*B(1,6).
  movaps 0x0+B_OFFSET_16(B), B1
  movaps 0x10+B_OFFSET_16(B), B2
  movaps 0x20+B_OFFSET_16(B), B3
  movaps 0x30+B_OFFSET_16(B), B4
  movaps 0x0+A_OFFSET_11(A), A11
  movaps 0x10+A_OFFSET_11(A), A12
  movaps 0x20+A_OFFSET_11(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_11(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_11(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_11(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_11(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_11(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_11(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_11(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_11(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_11(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_11(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_11(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_11(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_11(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,6) to already existing.
  addps 0x0+C_OFFSET_16(C), C1
  addps 0x10+C_OFFSET_16(C), C2
  addps 0x20+C_OFFSET_16(C), C3
  addps 0x30+C_OFFSET_16(C), C4

  # Write out C(1,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_16(C)
  movaps C2, 0x10+C_OFFSET_16(C)
  movaps C3, 0x20+C_OFFSET_16(C)
  movaps C4, 0x30+C_OFFSET_16(C)

  .align 16
block_132:

  # Check norm of product A(1,2)*B(2,6).
  movss 0x1c(multiply_stream, base_pointer), B1
  mulss 0x14c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_133

  # Reset C(1,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,6) = A(1,2)*B(2,6).
  movaps 0x0+B_OFFSET_26(B), B1
  movaps 0x10+B_OFFSET_26(B), B2
  movaps 0x20+B_OFFSET_26(B), B3
  movaps 0x30+B_OFFSET_26(B), B4
  movaps 0x0+A_OFFSET_12(A), A11
  movaps 0x10+A_OFFSET_12(A), A12
  movaps 0x20+A_OFFSET_12(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_12(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_12(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_12(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_12(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_12(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_12(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_12(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_12(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_12(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_12(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_12(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_12(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_12(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,6) to already existing.
  addps 0x0+C_OFFSET_16(C), C1
  addps 0x10+C_OFFSET_16(C), C2
  addps 0x20+C_OFFSET_16(C), C3
  addps 0x30+C_OFFSET_16(C), C4

  # Write out C(1,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_16(C)
  movaps C2, 0x10+C_OFFSET_16(C)
  movaps C3, 0x20+C_OFFSET_16(C)
  movaps C4, 0x30+C_OFFSET_16(C)

  .align 16
block_133:

  # Check norm of product A(2,1)*B(1,5).
  movss 0x38(multiply_stream, base_pointer), B1
  mulss 0x128(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_134

  # Reset C(2,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,5) = A(2,1)*B(1,5).
  movaps 0x0+B_OFFSET_15(B), B1
  movaps 0x10+B_OFFSET_15(B), B2
  movaps 0x20+B_OFFSET_15(B), B3
  movaps 0x30+B_OFFSET_15(B), B4
  movaps 0x0+A_OFFSET_21(A), A11
  movaps 0x10+A_OFFSET_21(A), A12
  movaps 0x20+A_OFFSET_21(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_21(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_21(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_21(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_21(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_21(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_21(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_21(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_21(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_21(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_21(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_21(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_21(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_21(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,5) to already existing.
  addps 0x0+C_OFFSET_25(C), C1
  addps 0x10+C_OFFSET_25(C), C2
  addps 0x20+C_OFFSET_25(C), C3
  addps 0x30+C_OFFSET_25(C), C4

  # Write out C(2,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_25(C)
  movaps C2, 0x10+C_OFFSET_25(C)
  movaps C3, 0x20+C_OFFSET_25(C)
  movaps C4, 0x30+C_OFFSET_25(C)

  .align 16
block_134:

  # Check norm of product A(2,2)*B(2,5).
  movss 0x3c(multiply_stream, base_pointer), B1
  mulss 0x148(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_135

  # Reset C(2,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,5) = A(2,2)*B(2,5).
  movaps 0x0+B_OFFSET_25(B), B1
  movaps 0x10+B_OFFSET_25(B), B2
  movaps 0x20+B_OFFSET_25(B), B3
  movaps 0x30+B_OFFSET_25(B), B4
  movaps 0x0+A_OFFSET_22(A), A11
  movaps 0x10+A_OFFSET_22(A), A12
  movaps 0x20+A_OFFSET_22(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_22(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_22(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_22(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_22(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_22(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_22(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_22(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_22(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_22(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_22(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_22(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_22(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_22(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,5) to already existing.
  addps 0x0+C_OFFSET_25(C), C1
  addps 0x10+C_OFFSET_25(C), C2
  addps 0x20+C_OFFSET_25(C), C3
  addps 0x30+C_OFFSET_25(C), C4

  # Write out C(2,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_25(C)
  movaps C2, 0x10+C_OFFSET_25(C)
  movaps C3, 0x20+C_OFFSET_25(C)
  movaps C4, 0x30+C_OFFSET_25(C)

  .align 16
block_135:

  # Check norm of product A(2,1)*B(1,6).
  movss 0x38(multiply_stream, base_pointer), B1
  mulss 0x12c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_136

  # Reset C(2,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,6) = A(2,1)*B(1,6).
  movaps 0x0+B_OFFSET_16(B), B1
  movaps 0x10+B_OFFSET_16(B), B2
  movaps 0x20+B_OFFSET_16(B), B3
  movaps 0x30+B_OFFSET_16(B), B4
  movaps 0x0+A_OFFSET_21(A), A11
  movaps 0x10+A_OFFSET_21(A), A12
  movaps 0x20+A_OFFSET_21(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_21(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_21(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_21(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_21(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_21(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_21(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_21(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_21(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_21(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_21(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_21(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_21(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_21(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,6) to already existing.
  addps 0x0+C_OFFSET_26(C), C1
  addps 0x10+C_OFFSET_26(C), C2
  addps 0x20+C_OFFSET_26(C), C3
  addps 0x30+C_OFFSET_26(C), C4

  # Write out C(2,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_26(C)
  movaps C2, 0x10+C_OFFSET_26(C)
  movaps C3, 0x20+C_OFFSET_26(C)
  movaps C4, 0x30+C_OFFSET_26(C)

  .align 16
block_136:

  # Check norm of product A(2,2)*B(2,6).
  movss 0x3c(multiply_stream, base_pointer), B1
  mulss 0x14c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_137

  # Reset C(2,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,6) = A(2,2)*B(2,6).
  movaps 0x0+B_OFFSET_26(B), B1
  movaps 0x10+B_OFFSET_26(B), B2
  movaps 0x20+B_OFFSET_26(B), B3
  movaps 0x30+B_OFFSET_26(B), B4
  movaps 0x0+A_OFFSET_22(A), A11
  movaps 0x10+A_OFFSET_22(A), A12
  movaps 0x20+A_OFFSET_22(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_22(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_22(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_22(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_22(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_22(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_22(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_22(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_22(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_22(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_22(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_22(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_22(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_22(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,6) to already existing.
  addps 0x0+C_OFFSET_26(C), C1
  addps 0x10+C_OFFSET_26(C), C2
  addps 0x20+C_OFFSET_26(C), C3
  addps 0x30+C_OFFSET_26(C), C4

  # Write out C(2,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_26(C)
  movaps C2, 0x10+C_OFFSET_26(C)
  movaps C3, 0x20+C_OFFSET_26(C)
  movaps C4, 0x30+C_OFFSET_26(C)

  .align 16
block_137:

  # Check norm of product A(1,3)*B(3,5).
  movss 0x20(multiply_stream, base_pointer), B1
  mulss 0x168(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_138

  # Reset C(1,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,5) = A(1,3)*B(3,5).
  movaps 0x0+B_OFFSET_35(B), B1
  movaps 0x10+B_OFFSET_35(B), B2
  movaps 0x20+B_OFFSET_35(B), B3
  movaps 0x30+B_OFFSET_35(B), B4
  movaps 0x0+A_OFFSET_13(A), A11
  movaps 0x10+A_OFFSET_13(A), A12
  movaps 0x20+A_OFFSET_13(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_13(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_13(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_13(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_13(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_13(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_13(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_13(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_13(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_13(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_13(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_13(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_13(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_13(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,5) to already existing.
  addps 0x0+C_OFFSET_15(C), C1
  addps 0x10+C_OFFSET_15(C), C2
  addps 0x20+C_OFFSET_15(C), C3
  addps 0x30+C_OFFSET_15(C), C4

  # Write out C(1,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_15(C)
  movaps C2, 0x10+C_OFFSET_15(C)
  movaps C3, 0x20+C_OFFSET_15(C)
  movaps C4, 0x30+C_OFFSET_15(C)

  .align 16
block_138:

  # Check norm of product A(1,4)*B(4,5).
  movss 0x24(multiply_stream, base_pointer), B1
  mulss 0x188(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_139

  # Reset C(1,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,5) = A(1,4)*B(4,5).
  movaps 0x0+B_OFFSET_45(B), B1
  movaps 0x10+B_OFFSET_45(B), B2
  movaps 0x20+B_OFFSET_45(B), B3
  movaps 0x30+B_OFFSET_45(B), B4
  movaps 0x0+A_OFFSET_14(A), A11
  movaps 0x10+A_OFFSET_14(A), A12
  movaps 0x20+A_OFFSET_14(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_14(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_14(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_14(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_14(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_14(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_14(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_14(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_14(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_14(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_14(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_14(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_14(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_14(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,5) to already existing.
  addps 0x0+C_OFFSET_15(C), C1
  addps 0x10+C_OFFSET_15(C), C2
  addps 0x20+C_OFFSET_15(C), C3
  addps 0x30+C_OFFSET_15(C), C4

  # Write out C(1,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_15(C)
  movaps C2, 0x10+C_OFFSET_15(C)
  movaps C3, 0x20+C_OFFSET_15(C)
  movaps C4, 0x30+C_OFFSET_15(C)

  .align 16
block_139:

  # Check norm of product A(1,3)*B(3,6).
  movss 0x20(multiply_stream, base_pointer), B1
  mulss 0x16c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_140

  # Reset C(1,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,6) = A(1,3)*B(3,6).
  movaps 0x0+B_OFFSET_36(B), B1
  movaps 0x10+B_OFFSET_36(B), B2
  movaps 0x20+B_OFFSET_36(B), B3
  movaps 0x30+B_OFFSET_36(B), B4
  movaps 0x0+A_OFFSET_13(A), A11
  movaps 0x10+A_OFFSET_13(A), A12
  movaps 0x20+A_OFFSET_13(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_13(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_13(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_13(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_13(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_13(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_13(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_13(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_13(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_13(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_13(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_13(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_13(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_13(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,6) to already existing.
  addps 0x0+C_OFFSET_16(C), C1
  addps 0x10+C_OFFSET_16(C), C2
  addps 0x20+C_OFFSET_16(C), C3
  addps 0x30+C_OFFSET_16(C), C4

  # Write out C(1,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_16(C)
  movaps C2, 0x10+C_OFFSET_16(C)
  movaps C3, 0x20+C_OFFSET_16(C)
  movaps C4, 0x30+C_OFFSET_16(C)

  .align 16
block_140:

  # Check norm of product A(1,4)*B(4,6).
  movss 0x24(multiply_stream, base_pointer), B1
  mulss 0x18c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_141

  # Reset C(1,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,6) = A(1,4)*B(4,6).
  movaps 0x0+B_OFFSET_46(B), B1
  movaps 0x10+B_OFFSET_46(B), B2
  movaps 0x20+B_OFFSET_46(B), B3
  movaps 0x30+B_OFFSET_46(B), B4
  movaps 0x0+A_OFFSET_14(A), A11
  movaps 0x10+A_OFFSET_14(A), A12
  movaps 0x20+A_OFFSET_14(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_14(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_14(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_14(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_14(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_14(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_14(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_14(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_14(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_14(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_14(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_14(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_14(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_14(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,6) to already existing.
  addps 0x0+C_OFFSET_16(C), C1
  addps 0x10+C_OFFSET_16(C), C2
  addps 0x20+C_OFFSET_16(C), C3
  addps 0x30+C_OFFSET_16(C), C4

  # Write out C(1,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_16(C)
  movaps C2, 0x10+C_OFFSET_16(C)
  movaps C3, 0x20+C_OFFSET_16(C)
  movaps C4, 0x30+C_OFFSET_16(C)

  .align 16
block_141:

  # Check norm of product A(2,3)*B(3,5).
  movss 0x40(multiply_stream, base_pointer), B1
  mulss 0x168(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_142

  # Reset C(2,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,5) = A(2,3)*B(3,5).
  movaps 0x0+B_OFFSET_35(B), B1
  movaps 0x10+B_OFFSET_35(B), B2
  movaps 0x20+B_OFFSET_35(B), B3
  movaps 0x30+B_OFFSET_35(B), B4
  movaps 0x0+A_OFFSET_23(A), A11
  movaps 0x10+A_OFFSET_23(A), A12
  movaps 0x20+A_OFFSET_23(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_23(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_23(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_23(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_23(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_23(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_23(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_23(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_23(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_23(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_23(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_23(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_23(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_23(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,5) to already existing.
  addps 0x0+C_OFFSET_25(C), C1
  addps 0x10+C_OFFSET_25(C), C2
  addps 0x20+C_OFFSET_25(C), C3
  addps 0x30+C_OFFSET_25(C), C4

  # Write out C(2,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_25(C)
  movaps C2, 0x10+C_OFFSET_25(C)
  movaps C3, 0x20+C_OFFSET_25(C)
  movaps C4, 0x30+C_OFFSET_25(C)

  .align 16
block_142:

  # Check norm of product A(2,4)*B(4,5).
  movss 0x44(multiply_stream, base_pointer), B1
  mulss 0x188(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_143

  # Reset C(2,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,5) = A(2,4)*B(4,5).
  movaps 0x0+B_OFFSET_45(B), B1
  movaps 0x10+B_OFFSET_45(B), B2
  movaps 0x20+B_OFFSET_45(B), B3
  movaps 0x30+B_OFFSET_45(B), B4
  movaps 0x0+A_OFFSET_24(A), A11
  movaps 0x10+A_OFFSET_24(A), A12
  movaps 0x20+A_OFFSET_24(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_24(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_24(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_24(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_24(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_24(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_24(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_24(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_24(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_24(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_24(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_24(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_24(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_24(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,5) to already existing.
  addps 0x0+C_OFFSET_25(C), C1
  addps 0x10+C_OFFSET_25(C), C2
  addps 0x20+C_OFFSET_25(C), C3
  addps 0x30+C_OFFSET_25(C), C4

  # Write out C(2,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_25(C)
  movaps C2, 0x10+C_OFFSET_25(C)
  movaps C3, 0x20+C_OFFSET_25(C)
  movaps C4, 0x30+C_OFFSET_25(C)

  .align 16
block_143:

  # Check norm of product A(2,3)*B(3,6).
  movss 0x40(multiply_stream, base_pointer), B1
  mulss 0x16c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_144

  # Reset C(2,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,6) = A(2,3)*B(3,6).
  movaps 0x0+B_OFFSET_36(B), B1
  movaps 0x10+B_OFFSET_36(B), B2
  movaps 0x20+B_OFFSET_36(B), B3
  movaps 0x30+B_OFFSET_36(B), B4
  movaps 0x0+A_OFFSET_23(A), A11
  movaps 0x10+A_OFFSET_23(A), A12
  movaps 0x20+A_OFFSET_23(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_23(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_23(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_23(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_23(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_23(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_23(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_23(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_23(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_23(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_23(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_23(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_23(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_23(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,6) to already existing.
  addps 0x0+C_OFFSET_26(C), C1
  addps 0x10+C_OFFSET_26(C), C2
  addps 0x20+C_OFFSET_26(C), C3
  addps 0x30+C_OFFSET_26(C), C4

  # Write out C(2,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_26(C)
  movaps C2, 0x10+C_OFFSET_26(C)
  movaps C3, 0x20+C_OFFSET_26(C)
  movaps C4, 0x30+C_OFFSET_26(C)

  .align 16
block_144:

  # Check norm of product A(2,4)*B(4,6).
  movss 0x44(multiply_stream, base_pointer), B1
  mulss 0x18c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_145

  # Reset C(2,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,6) = A(2,4)*B(4,6).
  movaps 0x0+B_OFFSET_46(B), B1
  movaps 0x10+B_OFFSET_46(B), B2
  movaps 0x20+B_OFFSET_46(B), B3
  movaps 0x30+B_OFFSET_46(B), B4
  movaps 0x0+A_OFFSET_24(A), A11
  movaps 0x10+A_OFFSET_24(A), A12
  movaps 0x20+A_OFFSET_24(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_24(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_24(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_24(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_24(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_24(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_24(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_24(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_24(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_24(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_24(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_24(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_24(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_24(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,6) to already existing.
  addps 0x0+C_OFFSET_26(C), C1
  addps 0x10+C_OFFSET_26(C), C2
  addps 0x20+C_OFFSET_26(C), C3
  addps 0x30+C_OFFSET_26(C), C4

  # Write out C(2,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_26(C)
  movaps C2, 0x10+C_OFFSET_26(C)
  movaps C3, 0x20+C_OFFSET_26(C)
  movaps C4, 0x30+C_OFFSET_26(C)

  .align 16
block_145:

  # Check norm of product A(1,1)*B(1,7).
  movss 0x18(multiply_stream, base_pointer), B1
  mulss 0x130(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_146

  # Reset C(1,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,7) = A(1,1)*B(1,7).
  movaps 0x0+B_OFFSET_17(B), B1
  movaps 0x10+B_OFFSET_17(B), B2
  movaps 0x20+B_OFFSET_17(B), B3
  movaps 0x30+B_OFFSET_17(B), B4
  movaps 0x0+A_OFFSET_11(A), A11
  movaps 0x10+A_OFFSET_11(A), A12
  movaps 0x20+A_OFFSET_11(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_11(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_11(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_11(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_11(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_11(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_11(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_11(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_11(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_11(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_11(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_11(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_11(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_11(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,7) to already existing.
  addps 0x0+C_OFFSET_17(C), C1
  addps 0x10+C_OFFSET_17(C), C2
  addps 0x20+C_OFFSET_17(C), C3
  addps 0x30+C_OFFSET_17(C), C4

  # Write out C(1,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_17(C)
  movaps C2, 0x10+C_OFFSET_17(C)
  movaps C3, 0x20+C_OFFSET_17(C)
  movaps C4, 0x30+C_OFFSET_17(C)

  .align 16
block_146:

  # Check norm of product A(1,2)*B(2,7).
  movss 0x1c(multiply_stream, base_pointer), B1
  mulss 0x150(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_147

  # Reset C(1,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,7) = A(1,2)*B(2,7).
  movaps 0x0+B_OFFSET_27(B), B1
  movaps 0x10+B_OFFSET_27(B), B2
  movaps 0x20+B_OFFSET_27(B), B3
  movaps 0x30+B_OFFSET_27(B), B4
  movaps 0x0+A_OFFSET_12(A), A11
  movaps 0x10+A_OFFSET_12(A), A12
  movaps 0x20+A_OFFSET_12(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_12(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_12(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_12(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_12(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_12(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_12(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_12(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_12(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_12(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_12(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_12(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_12(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_12(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,7) to already existing.
  addps 0x0+C_OFFSET_17(C), C1
  addps 0x10+C_OFFSET_17(C), C2
  addps 0x20+C_OFFSET_17(C), C3
  addps 0x30+C_OFFSET_17(C), C4

  # Write out C(1,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_17(C)
  movaps C2, 0x10+C_OFFSET_17(C)
  movaps C3, 0x20+C_OFFSET_17(C)
  movaps C4, 0x30+C_OFFSET_17(C)

  .align 16
block_147:

  # Check norm of product A(1,1)*B(1,8).
  movss 0x18(multiply_stream, base_pointer), B1
  mulss 0x134(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_148

  # Reset C(1,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,8) = A(1,1)*B(1,8).
  movaps 0x0+B_OFFSET_18(B), B1
  movaps 0x10+B_OFFSET_18(B), B2
  movaps 0x20+B_OFFSET_18(B), B3
  movaps 0x30+B_OFFSET_18(B), B4
  movaps 0x0+A_OFFSET_11(A), A11
  movaps 0x10+A_OFFSET_11(A), A12
  movaps 0x20+A_OFFSET_11(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_11(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_11(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_11(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_11(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_11(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_11(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_11(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_11(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_11(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_11(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_11(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_11(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_11(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,8) to already existing.
  addps 0x0+C_OFFSET_18(C), C1
  addps 0x10+C_OFFSET_18(C), C2
  addps 0x20+C_OFFSET_18(C), C3
  addps 0x30+C_OFFSET_18(C), C4

  # Write out C(1,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_18(C)
  movaps C2, 0x10+C_OFFSET_18(C)
  movaps C3, 0x20+C_OFFSET_18(C)
  movaps C4, 0x30+C_OFFSET_18(C)

  .align 16
block_148:

  # Check norm of product A(1,2)*B(2,8).
  movss 0x1c(multiply_stream, base_pointer), B1
  mulss 0x154(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_149

  # Reset C(1,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,8) = A(1,2)*B(2,8).
  movaps 0x0+B_OFFSET_28(B), B1
  movaps 0x10+B_OFFSET_28(B), B2
  movaps 0x20+B_OFFSET_28(B), B3
  movaps 0x30+B_OFFSET_28(B), B4
  movaps 0x0+A_OFFSET_12(A), A11
  movaps 0x10+A_OFFSET_12(A), A12
  movaps 0x20+A_OFFSET_12(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_12(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_12(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_12(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_12(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_12(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_12(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_12(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_12(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_12(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_12(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_12(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_12(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_12(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,8) to already existing.
  addps 0x0+C_OFFSET_18(C), C1
  addps 0x10+C_OFFSET_18(C), C2
  addps 0x20+C_OFFSET_18(C), C3
  addps 0x30+C_OFFSET_18(C), C4

  # Write out C(1,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_18(C)
  movaps C2, 0x10+C_OFFSET_18(C)
  movaps C3, 0x20+C_OFFSET_18(C)
  movaps C4, 0x30+C_OFFSET_18(C)

  .align 16
block_149:

  # Check norm of product A(2,1)*B(1,7).
  movss 0x38(multiply_stream, base_pointer), B1
  mulss 0x130(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_150

  # Reset C(2,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,7) = A(2,1)*B(1,7).
  movaps 0x0+B_OFFSET_17(B), B1
  movaps 0x10+B_OFFSET_17(B), B2
  movaps 0x20+B_OFFSET_17(B), B3
  movaps 0x30+B_OFFSET_17(B), B4
  movaps 0x0+A_OFFSET_21(A), A11
  movaps 0x10+A_OFFSET_21(A), A12
  movaps 0x20+A_OFFSET_21(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_21(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_21(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_21(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_21(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_21(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_21(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_21(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_21(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_21(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_21(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_21(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_21(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_21(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,7) to already existing.
  addps 0x0+C_OFFSET_27(C), C1
  addps 0x10+C_OFFSET_27(C), C2
  addps 0x20+C_OFFSET_27(C), C3
  addps 0x30+C_OFFSET_27(C), C4

  # Write out C(2,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_27(C)
  movaps C2, 0x10+C_OFFSET_27(C)
  movaps C3, 0x20+C_OFFSET_27(C)
  movaps C4, 0x30+C_OFFSET_27(C)

  .align 16
block_150:

  # Check norm of product A(2,2)*B(2,7).
  movss 0x3c(multiply_stream, base_pointer), B1
  mulss 0x150(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_151

  # Reset C(2,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,7) = A(2,2)*B(2,7).
  movaps 0x0+B_OFFSET_27(B), B1
  movaps 0x10+B_OFFSET_27(B), B2
  movaps 0x20+B_OFFSET_27(B), B3
  movaps 0x30+B_OFFSET_27(B), B4
  movaps 0x0+A_OFFSET_22(A), A11
  movaps 0x10+A_OFFSET_22(A), A12
  movaps 0x20+A_OFFSET_22(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_22(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_22(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_22(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_22(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_22(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_22(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_22(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_22(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_22(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_22(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_22(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_22(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_22(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,7) to already existing.
  addps 0x0+C_OFFSET_27(C), C1
  addps 0x10+C_OFFSET_27(C), C2
  addps 0x20+C_OFFSET_27(C), C3
  addps 0x30+C_OFFSET_27(C), C4

  # Write out C(2,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_27(C)
  movaps C2, 0x10+C_OFFSET_27(C)
  movaps C3, 0x20+C_OFFSET_27(C)
  movaps C4, 0x30+C_OFFSET_27(C)

  .align 16
block_151:

  # Check norm of product A(2,1)*B(1,8).
  movss 0x38(multiply_stream, base_pointer), B1
  mulss 0x134(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_152

  # Reset C(2,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,8) = A(2,1)*B(1,8).
  movaps 0x0+B_OFFSET_18(B), B1
  movaps 0x10+B_OFFSET_18(B), B2
  movaps 0x20+B_OFFSET_18(B), B3
  movaps 0x30+B_OFFSET_18(B), B4
  movaps 0x0+A_OFFSET_21(A), A11
  movaps 0x10+A_OFFSET_21(A), A12
  movaps 0x20+A_OFFSET_21(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_21(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_21(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_21(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_21(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_21(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_21(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_21(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_21(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_21(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_21(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_21(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_21(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_21(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,8) to already existing.
  addps 0x0+C_OFFSET_28(C), C1
  addps 0x10+C_OFFSET_28(C), C2
  addps 0x20+C_OFFSET_28(C), C3
  addps 0x30+C_OFFSET_28(C), C4

  # Write out C(2,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_28(C)
  movaps C2, 0x10+C_OFFSET_28(C)
  movaps C3, 0x20+C_OFFSET_28(C)
  movaps C4, 0x30+C_OFFSET_28(C)

  .align 16
block_152:

  # Check norm of product A(2,2)*B(2,8).
  movss 0x3c(multiply_stream, base_pointer), B1
  mulss 0x154(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_153

  # Reset C(2,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,8) = A(2,2)*B(2,8).
  movaps 0x0+B_OFFSET_28(B), B1
  movaps 0x10+B_OFFSET_28(B), B2
  movaps 0x20+B_OFFSET_28(B), B3
  movaps 0x30+B_OFFSET_28(B), B4
  movaps 0x0+A_OFFSET_22(A), A11
  movaps 0x10+A_OFFSET_22(A), A12
  movaps 0x20+A_OFFSET_22(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_22(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_22(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_22(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_22(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_22(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_22(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_22(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_22(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_22(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_22(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_22(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_22(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_22(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,8) to already existing.
  addps 0x0+C_OFFSET_28(C), C1
  addps 0x10+C_OFFSET_28(C), C2
  addps 0x20+C_OFFSET_28(C), C3
  addps 0x30+C_OFFSET_28(C), C4

  # Write out C(2,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_28(C)
  movaps C2, 0x10+C_OFFSET_28(C)
  movaps C3, 0x20+C_OFFSET_28(C)
  movaps C4, 0x30+C_OFFSET_28(C)

  .align 16
block_153:

  # Check norm of product A(1,3)*B(3,7).
  movss 0x20(multiply_stream, base_pointer), B1
  mulss 0x170(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_154

  # Reset C(1,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,7) = A(1,3)*B(3,7).
  movaps 0x0+B_OFFSET_37(B), B1
  movaps 0x10+B_OFFSET_37(B), B2
  movaps 0x20+B_OFFSET_37(B), B3
  movaps 0x30+B_OFFSET_37(B), B4
  movaps 0x0+A_OFFSET_13(A), A11
  movaps 0x10+A_OFFSET_13(A), A12
  movaps 0x20+A_OFFSET_13(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_13(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_13(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_13(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_13(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_13(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_13(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_13(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_13(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_13(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_13(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_13(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_13(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_13(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,7) to already existing.
  addps 0x0+C_OFFSET_17(C), C1
  addps 0x10+C_OFFSET_17(C), C2
  addps 0x20+C_OFFSET_17(C), C3
  addps 0x30+C_OFFSET_17(C), C4

  # Write out C(1,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_17(C)
  movaps C2, 0x10+C_OFFSET_17(C)
  movaps C3, 0x20+C_OFFSET_17(C)
  movaps C4, 0x30+C_OFFSET_17(C)

  .align 16
block_154:

  # Check norm of product A(1,4)*B(4,7).
  movss 0x24(multiply_stream, base_pointer), B1
  mulss 0x190(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_155

  # Reset C(1,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,7) = A(1,4)*B(4,7).
  movaps 0x0+B_OFFSET_47(B), B1
  movaps 0x10+B_OFFSET_47(B), B2
  movaps 0x20+B_OFFSET_47(B), B3
  movaps 0x30+B_OFFSET_47(B), B4
  movaps 0x0+A_OFFSET_14(A), A11
  movaps 0x10+A_OFFSET_14(A), A12
  movaps 0x20+A_OFFSET_14(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_14(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_14(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_14(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_14(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_14(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_14(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_14(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_14(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_14(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_14(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_14(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_14(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_14(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,7) to already existing.
  addps 0x0+C_OFFSET_17(C), C1
  addps 0x10+C_OFFSET_17(C), C2
  addps 0x20+C_OFFSET_17(C), C3
  addps 0x30+C_OFFSET_17(C), C4

  # Write out C(1,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_17(C)
  movaps C2, 0x10+C_OFFSET_17(C)
  movaps C3, 0x20+C_OFFSET_17(C)
  movaps C4, 0x30+C_OFFSET_17(C)

  .align 16
block_155:

  # Check norm of product A(1,3)*B(3,8).
  movss 0x20(multiply_stream, base_pointer), B1
  mulss 0x174(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_156

  # Reset C(1,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,8) = A(1,3)*B(3,8).
  movaps 0x0+B_OFFSET_38(B), B1
  movaps 0x10+B_OFFSET_38(B), B2
  movaps 0x20+B_OFFSET_38(B), B3
  movaps 0x30+B_OFFSET_38(B), B4
  movaps 0x0+A_OFFSET_13(A), A11
  movaps 0x10+A_OFFSET_13(A), A12
  movaps 0x20+A_OFFSET_13(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_13(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_13(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_13(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_13(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_13(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_13(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_13(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_13(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_13(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_13(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_13(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_13(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_13(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,8) to already existing.
  addps 0x0+C_OFFSET_18(C), C1
  addps 0x10+C_OFFSET_18(C), C2
  addps 0x20+C_OFFSET_18(C), C3
  addps 0x30+C_OFFSET_18(C), C4

  # Write out C(1,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_18(C)
  movaps C2, 0x10+C_OFFSET_18(C)
  movaps C3, 0x20+C_OFFSET_18(C)
  movaps C4, 0x30+C_OFFSET_18(C)

  .align 16
block_156:

  # Check norm of product A(1,4)*B(4,8).
  movss 0x24(multiply_stream, base_pointer), B1
  mulss 0x194(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_157

  # Reset C(1,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,8) = A(1,4)*B(4,8).
  movaps 0x0+B_OFFSET_48(B), B1
  movaps 0x10+B_OFFSET_48(B), B2
  movaps 0x20+B_OFFSET_48(B), B3
  movaps 0x30+B_OFFSET_48(B), B4
  movaps 0x0+A_OFFSET_14(A), A11
  movaps 0x10+A_OFFSET_14(A), A12
  movaps 0x20+A_OFFSET_14(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_14(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_14(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_14(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_14(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_14(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_14(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_14(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_14(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_14(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_14(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_14(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_14(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_14(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,8) to already existing.
  addps 0x0+C_OFFSET_18(C), C1
  addps 0x10+C_OFFSET_18(C), C2
  addps 0x20+C_OFFSET_18(C), C3
  addps 0x30+C_OFFSET_18(C), C4

  # Write out C(1,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_18(C)
  movaps C2, 0x10+C_OFFSET_18(C)
  movaps C3, 0x20+C_OFFSET_18(C)
  movaps C4, 0x30+C_OFFSET_18(C)

  .align 16
block_157:

  # Check norm of product A(2,3)*B(3,7).
  movss 0x40(multiply_stream, base_pointer), B1
  mulss 0x170(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_158

  # Reset C(2,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,7) = A(2,3)*B(3,7).
  movaps 0x0+B_OFFSET_37(B), B1
  movaps 0x10+B_OFFSET_37(B), B2
  movaps 0x20+B_OFFSET_37(B), B3
  movaps 0x30+B_OFFSET_37(B), B4
  movaps 0x0+A_OFFSET_23(A), A11
  movaps 0x10+A_OFFSET_23(A), A12
  movaps 0x20+A_OFFSET_23(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_23(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_23(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_23(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_23(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_23(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_23(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_23(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_23(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_23(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_23(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_23(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_23(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_23(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,7) to already existing.
  addps 0x0+C_OFFSET_27(C), C1
  addps 0x10+C_OFFSET_27(C), C2
  addps 0x20+C_OFFSET_27(C), C3
  addps 0x30+C_OFFSET_27(C), C4

  # Write out C(2,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_27(C)
  movaps C2, 0x10+C_OFFSET_27(C)
  movaps C3, 0x20+C_OFFSET_27(C)
  movaps C4, 0x30+C_OFFSET_27(C)

  .align 16
block_158:

  # Check norm of product A(2,4)*B(4,7).
  movss 0x44(multiply_stream, base_pointer), B1
  mulss 0x190(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_159

  # Reset C(2,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,7) = A(2,4)*B(4,7).
  movaps 0x0+B_OFFSET_47(B), B1
  movaps 0x10+B_OFFSET_47(B), B2
  movaps 0x20+B_OFFSET_47(B), B3
  movaps 0x30+B_OFFSET_47(B), B4
  movaps 0x0+A_OFFSET_24(A), A11
  movaps 0x10+A_OFFSET_24(A), A12
  movaps 0x20+A_OFFSET_24(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_24(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_24(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_24(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_24(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_24(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_24(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_24(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_24(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_24(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_24(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_24(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_24(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_24(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,7) to already existing.
  addps 0x0+C_OFFSET_27(C), C1
  addps 0x10+C_OFFSET_27(C), C2
  addps 0x20+C_OFFSET_27(C), C3
  addps 0x30+C_OFFSET_27(C), C4

  # Write out C(2,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_27(C)
  movaps C2, 0x10+C_OFFSET_27(C)
  movaps C3, 0x20+C_OFFSET_27(C)
  movaps C4, 0x30+C_OFFSET_27(C)

  .align 16
block_159:

  # Check norm of product A(2,3)*B(3,8).
  movss 0x40(multiply_stream, base_pointer), B1
  mulss 0x174(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_160

  # Reset C(2,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,8) = A(2,3)*B(3,8).
  movaps 0x0+B_OFFSET_38(B), B1
  movaps 0x10+B_OFFSET_38(B), B2
  movaps 0x20+B_OFFSET_38(B), B3
  movaps 0x30+B_OFFSET_38(B), B4
  movaps 0x0+A_OFFSET_23(A), A11
  movaps 0x10+A_OFFSET_23(A), A12
  movaps 0x20+A_OFFSET_23(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_23(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_23(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_23(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_23(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_23(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_23(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_23(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_23(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_23(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_23(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_23(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_23(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_23(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,8) to already existing.
  addps 0x0+C_OFFSET_28(C), C1
  addps 0x10+C_OFFSET_28(C), C2
  addps 0x20+C_OFFSET_28(C), C3
  addps 0x30+C_OFFSET_28(C), C4

  # Write out C(2,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_28(C)
  movaps C2, 0x10+C_OFFSET_28(C)
  movaps C3, 0x20+C_OFFSET_28(C)
  movaps C4, 0x30+C_OFFSET_28(C)

  .align 16
block_160:

  # Check norm of product A(2,4)*B(4,8).
  movss 0x44(multiply_stream, base_pointer), B1
  mulss 0x194(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_161

  # Reset C(2,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,8) = A(2,4)*B(4,8).
  movaps 0x0+B_OFFSET_48(B), B1
  movaps 0x10+B_OFFSET_48(B), B2
  movaps 0x20+B_OFFSET_48(B), B3
  movaps 0x30+B_OFFSET_48(B), B4
  movaps 0x0+A_OFFSET_24(A), A11
  movaps 0x10+A_OFFSET_24(A), A12
  movaps 0x20+A_OFFSET_24(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_24(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_24(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_24(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_24(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_24(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_24(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_24(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_24(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_24(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_24(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_24(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_24(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_24(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,8) to already existing.
  addps 0x0+C_OFFSET_28(C), C1
  addps 0x10+C_OFFSET_28(C), C2
  addps 0x20+C_OFFSET_28(C), C3
  addps 0x30+C_OFFSET_28(C), C4

  # Write out C(2,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_28(C)
  movaps C2, 0x10+C_OFFSET_28(C)
  movaps C3, 0x20+C_OFFSET_28(C)
  movaps C4, 0x30+C_OFFSET_28(C)

  .align 16
block_161:

  # Check norm of product A(3,1)*B(1,5).
  movss 0x58(multiply_stream, base_pointer), B1
  mulss 0x128(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_162

  # Reset C(3,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,5) = A(3,1)*B(1,5).
  movaps 0x0+B_OFFSET_15(B), B1
  movaps 0x10+B_OFFSET_15(B), B2
  movaps 0x20+B_OFFSET_15(B), B3
  movaps 0x30+B_OFFSET_15(B), B4
  movaps 0x0+A_OFFSET_31(A), A11
  movaps 0x10+A_OFFSET_31(A), A12
  movaps 0x20+A_OFFSET_31(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_31(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_31(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_31(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_31(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_31(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_31(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_31(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_31(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_31(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_31(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_31(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_31(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_31(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,5) to already existing.
  addps 0x0+C_OFFSET_35(C), C1
  addps 0x10+C_OFFSET_35(C), C2
  addps 0x20+C_OFFSET_35(C), C3
  addps 0x30+C_OFFSET_35(C), C4

  # Write out C(3,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_35(C)
  movaps C2, 0x10+C_OFFSET_35(C)
  movaps C3, 0x20+C_OFFSET_35(C)
  movaps C4, 0x30+C_OFFSET_35(C)

  .align 16
block_162:

  # Check norm of product A(3,2)*B(2,5).
  movss 0x5c(multiply_stream, base_pointer), B1
  mulss 0x148(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_163

  # Reset C(3,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,5) = A(3,2)*B(2,5).
  movaps 0x0+B_OFFSET_25(B), B1
  movaps 0x10+B_OFFSET_25(B), B2
  movaps 0x20+B_OFFSET_25(B), B3
  movaps 0x30+B_OFFSET_25(B), B4
  movaps 0x0+A_OFFSET_32(A), A11
  movaps 0x10+A_OFFSET_32(A), A12
  movaps 0x20+A_OFFSET_32(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_32(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_32(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_32(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_32(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_32(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_32(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_32(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_32(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_32(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_32(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_32(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_32(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_32(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,5) to already existing.
  addps 0x0+C_OFFSET_35(C), C1
  addps 0x10+C_OFFSET_35(C), C2
  addps 0x20+C_OFFSET_35(C), C3
  addps 0x30+C_OFFSET_35(C), C4

  # Write out C(3,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_35(C)
  movaps C2, 0x10+C_OFFSET_35(C)
  movaps C3, 0x20+C_OFFSET_35(C)
  movaps C4, 0x30+C_OFFSET_35(C)

  .align 16
block_163:

  # Check norm of product A(3,1)*B(1,6).
  movss 0x58(multiply_stream, base_pointer), B1
  mulss 0x12c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_164

  # Reset C(3,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,6) = A(3,1)*B(1,6).
  movaps 0x0+B_OFFSET_16(B), B1
  movaps 0x10+B_OFFSET_16(B), B2
  movaps 0x20+B_OFFSET_16(B), B3
  movaps 0x30+B_OFFSET_16(B), B4
  movaps 0x0+A_OFFSET_31(A), A11
  movaps 0x10+A_OFFSET_31(A), A12
  movaps 0x20+A_OFFSET_31(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_31(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_31(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_31(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_31(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_31(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_31(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_31(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_31(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_31(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_31(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_31(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_31(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_31(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,6) to already existing.
  addps 0x0+C_OFFSET_36(C), C1
  addps 0x10+C_OFFSET_36(C), C2
  addps 0x20+C_OFFSET_36(C), C3
  addps 0x30+C_OFFSET_36(C), C4

  # Write out C(3,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_36(C)
  movaps C2, 0x10+C_OFFSET_36(C)
  movaps C3, 0x20+C_OFFSET_36(C)
  movaps C4, 0x30+C_OFFSET_36(C)

  .align 16
block_164:

  # Check norm of product A(3,2)*B(2,6).
  movss 0x5c(multiply_stream, base_pointer), B1
  mulss 0x14c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_165

  # Reset C(3,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,6) = A(3,2)*B(2,6).
  movaps 0x0+B_OFFSET_26(B), B1
  movaps 0x10+B_OFFSET_26(B), B2
  movaps 0x20+B_OFFSET_26(B), B3
  movaps 0x30+B_OFFSET_26(B), B4
  movaps 0x0+A_OFFSET_32(A), A11
  movaps 0x10+A_OFFSET_32(A), A12
  movaps 0x20+A_OFFSET_32(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_32(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_32(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_32(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_32(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_32(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_32(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_32(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_32(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_32(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_32(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_32(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_32(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_32(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,6) to already existing.
  addps 0x0+C_OFFSET_36(C), C1
  addps 0x10+C_OFFSET_36(C), C2
  addps 0x20+C_OFFSET_36(C), C3
  addps 0x30+C_OFFSET_36(C), C4

  # Write out C(3,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_36(C)
  movaps C2, 0x10+C_OFFSET_36(C)
  movaps C3, 0x20+C_OFFSET_36(C)
  movaps C4, 0x30+C_OFFSET_36(C)

  .align 16
block_165:

  # Check norm of product A(4,1)*B(1,5).
  movss 0x78(multiply_stream, base_pointer), B1
  mulss 0x128(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_166

  # Reset C(4,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,5) = A(4,1)*B(1,5).
  movaps 0x0+B_OFFSET_15(B), B1
  movaps 0x10+B_OFFSET_15(B), B2
  movaps 0x20+B_OFFSET_15(B), B3
  movaps 0x30+B_OFFSET_15(B), B4
  movaps 0x0+A_OFFSET_41(A), A11
  movaps 0x10+A_OFFSET_41(A), A12
  movaps 0x20+A_OFFSET_41(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_41(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_41(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_41(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_41(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_41(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_41(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_41(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_41(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_41(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_41(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_41(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_41(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_41(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,5) to already existing.
  addps 0x0+C_OFFSET_45(C), C1
  addps 0x10+C_OFFSET_45(C), C2
  addps 0x20+C_OFFSET_45(C), C3
  addps 0x30+C_OFFSET_45(C), C4

  # Write out C(4,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_45(C)
  movaps C2, 0x10+C_OFFSET_45(C)
  movaps C3, 0x20+C_OFFSET_45(C)
  movaps C4, 0x30+C_OFFSET_45(C)

  .align 16
block_166:

  # Check norm of product A(4,2)*B(2,5).
  movss 0x7c(multiply_stream, base_pointer), B1
  mulss 0x148(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_167

  # Reset C(4,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,5) = A(4,2)*B(2,5).
  movaps 0x0+B_OFFSET_25(B), B1
  movaps 0x10+B_OFFSET_25(B), B2
  movaps 0x20+B_OFFSET_25(B), B3
  movaps 0x30+B_OFFSET_25(B), B4
  movaps 0x0+A_OFFSET_42(A), A11
  movaps 0x10+A_OFFSET_42(A), A12
  movaps 0x20+A_OFFSET_42(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_42(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_42(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_42(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_42(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_42(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_42(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_42(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_42(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_42(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_42(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_42(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_42(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_42(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,5) to already existing.
  addps 0x0+C_OFFSET_45(C), C1
  addps 0x10+C_OFFSET_45(C), C2
  addps 0x20+C_OFFSET_45(C), C3
  addps 0x30+C_OFFSET_45(C), C4

  # Write out C(4,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_45(C)
  movaps C2, 0x10+C_OFFSET_45(C)
  movaps C3, 0x20+C_OFFSET_45(C)
  movaps C4, 0x30+C_OFFSET_45(C)

  .align 16
block_167:

  # Check norm of product A(4,1)*B(1,6).
  movss 0x78(multiply_stream, base_pointer), B1
  mulss 0x12c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_168

  # Reset C(4,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,6) = A(4,1)*B(1,6).
  movaps 0x0+B_OFFSET_16(B), B1
  movaps 0x10+B_OFFSET_16(B), B2
  movaps 0x20+B_OFFSET_16(B), B3
  movaps 0x30+B_OFFSET_16(B), B4
  movaps 0x0+A_OFFSET_41(A), A11
  movaps 0x10+A_OFFSET_41(A), A12
  movaps 0x20+A_OFFSET_41(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_41(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_41(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_41(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_41(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_41(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_41(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_41(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_41(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_41(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_41(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_41(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_41(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_41(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,6) to already existing.
  addps 0x0+C_OFFSET_46(C), C1
  addps 0x10+C_OFFSET_46(C), C2
  addps 0x20+C_OFFSET_46(C), C3
  addps 0x30+C_OFFSET_46(C), C4

  # Write out C(4,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_46(C)
  movaps C2, 0x10+C_OFFSET_46(C)
  movaps C3, 0x20+C_OFFSET_46(C)
  movaps C4, 0x30+C_OFFSET_46(C)

  .align 16
block_168:

  # Check norm of product A(4,2)*B(2,6).
  movss 0x7c(multiply_stream, base_pointer), B1
  mulss 0x14c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_169

  # Reset C(4,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,6) = A(4,2)*B(2,6).
  movaps 0x0+B_OFFSET_26(B), B1
  movaps 0x10+B_OFFSET_26(B), B2
  movaps 0x20+B_OFFSET_26(B), B3
  movaps 0x30+B_OFFSET_26(B), B4
  movaps 0x0+A_OFFSET_42(A), A11
  movaps 0x10+A_OFFSET_42(A), A12
  movaps 0x20+A_OFFSET_42(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_42(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_42(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_42(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_42(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_42(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_42(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_42(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_42(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_42(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_42(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_42(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_42(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_42(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,6) to already existing.
  addps 0x0+C_OFFSET_46(C), C1
  addps 0x10+C_OFFSET_46(C), C2
  addps 0x20+C_OFFSET_46(C), C3
  addps 0x30+C_OFFSET_46(C), C4

  # Write out C(4,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_46(C)
  movaps C2, 0x10+C_OFFSET_46(C)
  movaps C3, 0x20+C_OFFSET_46(C)
  movaps C4, 0x30+C_OFFSET_46(C)

  .align 16
block_169:

  # Check norm of product A(3,3)*B(3,5).
  movss 0x60(multiply_stream, base_pointer), B1
  mulss 0x168(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_170

  # Reset C(3,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,5) = A(3,3)*B(3,5).
  movaps 0x0+B_OFFSET_35(B), B1
  movaps 0x10+B_OFFSET_35(B), B2
  movaps 0x20+B_OFFSET_35(B), B3
  movaps 0x30+B_OFFSET_35(B), B4
  movaps 0x0+A_OFFSET_33(A), A11
  movaps 0x10+A_OFFSET_33(A), A12
  movaps 0x20+A_OFFSET_33(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_33(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_33(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_33(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_33(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_33(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_33(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_33(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_33(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_33(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_33(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_33(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_33(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_33(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,5) to already existing.
  addps 0x0+C_OFFSET_35(C), C1
  addps 0x10+C_OFFSET_35(C), C2
  addps 0x20+C_OFFSET_35(C), C3
  addps 0x30+C_OFFSET_35(C), C4

  # Write out C(3,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_35(C)
  movaps C2, 0x10+C_OFFSET_35(C)
  movaps C3, 0x20+C_OFFSET_35(C)
  movaps C4, 0x30+C_OFFSET_35(C)

  .align 16
block_170:

  # Check norm of product A(3,4)*B(4,5).
  movss 0x64(multiply_stream, base_pointer), B1
  mulss 0x188(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_171

  # Reset C(3,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,5) = A(3,4)*B(4,5).
  movaps 0x0+B_OFFSET_45(B), B1
  movaps 0x10+B_OFFSET_45(B), B2
  movaps 0x20+B_OFFSET_45(B), B3
  movaps 0x30+B_OFFSET_45(B), B4
  movaps 0x0+A_OFFSET_34(A), A11
  movaps 0x10+A_OFFSET_34(A), A12
  movaps 0x20+A_OFFSET_34(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_34(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_34(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_34(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_34(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_34(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_34(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_34(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_34(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_34(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_34(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_34(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_34(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_34(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,5) to already existing.
  addps 0x0+C_OFFSET_35(C), C1
  addps 0x10+C_OFFSET_35(C), C2
  addps 0x20+C_OFFSET_35(C), C3
  addps 0x30+C_OFFSET_35(C), C4

  # Write out C(3,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_35(C)
  movaps C2, 0x10+C_OFFSET_35(C)
  movaps C3, 0x20+C_OFFSET_35(C)
  movaps C4, 0x30+C_OFFSET_35(C)

  .align 16
block_171:

  # Check norm of product A(3,3)*B(3,6).
  movss 0x60(multiply_stream, base_pointer), B1
  mulss 0x16c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_172

  # Reset C(3,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,6) = A(3,3)*B(3,6).
  movaps 0x0+B_OFFSET_36(B), B1
  movaps 0x10+B_OFFSET_36(B), B2
  movaps 0x20+B_OFFSET_36(B), B3
  movaps 0x30+B_OFFSET_36(B), B4
  movaps 0x0+A_OFFSET_33(A), A11
  movaps 0x10+A_OFFSET_33(A), A12
  movaps 0x20+A_OFFSET_33(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_33(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_33(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_33(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_33(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_33(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_33(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_33(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_33(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_33(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_33(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_33(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_33(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_33(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,6) to already existing.
  addps 0x0+C_OFFSET_36(C), C1
  addps 0x10+C_OFFSET_36(C), C2
  addps 0x20+C_OFFSET_36(C), C3
  addps 0x30+C_OFFSET_36(C), C4

  # Write out C(3,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_36(C)
  movaps C2, 0x10+C_OFFSET_36(C)
  movaps C3, 0x20+C_OFFSET_36(C)
  movaps C4, 0x30+C_OFFSET_36(C)

  .align 16
block_172:

  # Check norm of product A(3,4)*B(4,6).
  movss 0x64(multiply_stream, base_pointer), B1
  mulss 0x18c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_173

  # Reset C(3,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,6) = A(3,4)*B(4,6).
  movaps 0x0+B_OFFSET_46(B), B1
  movaps 0x10+B_OFFSET_46(B), B2
  movaps 0x20+B_OFFSET_46(B), B3
  movaps 0x30+B_OFFSET_46(B), B4
  movaps 0x0+A_OFFSET_34(A), A11
  movaps 0x10+A_OFFSET_34(A), A12
  movaps 0x20+A_OFFSET_34(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_34(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_34(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_34(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_34(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_34(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_34(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_34(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_34(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_34(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_34(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_34(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_34(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_34(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,6) to already existing.
  addps 0x0+C_OFFSET_36(C), C1
  addps 0x10+C_OFFSET_36(C), C2
  addps 0x20+C_OFFSET_36(C), C3
  addps 0x30+C_OFFSET_36(C), C4

  # Write out C(3,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_36(C)
  movaps C2, 0x10+C_OFFSET_36(C)
  movaps C3, 0x20+C_OFFSET_36(C)
  movaps C4, 0x30+C_OFFSET_36(C)

  .align 16
block_173:

  # Check norm of product A(4,3)*B(3,5).
  movss 0x80(multiply_stream, base_pointer), B1
  mulss 0x168(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_174

  # Reset C(4,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,5) = A(4,3)*B(3,5).
  movaps 0x0+B_OFFSET_35(B), B1
  movaps 0x10+B_OFFSET_35(B), B2
  movaps 0x20+B_OFFSET_35(B), B3
  movaps 0x30+B_OFFSET_35(B), B4
  movaps 0x0+A_OFFSET_43(A), A11
  movaps 0x10+A_OFFSET_43(A), A12
  movaps 0x20+A_OFFSET_43(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_43(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_43(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_43(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_43(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_43(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_43(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_43(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_43(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_43(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_43(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_43(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_43(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_43(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,5) to already existing.
  addps 0x0+C_OFFSET_45(C), C1
  addps 0x10+C_OFFSET_45(C), C2
  addps 0x20+C_OFFSET_45(C), C3
  addps 0x30+C_OFFSET_45(C), C4

  # Write out C(4,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_45(C)
  movaps C2, 0x10+C_OFFSET_45(C)
  movaps C3, 0x20+C_OFFSET_45(C)
  movaps C4, 0x30+C_OFFSET_45(C)

  .align 16
block_174:

  # Check norm of product A(4,4)*B(4,5).
  movss 0x84(multiply_stream, base_pointer), B1
  mulss 0x188(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_175

  # Reset C(4,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,5) = A(4,4)*B(4,5).
  movaps 0x0+B_OFFSET_45(B), B1
  movaps 0x10+B_OFFSET_45(B), B2
  movaps 0x20+B_OFFSET_45(B), B3
  movaps 0x30+B_OFFSET_45(B), B4
  movaps 0x0+A_OFFSET_44(A), A11
  movaps 0x10+A_OFFSET_44(A), A12
  movaps 0x20+A_OFFSET_44(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_44(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_44(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_44(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_44(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_44(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_44(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_44(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_44(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_44(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_44(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_44(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_44(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_44(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,5) to already existing.
  addps 0x0+C_OFFSET_45(C), C1
  addps 0x10+C_OFFSET_45(C), C2
  addps 0x20+C_OFFSET_45(C), C3
  addps 0x30+C_OFFSET_45(C), C4

  # Write out C(4,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_45(C)
  movaps C2, 0x10+C_OFFSET_45(C)
  movaps C3, 0x20+C_OFFSET_45(C)
  movaps C4, 0x30+C_OFFSET_45(C)

  .align 16
block_175:

  # Check norm of product A(4,3)*B(3,6).
  movss 0x80(multiply_stream, base_pointer), B1
  mulss 0x16c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_176

  # Reset C(4,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,6) = A(4,3)*B(3,6).
  movaps 0x0+B_OFFSET_36(B), B1
  movaps 0x10+B_OFFSET_36(B), B2
  movaps 0x20+B_OFFSET_36(B), B3
  movaps 0x30+B_OFFSET_36(B), B4
  movaps 0x0+A_OFFSET_43(A), A11
  movaps 0x10+A_OFFSET_43(A), A12
  movaps 0x20+A_OFFSET_43(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_43(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_43(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_43(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_43(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_43(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_43(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_43(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_43(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_43(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_43(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_43(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_43(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_43(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,6) to already existing.
  addps 0x0+C_OFFSET_46(C), C1
  addps 0x10+C_OFFSET_46(C), C2
  addps 0x20+C_OFFSET_46(C), C3
  addps 0x30+C_OFFSET_46(C), C4

  # Write out C(4,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_46(C)
  movaps C2, 0x10+C_OFFSET_46(C)
  movaps C3, 0x20+C_OFFSET_46(C)
  movaps C4, 0x30+C_OFFSET_46(C)

  .align 16
block_176:

  # Check norm of product A(4,4)*B(4,6).
  movss 0x84(multiply_stream, base_pointer), B1
  mulss 0x18c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_177

  # Reset C(4,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,6) = A(4,4)*B(4,6).
  movaps 0x0+B_OFFSET_46(B), B1
  movaps 0x10+B_OFFSET_46(B), B2
  movaps 0x20+B_OFFSET_46(B), B3
  movaps 0x30+B_OFFSET_46(B), B4
  movaps 0x0+A_OFFSET_44(A), A11
  movaps 0x10+A_OFFSET_44(A), A12
  movaps 0x20+A_OFFSET_44(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_44(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_44(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_44(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_44(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_44(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_44(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_44(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_44(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_44(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_44(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_44(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_44(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_44(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,6) to already existing.
  addps 0x0+C_OFFSET_46(C), C1
  addps 0x10+C_OFFSET_46(C), C2
  addps 0x20+C_OFFSET_46(C), C3
  addps 0x30+C_OFFSET_46(C), C4

  # Write out C(4,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_46(C)
  movaps C2, 0x10+C_OFFSET_46(C)
  movaps C3, 0x20+C_OFFSET_46(C)
  movaps C4, 0x30+C_OFFSET_46(C)

  .align 16
block_177:

  # Check norm of product A(3,1)*B(1,7).
  movss 0x58(multiply_stream, base_pointer), B1
  mulss 0x130(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_178

  # Reset C(3,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,7) = A(3,1)*B(1,7).
  movaps 0x0+B_OFFSET_17(B), B1
  movaps 0x10+B_OFFSET_17(B), B2
  movaps 0x20+B_OFFSET_17(B), B3
  movaps 0x30+B_OFFSET_17(B), B4
  movaps 0x0+A_OFFSET_31(A), A11
  movaps 0x10+A_OFFSET_31(A), A12
  movaps 0x20+A_OFFSET_31(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_31(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_31(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_31(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_31(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_31(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_31(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_31(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_31(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_31(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_31(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_31(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_31(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_31(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,7) to already existing.
  addps 0x0+C_OFFSET_37(C), C1
  addps 0x10+C_OFFSET_37(C), C2
  addps 0x20+C_OFFSET_37(C), C3
  addps 0x30+C_OFFSET_37(C), C4

  # Write out C(3,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_37(C)
  movaps C2, 0x10+C_OFFSET_37(C)
  movaps C3, 0x20+C_OFFSET_37(C)
  movaps C4, 0x30+C_OFFSET_37(C)

  .align 16
block_178:

  # Check norm of product A(3,2)*B(2,7).
  movss 0x5c(multiply_stream, base_pointer), B1
  mulss 0x150(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_179

  # Reset C(3,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,7) = A(3,2)*B(2,7).
  movaps 0x0+B_OFFSET_27(B), B1
  movaps 0x10+B_OFFSET_27(B), B2
  movaps 0x20+B_OFFSET_27(B), B3
  movaps 0x30+B_OFFSET_27(B), B4
  movaps 0x0+A_OFFSET_32(A), A11
  movaps 0x10+A_OFFSET_32(A), A12
  movaps 0x20+A_OFFSET_32(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_32(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_32(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_32(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_32(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_32(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_32(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_32(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_32(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_32(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_32(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_32(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_32(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_32(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,7) to already existing.
  addps 0x0+C_OFFSET_37(C), C1
  addps 0x10+C_OFFSET_37(C), C2
  addps 0x20+C_OFFSET_37(C), C3
  addps 0x30+C_OFFSET_37(C), C4

  # Write out C(3,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_37(C)
  movaps C2, 0x10+C_OFFSET_37(C)
  movaps C3, 0x20+C_OFFSET_37(C)
  movaps C4, 0x30+C_OFFSET_37(C)

  .align 16
block_179:

  # Check norm of product A(3,1)*B(1,8).
  movss 0x58(multiply_stream, base_pointer), B1
  mulss 0x134(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_180

  # Reset C(3,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,8) = A(3,1)*B(1,8).
  movaps 0x0+B_OFFSET_18(B), B1
  movaps 0x10+B_OFFSET_18(B), B2
  movaps 0x20+B_OFFSET_18(B), B3
  movaps 0x30+B_OFFSET_18(B), B4
  movaps 0x0+A_OFFSET_31(A), A11
  movaps 0x10+A_OFFSET_31(A), A12
  movaps 0x20+A_OFFSET_31(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_31(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_31(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_31(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_31(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_31(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_31(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_31(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_31(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_31(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_31(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_31(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_31(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_31(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,8) to already existing.
  addps 0x0+C_OFFSET_38(C), C1
  addps 0x10+C_OFFSET_38(C), C2
  addps 0x20+C_OFFSET_38(C), C3
  addps 0x30+C_OFFSET_38(C), C4

  # Write out C(3,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_38(C)
  movaps C2, 0x10+C_OFFSET_38(C)
  movaps C3, 0x20+C_OFFSET_38(C)
  movaps C4, 0x30+C_OFFSET_38(C)

  .align 16
block_180:

  # Check norm of product A(3,2)*B(2,8).
  movss 0x5c(multiply_stream, base_pointer), B1
  mulss 0x154(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_181

  # Reset C(3,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,8) = A(3,2)*B(2,8).
  movaps 0x0+B_OFFSET_28(B), B1
  movaps 0x10+B_OFFSET_28(B), B2
  movaps 0x20+B_OFFSET_28(B), B3
  movaps 0x30+B_OFFSET_28(B), B4
  movaps 0x0+A_OFFSET_32(A), A11
  movaps 0x10+A_OFFSET_32(A), A12
  movaps 0x20+A_OFFSET_32(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_32(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_32(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_32(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_32(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_32(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_32(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_32(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_32(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_32(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_32(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_32(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_32(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_32(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,8) to already existing.
  addps 0x0+C_OFFSET_38(C), C1
  addps 0x10+C_OFFSET_38(C), C2
  addps 0x20+C_OFFSET_38(C), C3
  addps 0x30+C_OFFSET_38(C), C4

  # Write out C(3,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_38(C)
  movaps C2, 0x10+C_OFFSET_38(C)
  movaps C3, 0x20+C_OFFSET_38(C)
  movaps C4, 0x30+C_OFFSET_38(C)

  .align 16
block_181:

  # Check norm of product A(4,1)*B(1,7).
  movss 0x78(multiply_stream, base_pointer), B1
  mulss 0x130(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_182

  # Reset C(4,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,7) = A(4,1)*B(1,7).
  movaps 0x0+B_OFFSET_17(B), B1
  movaps 0x10+B_OFFSET_17(B), B2
  movaps 0x20+B_OFFSET_17(B), B3
  movaps 0x30+B_OFFSET_17(B), B4
  movaps 0x0+A_OFFSET_41(A), A11
  movaps 0x10+A_OFFSET_41(A), A12
  movaps 0x20+A_OFFSET_41(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_41(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_41(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_41(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_41(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_41(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_41(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_41(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_41(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_41(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_41(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_41(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_41(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_41(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,7) to already existing.
  addps 0x0+C_OFFSET_47(C), C1
  addps 0x10+C_OFFSET_47(C), C2
  addps 0x20+C_OFFSET_47(C), C3
  addps 0x30+C_OFFSET_47(C), C4

  # Write out C(4,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_47(C)
  movaps C2, 0x10+C_OFFSET_47(C)
  movaps C3, 0x20+C_OFFSET_47(C)
  movaps C4, 0x30+C_OFFSET_47(C)

  .align 16
block_182:

  # Check norm of product A(4,2)*B(2,7).
  movss 0x7c(multiply_stream, base_pointer), B1
  mulss 0x150(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_183

  # Reset C(4,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,7) = A(4,2)*B(2,7).
  movaps 0x0+B_OFFSET_27(B), B1
  movaps 0x10+B_OFFSET_27(B), B2
  movaps 0x20+B_OFFSET_27(B), B3
  movaps 0x30+B_OFFSET_27(B), B4
  movaps 0x0+A_OFFSET_42(A), A11
  movaps 0x10+A_OFFSET_42(A), A12
  movaps 0x20+A_OFFSET_42(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_42(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_42(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_42(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_42(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_42(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_42(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_42(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_42(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_42(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_42(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_42(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_42(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_42(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,7) to already existing.
  addps 0x0+C_OFFSET_47(C), C1
  addps 0x10+C_OFFSET_47(C), C2
  addps 0x20+C_OFFSET_47(C), C3
  addps 0x30+C_OFFSET_47(C), C4

  # Write out C(4,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_47(C)
  movaps C2, 0x10+C_OFFSET_47(C)
  movaps C3, 0x20+C_OFFSET_47(C)
  movaps C4, 0x30+C_OFFSET_47(C)

  .align 16
block_183:

  # Check norm of product A(4,1)*B(1,8).
  movss 0x78(multiply_stream, base_pointer), B1
  mulss 0x134(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_184

  # Reset C(4,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,8) = A(4,1)*B(1,8).
  movaps 0x0+B_OFFSET_18(B), B1
  movaps 0x10+B_OFFSET_18(B), B2
  movaps 0x20+B_OFFSET_18(B), B3
  movaps 0x30+B_OFFSET_18(B), B4
  movaps 0x0+A_OFFSET_41(A), A11
  movaps 0x10+A_OFFSET_41(A), A12
  movaps 0x20+A_OFFSET_41(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_41(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_41(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_41(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_41(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_41(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_41(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_41(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_41(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_41(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_41(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_41(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_41(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_41(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,8) to already existing.
  addps 0x0+C_OFFSET_48(C), C1
  addps 0x10+C_OFFSET_48(C), C2
  addps 0x20+C_OFFSET_48(C), C3
  addps 0x30+C_OFFSET_48(C), C4

  # Write out C(4,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_48(C)
  movaps C2, 0x10+C_OFFSET_48(C)
  movaps C3, 0x20+C_OFFSET_48(C)
  movaps C4, 0x30+C_OFFSET_48(C)

  .align 16
block_184:

  # Check norm of product A(4,2)*B(2,8).
  movss 0x7c(multiply_stream, base_pointer), B1
  mulss 0x154(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_185

  # Reset C(4,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,8) = A(4,2)*B(2,8).
  movaps 0x0+B_OFFSET_28(B), B1
  movaps 0x10+B_OFFSET_28(B), B2
  movaps 0x20+B_OFFSET_28(B), B3
  movaps 0x30+B_OFFSET_28(B), B4
  movaps 0x0+A_OFFSET_42(A), A11
  movaps 0x10+A_OFFSET_42(A), A12
  movaps 0x20+A_OFFSET_42(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_42(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_42(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_42(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_42(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_42(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_42(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_42(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_42(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_42(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_42(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_42(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_42(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_42(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,8) to already existing.
  addps 0x0+C_OFFSET_48(C), C1
  addps 0x10+C_OFFSET_48(C), C2
  addps 0x20+C_OFFSET_48(C), C3
  addps 0x30+C_OFFSET_48(C), C4

  # Write out C(4,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_48(C)
  movaps C2, 0x10+C_OFFSET_48(C)
  movaps C3, 0x20+C_OFFSET_48(C)
  movaps C4, 0x30+C_OFFSET_48(C)

  .align 16
block_185:

  # Check norm of product A(3,3)*B(3,7).
  movss 0x60(multiply_stream, base_pointer), B1
  mulss 0x170(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_186

  # Reset C(3,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,7) = A(3,3)*B(3,7).
  movaps 0x0+B_OFFSET_37(B), B1
  movaps 0x10+B_OFFSET_37(B), B2
  movaps 0x20+B_OFFSET_37(B), B3
  movaps 0x30+B_OFFSET_37(B), B4
  movaps 0x0+A_OFFSET_33(A), A11
  movaps 0x10+A_OFFSET_33(A), A12
  movaps 0x20+A_OFFSET_33(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_33(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_33(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_33(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_33(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_33(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_33(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_33(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_33(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_33(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_33(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_33(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_33(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_33(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,7) to already existing.
  addps 0x0+C_OFFSET_37(C), C1
  addps 0x10+C_OFFSET_37(C), C2
  addps 0x20+C_OFFSET_37(C), C3
  addps 0x30+C_OFFSET_37(C), C4

  # Write out C(3,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_37(C)
  movaps C2, 0x10+C_OFFSET_37(C)
  movaps C3, 0x20+C_OFFSET_37(C)
  movaps C4, 0x30+C_OFFSET_37(C)

  .align 16
block_186:

  # Check norm of product A(3,4)*B(4,7).
  movss 0x64(multiply_stream, base_pointer), B1
  mulss 0x190(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_187

  # Reset C(3,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,7) = A(3,4)*B(4,7).
  movaps 0x0+B_OFFSET_47(B), B1
  movaps 0x10+B_OFFSET_47(B), B2
  movaps 0x20+B_OFFSET_47(B), B3
  movaps 0x30+B_OFFSET_47(B), B4
  movaps 0x0+A_OFFSET_34(A), A11
  movaps 0x10+A_OFFSET_34(A), A12
  movaps 0x20+A_OFFSET_34(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_34(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_34(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_34(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_34(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_34(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_34(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_34(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_34(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_34(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_34(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_34(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_34(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_34(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,7) to already existing.
  addps 0x0+C_OFFSET_37(C), C1
  addps 0x10+C_OFFSET_37(C), C2
  addps 0x20+C_OFFSET_37(C), C3
  addps 0x30+C_OFFSET_37(C), C4

  # Write out C(3,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_37(C)
  movaps C2, 0x10+C_OFFSET_37(C)
  movaps C3, 0x20+C_OFFSET_37(C)
  movaps C4, 0x30+C_OFFSET_37(C)

  .align 16
block_187:

  # Check norm of product A(3,3)*B(3,8).
  movss 0x60(multiply_stream, base_pointer), B1
  mulss 0x174(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_188

  # Reset C(3,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,8) = A(3,3)*B(3,8).
  movaps 0x0+B_OFFSET_38(B), B1
  movaps 0x10+B_OFFSET_38(B), B2
  movaps 0x20+B_OFFSET_38(B), B3
  movaps 0x30+B_OFFSET_38(B), B4
  movaps 0x0+A_OFFSET_33(A), A11
  movaps 0x10+A_OFFSET_33(A), A12
  movaps 0x20+A_OFFSET_33(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_33(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_33(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_33(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_33(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_33(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_33(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_33(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_33(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_33(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_33(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_33(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_33(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_33(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,8) to already existing.
  addps 0x0+C_OFFSET_38(C), C1
  addps 0x10+C_OFFSET_38(C), C2
  addps 0x20+C_OFFSET_38(C), C3
  addps 0x30+C_OFFSET_38(C), C4

  # Write out C(3,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_38(C)
  movaps C2, 0x10+C_OFFSET_38(C)
  movaps C3, 0x20+C_OFFSET_38(C)
  movaps C4, 0x30+C_OFFSET_38(C)

  .align 16
block_188:

  # Check norm of product A(3,4)*B(4,8).
  movss 0x64(multiply_stream, base_pointer), B1
  mulss 0x194(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_189

  # Reset C(3,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,8) = A(3,4)*B(4,8).
  movaps 0x0+B_OFFSET_48(B), B1
  movaps 0x10+B_OFFSET_48(B), B2
  movaps 0x20+B_OFFSET_48(B), B3
  movaps 0x30+B_OFFSET_48(B), B4
  movaps 0x0+A_OFFSET_34(A), A11
  movaps 0x10+A_OFFSET_34(A), A12
  movaps 0x20+A_OFFSET_34(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_34(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_34(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_34(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_34(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_34(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_34(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_34(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_34(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_34(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_34(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_34(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_34(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_34(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,8) to already existing.
  addps 0x0+C_OFFSET_38(C), C1
  addps 0x10+C_OFFSET_38(C), C2
  addps 0x20+C_OFFSET_38(C), C3
  addps 0x30+C_OFFSET_38(C), C4

  # Write out C(3,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_38(C)
  movaps C2, 0x10+C_OFFSET_38(C)
  movaps C3, 0x20+C_OFFSET_38(C)
  movaps C4, 0x30+C_OFFSET_38(C)

  .align 16
block_189:

  # Check norm of product A(4,3)*B(3,7).
  movss 0x80(multiply_stream, base_pointer), B1
  mulss 0x170(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_190

  # Reset C(4,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,7) = A(4,3)*B(3,7).
  movaps 0x0+B_OFFSET_37(B), B1
  movaps 0x10+B_OFFSET_37(B), B2
  movaps 0x20+B_OFFSET_37(B), B3
  movaps 0x30+B_OFFSET_37(B), B4
  movaps 0x0+A_OFFSET_43(A), A11
  movaps 0x10+A_OFFSET_43(A), A12
  movaps 0x20+A_OFFSET_43(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_43(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_43(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_43(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_43(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_43(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_43(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_43(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_43(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_43(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_43(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_43(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_43(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_43(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,7) to already existing.
  addps 0x0+C_OFFSET_47(C), C1
  addps 0x10+C_OFFSET_47(C), C2
  addps 0x20+C_OFFSET_47(C), C3
  addps 0x30+C_OFFSET_47(C), C4

  # Write out C(4,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_47(C)
  movaps C2, 0x10+C_OFFSET_47(C)
  movaps C3, 0x20+C_OFFSET_47(C)
  movaps C4, 0x30+C_OFFSET_47(C)

  .align 16
block_190:

  # Check norm of product A(4,4)*B(4,7).
  movss 0x84(multiply_stream, base_pointer), B1
  mulss 0x190(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_191

  # Reset C(4,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,7) = A(4,4)*B(4,7).
  movaps 0x0+B_OFFSET_47(B), B1
  movaps 0x10+B_OFFSET_47(B), B2
  movaps 0x20+B_OFFSET_47(B), B3
  movaps 0x30+B_OFFSET_47(B), B4
  movaps 0x0+A_OFFSET_44(A), A11
  movaps 0x10+A_OFFSET_44(A), A12
  movaps 0x20+A_OFFSET_44(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_44(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_44(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_44(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_44(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_44(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_44(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_44(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_44(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_44(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_44(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_44(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_44(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_44(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,7) to already existing.
  addps 0x0+C_OFFSET_47(C), C1
  addps 0x10+C_OFFSET_47(C), C2
  addps 0x20+C_OFFSET_47(C), C3
  addps 0x30+C_OFFSET_47(C), C4

  # Write out C(4,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_47(C)
  movaps C2, 0x10+C_OFFSET_47(C)
  movaps C3, 0x20+C_OFFSET_47(C)
  movaps C4, 0x30+C_OFFSET_47(C)

  .align 16
block_191:

  # Check norm of product A(4,3)*B(3,8).
  movss 0x80(multiply_stream, base_pointer), B1
  mulss 0x174(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_192

  # Reset C(4,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,8) = A(4,3)*B(3,8).
  movaps 0x0+B_OFFSET_38(B), B1
  movaps 0x10+B_OFFSET_38(B), B2
  movaps 0x20+B_OFFSET_38(B), B3
  movaps 0x30+B_OFFSET_38(B), B4
  movaps 0x0+A_OFFSET_43(A), A11
  movaps 0x10+A_OFFSET_43(A), A12
  movaps 0x20+A_OFFSET_43(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_43(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_43(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_43(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_43(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_43(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_43(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_43(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_43(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_43(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_43(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_43(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_43(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_43(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,8) to already existing.
  addps 0x0+C_OFFSET_48(C), C1
  addps 0x10+C_OFFSET_48(C), C2
  addps 0x20+C_OFFSET_48(C), C3
  addps 0x30+C_OFFSET_48(C), C4

  # Write out C(4,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_48(C)
  movaps C2, 0x10+C_OFFSET_48(C)
  movaps C3, 0x20+C_OFFSET_48(C)
  movaps C4, 0x30+C_OFFSET_48(C)

  .align 16
block_192:

  # Check norm of product A(4,4)*B(4,8).
  movss 0x84(multiply_stream, base_pointer), B1
  mulss 0x194(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_193

  # Reset C(4,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,8) = A(4,4)*B(4,8).
  movaps 0x0+B_OFFSET_48(B), B1
  movaps 0x10+B_OFFSET_48(B), B2
  movaps 0x20+B_OFFSET_48(B), B3
  movaps 0x30+B_OFFSET_48(B), B4
  movaps 0x0+A_OFFSET_44(A), A11
  movaps 0x10+A_OFFSET_44(A), A12
  movaps 0x20+A_OFFSET_44(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_44(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_44(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_44(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_44(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_44(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_44(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_44(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_44(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_44(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_44(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_44(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_44(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_44(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,8) to already existing.
  addps 0x0+C_OFFSET_48(C), C1
  addps 0x10+C_OFFSET_48(C), C2
  addps 0x20+C_OFFSET_48(C), C3
  addps 0x30+C_OFFSET_48(C), C4

  # Write out C(4,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_48(C)
  movaps C2, 0x10+C_OFFSET_48(C)
  movaps C3, 0x20+C_OFFSET_48(C)
  movaps C4, 0x30+C_OFFSET_48(C)

  .align 16
block_193:

  # Check norm of product A(1,5)*B(5,5).
  movss 0x28(multiply_stream, base_pointer), B1
  mulss 0x1a8(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_194

  # Reset C(1,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,5) = A(1,5)*B(5,5).
  movaps 0x0+B_OFFSET_55(B), B1
  movaps 0x10+B_OFFSET_55(B), B2
  movaps 0x20+B_OFFSET_55(B), B3
  movaps 0x30+B_OFFSET_55(B), B4
  movaps 0x0+A_OFFSET_15(A), A11
  movaps 0x10+A_OFFSET_15(A), A12
  movaps 0x20+A_OFFSET_15(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_15(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_15(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_15(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_15(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_15(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_15(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_15(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_15(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_15(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_15(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_15(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_15(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_15(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,5) to already existing.
  addps 0x0+C_OFFSET_15(C), C1
  addps 0x10+C_OFFSET_15(C), C2
  addps 0x20+C_OFFSET_15(C), C3
  addps 0x30+C_OFFSET_15(C), C4

  # Write out C(1,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_15(C)
  movaps C2, 0x10+C_OFFSET_15(C)
  movaps C3, 0x20+C_OFFSET_15(C)
  movaps C4, 0x30+C_OFFSET_15(C)

  .align 16
block_194:

  # Check norm of product A(1,6)*B(6,5).
  movss 0x2c(multiply_stream, base_pointer), B1
  mulss 0x1c8(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_195

  # Reset C(1,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,5) = A(1,6)*B(6,5).
  movaps 0x0+B_OFFSET_65(B), B1
  movaps 0x10+B_OFFSET_65(B), B2
  movaps 0x20+B_OFFSET_65(B), B3
  movaps 0x30+B_OFFSET_65(B), B4
  movaps 0x0+A_OFFSET_16(A), A11
  movaps 0x10+A_OFFSET_16(A), A12
  movaps 0x20+A_OFFSET_16(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_16(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_16(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_16(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_16(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_16(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_16(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_16(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_16(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_16(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_16(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_16(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_16(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_16(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,5) to already existing.
  addps 0x0+C_OFFSET_15(C), C1
  addps 0x10+C_OFFSET_15(C), C2
  addps 0x20+C_OFFSET_15(C), C3
  addps 0x30+C_OFFSET_15(C), C4

  # Write out C(1,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_15(C)
  movaps C2, 0x10+C_OFFSET_15(C)
  movaps C3, 0x20+C_OFFSET_15(C)
  movaps C4, 0x30+C_OFFSET_15(C)

  .align 16
block_195:

  # Check norm of product A(1,5)*B(5,6).
  movss 0x28(multiply_stream, base_pointer), B1
  mulss 0x1ac(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_196

  # Reset C(1,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,6) = A(1,5)*B(5,6).
  movaps 0x0+B_OFFSET_56(B), B1
  movaps 0x10+B_OFFSET_56(B), B2
  movaps 0x20+B_OFFSET_56(B), B3
  movaps 0x30+B_OFFSET_56(B), B4
  movaps 0x0+A_OFFSET_15(A), A11
  movaps 0x10+A_OFFSET_15(A), A12
  movaps 0x20+A_OFFSET_15(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_15(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_15(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_15(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_15(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_15(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_15(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_15(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_15(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_15(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_15(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_15(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_15(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_15(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,6) to already existing.
  addps 0x0+C_OFFSET_16(C), C1
  addps 0x10+C_OFFSET_16(C), C2
  addps 0x20+C_OFFSET_16(C), C3
  addps 0x30+C_OFFSET_16(C), C4

  # Write out C(1,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_16(C)
  movaps C2, 0x10+C_OFFSET_16(C)
  movaps C3, 0x20+C_OFFSET_16(C)
  movaps C4, 0x30+C_OFFSET_16(C)

  .align 16
block_196:

  # Check norm of product A(1,6)*B(6,6).
  movss 0x2c(multiply_stream, base_pointer), B1
  mulss 0x1cc(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_197

  # Reset C(1,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,6) = A(1,6)*B(6,6).
  movaps 0x0+B_OFFSET_66(B), B1
  movaps 0x10+B_OFFSET_66(B), B2
  movaps 0x20+B_OFFSET_66(B), B3
  movaps 0x30+B_OFFSET_66(B), B4
  movaps 0x0+A_OFFSET_16(A), A11
  movaps 0x10+A_OFFSET_16(A), A12
  movaps 0x20+A_OFFSET_16(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_16(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_16(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_16(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_16(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_16(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_16(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_16(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_16(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_16(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_16(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_16(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_16(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_16(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,6) to already existing.
  addps 0x0+C_OFFSET_16(C), C1
  addps 0x10+C_OFFSET_16(C), C2
  addps 0x20+C_OFFSET_16(C), C3
  addps 0x30+C_OFFSET_16(C), C4

  # Write out C(1,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_16(C)
  movaps C2, 0x10+C_OFFSET_16(C)
  movaps C3, 0x20+C_OFFSET_16(C)
  movaps C4, 0x30+C_OFFSET_16(C)

  .align 16
block_197:

  # Check norm of product A(2,5)*B(5,5).
  movss 0x48(multiply_stream, base_pointer), B1
  mulss 0x1a8(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_198

  # Reset C(2,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,5) = A(2,5)*B(5,5).
  movaps 0x0+B_OFFSET_55(B), B1
  movaps 0x10+B_OFFSET_55(B), B2
  movaps 0x20+B_OFFSET_55(B), B3
  movaps 0x30+B_OFFSET_55(B), B4
  movaps 0x0+A_OFFSET_25(A), A11
  movaps 0x10+A_OFFSET_25(A), A12
  movaps 0x20+A_OFFSET_25(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_25(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_25(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_25(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_25(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_25(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_25(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_25(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_25(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_25(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_25(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_25(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_25(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_25(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,5) to already existing.
  addps 0x0+C_OFFSET_25(C), C1
  addps 0x10+C_OFFSET_25(C), C2
  addps 0x20+C_OFFSET_25(C), C3
  addps 0x30+C_OFFSET_25(C), C4

  # Write out C(2,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_25(C)
  movaps C2, 0x10+C_OFFSET_25(C)
  movaps C3, 0x20+C_OFFSET_25(C)
  movaps C4, 0x30+C_OFFSET_25(C)

  .align 16
block_198:

  # Check norm of product A(2,6)*B(6,5).
  movss 0x4c(multiply_stream, base_pointer), B1
  mulss 0x1c8(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_199

  # Reset C(2,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,5) = A(2,6)*B(6,5).
  movaps 0x0+B_OFFSET_65(B), B1
  movaps 0x10+B_OFFSET_65(B), B2
  movaps 0x20+B_OFFSET_65(B), B3
  movaps 0x30+B_OFFSET_65(B), B4
  movaps 0x0+A_OFFSET_26(A), A11
  movaps 0x10+A_OFFSET_26(A), A12
  movaps 0x20+A_OFFSET_26(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_26(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_26(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_26(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_26(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_26(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_26(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_26(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_26(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_26(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_26(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_26(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_26(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_26(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,5) to already existing.
  addps 0x0+C_OFFSET_25(C), C1
  addps 0x10+C_OFFSET_25(C), C2
  addps 0x20+C_OFFSET_25(C), C3
  addps 0x30+C_OFFSET_25(C), C4

  # Write out C(2,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_25(C)
  movaps C2, 0x10+C_OFFSET_25(C)
  movaps C3, 0x20+C_OFFSET_25(C)
  movaps C4, 0x30+C_OFFSET_25(C)

  .align 16
block_199:

  # Check norm of product A(2,5)*B(5,6).
  movss 0x48(multiply_stream, base_pointer), B1
  mulss 0x1ac(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_200

  # Reset C(2,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,6) = A(2,5)*B(5,6).
  movaps 0x0+B_OFFSET_56(B), B1
  movaps 0x10+B_OFFSET_56(B), B2
  movaps 0x20+B_OFFSET_56(B), B3
  movaps 0x30+B_OFFSET_56(B), B4
  movaps 0x0+A_OFFSET_25(A), A11
  movaps 0x10+A_OFFSET_25(A), A12
  movaps 0x20+A_OFFSET_25(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_25(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_25(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_25(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_25(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_25(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_25(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_25(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_25(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_25(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_25(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_25(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_25(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_25(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,6) to already existing.
  addps 0x0+C_OFFSET_26(C), C1
  addps 0x10+C_OFFSET_26(C), C2
  addps 0x20+C_OFFSET_26(C), C3
  addps 0x30+C_OFFSET_26(C), C4

  # Write out C(2,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_26(C)
  movaps C2, 0x10+C_OFFSET_26(C)
  movaps C3, 0x20+C_OFFSET_26(C)
  movaps C4, 0x30+C_OFFSET_26(C)

  .align 16
block_200:

  # Check norm of product A(2,6)*B(6,6).
  movss 0x4c(multiply_stream, base_pointer), B1
  mulss 0x1cc(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_201

  # Reset C(2,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,6) = A(2,6)*B(6,6).
  movaps 0x0+B_OFFSET_66(B), B1
  movaps 0x10+B_OFFSET_66(B), B2
  movaps 0x20+B_OFFSET_66(B), B3
  movaps 0x30+B_OFFSET_66(B), B4
  movaps 0x0+A_OFFSET_26(A), A11
  movaps 0x10+A_OFFSET_26(A), A12
  movaps 0x20+A_OFFSET_26(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_26(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_26(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_26(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_26(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_26(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_26(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_26(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_26(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_26(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_26(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_26(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_26(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_26(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,6) to already existing.
  addps 0x0+C_OFFSET_26(C), C1
  addps 0x10+C_OFFSET_26(C), C2
  addps 0x20+C_OFFSET_26(C), C3
  addps 0x30+C_OFFSET_26(C), C4

  # Write out C(2,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_26(C)
  movaps C2, 0x10+C_OFFSET_26(C)
  movaps C3, 0x20+C_OFFSET_26(C)
  movaps C4, 0x30+C_OFFSET_26(C)

  .align 16
block_201:

  # Check norm of product A(1,7)*B(7,5).
  movss 0x30(multiply_stream, base_pointer), B1
  mulss 0x1e8(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_202

  # Reset C(1,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,5) = A(1,7)*B(7,5).
  movaps 0x0+B_OFFSET_75(B), B1
  movaps 0x10+B_OFFSET_75(B), B2
  movaps 0x20+B_OFFSET_75(B), B3
  movaps 0x30+B_OFFSET_75(B), B4
  movaps 0x0+A_OFFSET_17(A), A11
  movaps 0x10+A_OFFSET_17(A), A12
  movaps 0x20+A_OFFSET_17(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_17(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_17(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_17(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_17(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_17(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_17(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_17(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_17(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_17(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_17(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_17(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_17(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_17(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,5) to already existing.
  addps 0x0+C_OFFSET_15(C), C1
  addps 0x10+C_OFFSET_15(C), C2
  addps 0x20+C_OFFSET_15(C), C3
  addps 0x30+C_OFFSET_15(C), C4

  # Write out C(1,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_15(C)
  movaps C2, 0x10+C_OFFSET_15(C)
  movaps C3, 0x20+C_OFFSET_15(C)
  movaps C4, 0x30+C_OFFSET_15(C)

  .align 16
block_202:

  # Check norm of product A(1,8)*B(8,5).
  movss 0x34(multiply_stream, base_pointer), B1
  mulss 0x208(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_203

  # Reset C(1,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,5) = A(1,8)*B(8,5).
  movaps 0x0+B_OFFSET_85(B), B1
  movaps 0x10+B_OFFSET_85(B), B2
  movaps 0x20+B_OFFSET_85(B), B3
  movaps 0x30+B_OFFSET_85(B), B4
  movaps 0x0+A_OFFSET_18(A), A11
  movaps 0x10+A_OFFSET_18(A), A12
  movaps 0x20+A_OFFSET_18(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_18(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_18(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_18(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_18(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_18(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_18(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_18(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_18(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_18(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_18(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_18(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_18(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_18(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,5) to already existing.
  addps 0x0+C_OFFSET_15(C), C1
  addps 0x10+C_OFFSET_15(C), C2
  addps 0x20+C_OFFSET_15(C), C3
  addps 0x30+C_OFFSET_15(C), C4

  # Write out C(1,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_15(C)
  movaps C2, 0x10+C_OFFSET_15(C)
  movaps C3, 0x20+C_OFFSET_15(C)
  movaps C4, 0x30+C_OFFSET_15(C)

  .align 16
block_203:

  # Check norm of product A(1,7)*B(7,6).
  movss 0x30(multiply_stream, base_pointer), B1
  mulss 0x1ec(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_204

  # Reset C(1,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,6) = A(1,7)*B(7,6).
  movaps 0x0+B_OFFSET_76(B), B1
  movaps 0x10+B_OFFSET_76(B), B2
  movaps 0x20+B_OFFSET_76(B), B3
  movaps 0x30+B_OFFSET_76(B), B4
  movaps 0x0+A_OFFSET_17(A), A11
  movaps 0x10+A_OFFSET_17(A), A12
  movaps 0x20+A_OFFSET_17(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_17(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_17(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_17(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_17(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_17(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_17(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_17(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_17(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_17(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_17(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_17(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_17(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_17(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,6) to already existing.
  addps 0x0+C_OFFSET_16(C), C1
  addps 0x10+C_OFFSET_16(C), C2
  addps 0x20+C_OFFSET_16(C), C3
  addps 0x30+C_OFFSET_16(C), C4

  # Write out C(1,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_16(C)
  movaps C2, 0x10+C_OFFSET_16(C)
  movaps C3, 0x20+C_OFFSET_16(C)
  movaps C4, 0x30+C_OFFSET_16(C)

  .align 16
block_204:

  # Check norm of product A(1,8)*B(8,6).
  movss 0x34(multiply_stream, base_pointer), B1
  mulss 0x20c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_205

  # Reset C(1,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,6) = A(1,8)*B(8,6).
  movaps 0x0+B_OFFSET_86(B), B1
  movaps 0x10+B_OFFSET_86(B), B2
  movaps 0x20+B_OFFSET_86(B), B3
  movaps 0x30+B_OFFSET_86(B), B4
  movaps 0x0+A_OFFSET_18(A), A11
  movaps 0x10+A_OFFSET_18(A), A12
  movaps 0x20+A_OFFSET_18(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_18(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_18(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_18(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_18(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_18(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_18(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_18(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_18(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_18(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_18(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_18(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_18(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_18(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,6) to already existing.
  addps 0x0+C_OFFSET_16(C), C1
  addps 0x10+C_OFFSET_16(C), C2
  addps 0x20+C_OFFSET_16(C), C3
  addps 0x30+C_OFFSET_16(C), C4

  # Write out C(1,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_16(C)
  movaps C2, 0x10+C_OFFSET_16(C)
  movaps C3, 0x20+C_OFFSET_16(C)
  movaps C4, 0x30+C_OFFSET_16(C)

  .align 16
block_205:

  # Check norm of product A(2,7)*B(7,5).
  movss 0x50(multiply_stream, base_pointer), B1
  mulss 0x1e8(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_206

  # Reset C(2,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,5) = A(2,7)*B(7,5).
  movaps 0x0+B_OFFSET_75(B), B1
  movaps 0x10+B_OFFSET_75(B), B2
  movaps 0x20+B_OFFSET_75(B), B3
  movaps 0x30+B_OFFSET_75(B), B4
  movaps 0x0+A_OFFSET_27(A), A11
  movaps 0x10+A_OFFSET_27(A), A12
  movaps 0x20+A_OFFSET_27(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_27(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_27(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_27(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_27(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_27(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_27(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_27(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_27(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_27(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_27(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_27(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_27(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_27(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,5) to already existing.
  addps 0x0+C_OFFSET_25(C), C1
  addps 0x10+C_OFFSET_25(C), C2
  addps 0x20+C_OFFSET_25(C), C3
  addps 0x30+C_OFFSET_25(C), C4

  # Write out C(2,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_25(C)
  movaps C2, 0x10+C_OFFSET_25(C)
  movaps C3, 0x20+C_OFFSET_25(C)
  movaps C4, 0x30+C_OFFSET_25(C)

  .align 16
block_206:

  # Check norm of product A(2,8)*B(8,5).
  movss 0x54(multiply_stream, base_pointer), B1
  mulss 0x208(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_207

  # Reset C(2,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,5) = A(2,8)*B(8,5).
  movaps 0x0+B_OFFSET_85(B), B1
  movaps 0x10+B_OFFSET_85(B), B2
  movaps 0x20+B_OFFSET_85(B), B3
  movaps 0x30+B_OFFSET_85(B), B4
  movaps 0x0+A_OFFSET_28(A), A11
  movaps 0x10+A_OFFSET_28(A), A12
  movaps 0x20+A_OFFSET_28(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_28(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_28(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_28(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_28(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_28(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_28(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_28(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_28(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_28(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_28(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_28(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_28(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_28(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,5) to already existing.
  addps 0x0+C_OFFSET_25(C), C1
  addps 0x10+C_OFFSET_25(C), C2
  addps 0x20+C_OFFSET_25(C), C3
  addps 0x30+C_OFFSET_25(C), C4

  # Write out C(2,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_25(C)
  movaps C2, 0x10+C_OFFSET_25(C)
  movaps C3, 0x20+C_OFFSET_25(C)
  movaps C4, 0x30+C_OFFSET_25(C)

  .align 16
block_207:

  # Check norm of product A(2,7)*B(7,6).
  movss 0x50(multiply_stream, base_pointer), B1
  mulss 0x1ec(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_208

  # Reset C(2,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,6) = A(2,7)*B(7,6).
  movaps 0x0+B_OFFSET_76(B), B1
  movaps 0x10+B_OFFSET_76(B), B2
  movaps 0x20+B_OFFSET_76(B), B3
  movaps 0x30+B_OFFSET_76(B), B4
  movaps 0x0+A_OFFSET_27(A), A11
  movaps 0x10+A_OFFSET_27(A), A12
  movaps 0x20+A_OFFSET_27(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_27(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_27(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_27(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_27(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_27(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_27(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_27(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_27(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_27(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_27(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_27(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_27(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_27(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,6) to already existing.
  addps 0x0+C_OFFSET_26(C), C1
  addps 0x10+C_OFFSET_26(C), C2
  addps 0x20+C_OFFSET_26(C), C3
  addps 0x30+C_OFFSET_26(C), C4

  # Write out C(2,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_26(C)
  movaps C2, 0x10+C_OFFSET_26(C)
  movaps C3, 0x20+C_OFFSET_26(C)
  movaps C4, 0x30+C_OFFSET_26(C)

  .align 16
block_208:

  # Check norm of product A(2,8)*B(8,6).
  movss 0x54(multiply_stream, base_pointer), B1
  mulss 0x20c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_209

  # Reset C(2,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,6) = A(2,8)*B(8,6).
  movaps 0x0+B_OFFSET_86(B), B1
  movaps 0x10+B_OFFSET_86(B), B2
  movaps 0x20+B_OFFSET_86(B), B3
  movaps 0x30+B_OFFSET_86(B), B4
  movaps 0x0+A_OFFSET_28(A), A11
  movaps 0x10+A_OFFSET_28(A), A12
  movaps 0x20+A_OFFSET_28(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_28(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_28(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_28(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_28(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_28(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_28(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_28(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_28(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_28(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_28(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_28(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_28(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_28(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,6) to already existing.
  addps 0x0+C_OFFSET_26(C), C1
  addps 0x10+C_OFFSET_26(C), C2
  addps 0x20+C_OFFSET_26(C), C3
  addps 0x30+C_OFFSET_26(C), C4

  # Write out C(2,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_26(C)
  movaps C2, 0x10+C_OFFSET_26(C)
  movaps C3, 0x20+C_OFFSET_26(C)
  movaps C4, 0x30+C_OFFSET_26(C)

  .align 16
block_209:

  # Check norm of product A(1,5)*B(5,7).
  movss 0x28(multiply_stream, base_pointer), B1
  mulss 0x1b0(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_210

  # Reset C(1,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,7) = A(1,5)*B(5,7).
  movaps 0x0+B_OFFSET_57(B), B1
  movaps 0x10+B_OFFSET_57(B), B2
  movaps 0x20+B_OFFSET_57(B), B3
  movaps 0x30+B_OFFSET_57(B), B4
  movaps 0x0+A_OFFSET_15(A), A11
  movaps 0x10+A_OFFSET_15(A), A12
  movaps 0x20+A_OFFSET_15(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_15(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_15(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_15(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_15(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_15(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_15(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_15(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_15(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_15(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_15(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_15(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_15(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_15(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,7) to already existing.
  addps 0x0+C_OFFSET_17(C), C1
  addps 0x10+C_OFFSET_17(C), C2
  addps 0x20+C_OFFSET_17(C), C3
  addps 0x30+C_OFFSET_17(C), C4

  # Write out C(1,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_17(C)
  movaps C2, 0x10+C_OFFSET_17(C)
  movaps C3, 0x20+C_OFFSET_17(C)
  movaps C4, 0x30+C_OFFSET_17(C)

  .align 16
block_210:

  # Check norm of product A(1,6)*B(6,7).
  movss 0x2c(multiply_stream, base_pointer), B1
  mulss 0x1d0(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_211

  # Reset C(1,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,7) = A(1,6)*B(6,7).
  movaps 0x0+B_OFFSET_67(B), B1
  movaps 0x10+B_OFFSET_67(B), B2
  movaps 0x20+B_OFFSET_67(B), B3
  movaps 0x30+B_OFFSET_67(B), B4
  movaps 0x0+A_OFFSET_16(A), A11
  movaps 0x10+A_OFFSET_16(A), A12
  movaps 0x20+A_OFFSET_16(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_16(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_16(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_16(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_16(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_16(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_16(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_16(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_16(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_16(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_16(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_16(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_16(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_16(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,7) to already existing.
  addps 0x0+C_OFFSET_17(C), C1
  addps 0x10+C_OFFSET_17(C), C2
  addps 0x20+C_OFFSET_17(C), C3
  addps 0x30+C_OFFSET_17(C), C4

  # Write out C(1,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_17(C)
  movaps C2, 0x10+C_OFFSET_17(C)
  movaps C3, 0x20+C_OFFSET_17(C)
  movaps C4, 0x30+C_OFFSET_17(C)

  .align 16
block_211:

  # Check norm of product A(1,5)*B(5,8).
  movss 0x28(multiply_stream, base_pointer), B1
  mulss 0x1b4(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_212

  # Reset C(1,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,8) = A(1,5)*B(5,8).
  movaps 0x0+B_OFFSET_58(B), B1
  movaps 0x10+B_OFFSET_58(B), B2
  movaps 0x20+B_OFFSET_58(B), B3
  movaps 0x30+B_OFFSET_58(B), B4
  movaps 0x0+A_OFFSET_15(A), A11
  movaps 0x10+A_OFFSET_15(A), A12
  movaps 0x20+A_OFFSET_15(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_15(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_15(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_15(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_15(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_15(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_15(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_15(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_15(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_15(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_15(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_15(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_15(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_15(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,8) to already existing.
  addps 0x0+C_OFFSET_18(C), C1
  addps 0x10+C_OFFSET_18(C), C2
  addps 0x20+C_OFFSET_18(C), C3
  addps 0x30+C_OFFSET_18(C), C4

  # Write out C(1,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_18(C)
  movaps C2, 0x10+C_OFFSET_18(C)
  movaps C3, 0x20+C_OFFSET_18(C)
  movaps C4, 0x30+C_OFFSET_18(C)

  .align 16
block_212:

  # Check norm of product A(1,6)*B(6,8).
  movss 0x2c(multiply_stream, base_pointer), B1
  mulss 0x1d4(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_213

  # Reset C(1,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,8) = A(1,6)*B(6,8).
  movaps 0x0+B_OFFSET_68(B), B1
  movaps 0x10+B_OFFSET_68(B), B2
  movaps 0x20+B_OFFSET_68(B), B3
  movaps 0x30+B_OFFSET_68(B), B4
  movaps 0x0+A_OFFSET_16(A), A11
  movaps 0x10+A_OFFSET_16(A), A12
  movaps 0x20+A_OFFSET_16(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_16(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_16(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_16(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_16(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_16(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_16(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_16(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_16(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_16(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_16(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_16(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_16(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_16(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,8) to already existing.
  addps 0x0+C_OFFSET_18(C), C1
  addps 0x10+C_OFFSET_18(C), C2
  addps 0x20+C_OFFSET_18(C), C3
  addps 0x30+C_OFFSET_18(C), C4

  # Write out C(1,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_18(C)
  movaps C2, 0x10+C_OFFSET_18(C)
  movaps C3, 0x20+C_OFFSET_18(C)
  movaps C4, 0x30+C_OFFSET_18(C)

  .align 16
block_213:

  # Check norm of product A(2,5)*B(5,7).
  movss 0x48(multiply_stream, base_pointer), B1
  mulss 0x1b0(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_214

  # Reset C(2,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,7) = A(2,5)*B(5,7).
  movaps 0x0+B_OFFSET_57(B), B1
  movaps 0x10+B_OFFSET_57(B), B2
  movaps 0x20+B_OFFSET_57(B), B3
  movaps 0x30+B_OFFSET_57(B), B4
  movaps 0x0+A_OFFSET_25(A), A11
  movaps 0x10+A_OFFSET_25(A), A12
  movaps 0x20+A_OFFSET_25(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_25(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_25(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_25(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_25(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_25(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_25(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_25(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_25(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_25(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_25(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_25(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_25(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_25(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,7) to already existing.
  addps 0x0+C_OFFSET_27(C), C1
  addps 0x10+C_OFFSET_27(C), C2
  addps 0x20+C_OFFSET_27(C), C3
  addps 0x30+C_OFFSET_27(C), C4

  # Write out C(2,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_27(C)
  movaps C2, 0x10+C_OFFSET_27(C)
  movaps C3, 0x20+C_OFFSET_27(C)
  movaps C4, 0x30+C_OFFSET_27(C)

  .align 16
block_214:

  # Check norm of product A(2,6)*B(6,7).
  movss 0x4c(multiply_stream, base_pointer), B1
  mulss 0x1d0(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_215

  # Reset C(2,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,7) = A(2,6)*B(6,7).
  movaps 0x0+B_OFFSET_67(B), B1
  movaps 0x10+B_OFFSET_67(B), B2
  movaps 0x20+B_OFFSET_67(B), B3
  movaps 0x30+B_OFFSET_67(B), B4
  movaps 0x0+A_OFFSET_26(A), A11
  movaps 0x10+A_OFFSET_26(A), A12
  movaps 0x20+A_OFFSET_26(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_26(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_26(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_26(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_26(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_26(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_26(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_26(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_26(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_26(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_26(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_26(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_26(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_26(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,7) to already existing.
  addps 0x0+C_OFFSET_27(C), C1
  addps 0x10+C_OFFSET_27(C), C2
  addps 0x20+C_OFFSET_27(C), C3
  addps 0x30+C_OFFSET_27(C), C4

  # Write out C(2,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_27(C)
  movaps C2, 0x10+C_OFFSET_27(C)
  movaps C3, 0x20+C_OFFSET_27(C)
  movaps C4, 0x30+C_OFFSET_27(C)

  .align 16
block_215:

  # Check norm of product A(2,5)*B(5,8).
  movss 0x48(multiply_stream, base_pointer), B1
  mulss 0x1b4(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_216

  # Reset C(2,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,8) = A(2,5)*B(5,8).
  movaps 0x0+B_OFFSET_58(B), B1
  movaps 0x10+B_OFFSET_58(B), B2
  movaps 0x20+B_OFFSET_58(B), B3
  movaps 0x30+B_OFFSET_58(B), B4
  movaps 0x0+A_OFFSET_25(A), A11
  movaps 0x10+A_OFFSET_25(A), A12
  movaps 0x20+A_OFFSET_25(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_25(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_25(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_25(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_25(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_25(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_25(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_25(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_25(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_25(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_25(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_25(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_25(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_25(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,8) to already existing.
  addps 0x0+C_OFFSET_28(C), C1
  addps 0x10+C_OFFSET_28(C), C2
  addps 0x20+C_OFFSET_28(C), C3
  addps 0x30+C_OFFSET_28(C), C4

  # Write out C(2,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_28(C)
  movaps C2, 0x10+C_OFFSET_28(C)
  movaps C3, 0x20+C_OFFSET_28(C)
  movaps C4, 0x30+C_OFFSET_28(C)

  .align 16
block_216:

  # Check norm of product A(2,6)*B(6,8).
  movss 0x4c(multiply_stream, base_pointer), B1
  mulss 0x1d4(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_217

  # Reset C(2,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,8) = A(2,6)*B(6,8).
  movaps 0x0+B_OFFSET_68(B), B1
  movaps 0x10+B_OFFSET_68(B), B2
  movaps 0x20+B_OFFSET_68(B), B3
  movaps 0x30+B_OFFSET_68(B), B4
  movaps 0x0+A_OFFSET_26(A), A11
  movaps 0x10+A_OFFSET_26(A), A12
  movaps 0x20+A_OFFSET_26(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_26(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_26(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_26(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_26(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_26(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_26(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_26(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_26(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_26(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_26(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_26(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_26(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_26(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,8) to already existing.
  addps 0x0+C_OFFSET_28(C), C1
  addps 0x10+C_OFFSET_28(C), C2
  addps 0x20+C_OFFSET_28(C), C3
  addps 0x30+C_OFFSET_28(C), C4

  # Write out C(2,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_28(C)
  movaps C2, 0x10+C_OFFSET_28(C)
  movaps C3, 0x20+C_OFFSET_28(C)
  movaps C4, 0x30+C_OFFSET_28(C)

  .align 16
block_217:

  # Check norm of product A(1,7)*B(7,7).
  movss 0x30(multiply_stream, base_pointer), B1
  mulss 0x1f0(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_218

  # Reset C(1,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,7) = A(1,7)*B(7,7).
  movaps 0x0+B_OFFSET_77(B), B1
  movaps 0x10+B_OFFSET_77(B), B2
  movaps 0x20+B_OFFSET_77(B), B3
  movaps 0x30+B_OFFSET_77(B), B4
  movaps 0x0+A_OFFSET_17(A), A11
  movaps 0x10+A_OFFSET_17(A), A12
  movaps 0x20+A_OFFSET_17(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_17(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_17(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_17(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_17(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_17(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_17(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_17(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_17(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_17(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_17(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_17(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_17(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_17(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,7) to already existing.
  addps 0x0+C_OFFSET_17(C), C1
  addps 0x10+C_OFFSET_17(C), C2
  addps 0x20+C_OFFSET_17(C), C3
  addps 0x30+C_OFFSET_17(C), C4

  # Write out C(1,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_17(C)
  movaps C2, 0x10+C_OFFSET_17(C)
  movaps C3, 0x20+C_OFFSET_17(C)
  movaps C4, 0x30+C_OFFSET_17(C)

  .align 16
block_218:

  # Check norm of product A(1,8)*B(8,7).
  movss 0x34(multiply_stream, base_pointer), B1
  mulss 0x210(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_219

  # Reset C(1,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,7) = A(1,8)*B(8,7).
  movaps 0x0+B_OFFSET_87(B), B1
  movaps 0x10+B_OFFSET_87(B), B2
  movaps 0x20+B_OFFSET_87(B), B3
  movaps 0x30+B_OFFSET_87(B), B4
  movaps 0x0+A_OFFSET_18(A), A11
  movaps 0x10+A_OFFSET_18(A), A12
  movaps 0x20+A_OFFSET_18(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_18(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_18(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_18(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_18(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_18(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_18(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_18(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_18(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_18(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_18(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_18(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_18(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_18(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,7) to already existing.
  addps 0x0+C_OFFSET_17(C), C1
  addps 0x10+C_OFFSET_17(C), C2
  addps 0x20+C_OFFSET_17(C), C3
  addps 0x30+C_OFFSET_17(C), C4

  # Write out C(1,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_17(C)
  movaps C2, 0x10+C_OFFSET_17(C)
  movaps C3, 0x20+C_OFFSET_17(C)
  movaps C4, 0x30+C_OFFSET_17(C)

  .align 16
block_219:

  # Check norm of product A(1,7)*B(7,8).
  movss 0x30(multiply_stream, base_pointer), B1
  mulss 0x1f4(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_220

  # Reset C(1,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,8) = A(1,7)*B(7,8).
  movaps 0x0+B_OFFSET_78(B), B1
  movaps 0x10+B_OFFSET_78(B), B2
  movaps 0x20+B_OFFSET_78(B), B3
  movaps 0x30+B_OFFSET_78(B), B4
  movaps 0x0+A_OFFSET_17(A), A11
  movaps 0x10+A_OFFSET_17(A), A12
  movaps 0x20+A_OFFSET_17(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_17(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_17(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_17(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_17(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_17(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_17(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_17(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_17(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_17(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_17(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_17(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_17(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_17(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,8) to already existing.
  addps 0x0+C_OFFSET_18(C), C1
  addps 0x10+C_OFFSET_18(C), C2
  addps 0x20+C_OFFSET_18(C), C3
  addps 0x30+C_OFFSET_18(C), C4

  # Write out C(1,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_18(C)
  movaps C2, 0x10+C_OFFSET_18(C)
  movaps C3, 0x20+C_OFFSET_18(C)
  movaps C4, 0x30+C_OFFSET_18(C)

  .align 16
block_220:

  # Check norm of product A(1,8)*B(8,8).
  movss 0x34(multiply_stream, base_pointer), B1
  mulss 0x214(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_221

  # Reset C(1,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(1,8) = A(1,8)*B(8,8).
  movaps 0x0+B_OFFSET_88(B), B1
  movaps 0x10+B_OFFSET_88(B), B2
  movaps 0x20+B_OFFSET_88(B), B3
  movaps 0x30+B_OFFSET_88(B), B4
  movaps 0x0+A_OFFSET_18(A), A11
  movaps 0x10+A_OFFSET_18(A), A12
  movaps 0x20+A_OFFSET_18(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_18(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_18(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_18(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_18(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_18(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_18(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_18(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_18(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_18(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_18(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_18(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_18(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_18(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(1,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(1,8) to already existing.
  addps 0x0+C_OFFSET_18(C), C1
  addps 0x10+C_OFFSET_18(C), C2
  addps 0x20+C_OFFSET_18(C), C3
  addps 0x30+C_OFFSET_18(C), C4

  # Write out C(1,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_18(C)
  movaps C2, 0x10+C_OFFSET_18(C)
  movaps C3, 0x20+C_OFFSET_18(C)
  movaps C4, 0x30+C_OFFSET_18(C)

  .align 16
block_221:

  # Check norm of product A(2,7)*B(7,7).
  movss 0x50(multiply_stream, base_pointer), B1
  mulss 0x1f0(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_222

  # Reset C(2,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,7) = A(2,7)*B(7,7).
  movaps 0x0+B_OFFSET_77(B), B1
  movaps 0x10+B_OFFSET_77(B), B2
  movaps 0x20+B_OFFSET_77(B), B3
  movaps 0x30+B_OFFSET_77(B), B4
  movaps 0x0+A_OFFSET_27(A), A11
  movaps 0x10+A_OFFSET_27(A), A12
  movaps 0x20+A_OFFSET_27(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_27(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_27(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_27(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_27(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_27(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_27(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_27(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_27(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_27(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_27(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_27(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_27(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_27(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,7) to already existing.
  addps 0x0+C_OFFSET_27(C), C1
  addps 0x10+C_OFFSET_27(C), C2
  addps 0x20+C_OFFSET_27(C), C3
  addps 0x30+C_OFFSET_27(C), C4

  # Write out C(2,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_27(C)
  movaps C2, 0x10+C_OFFSET_27(C)
  movaps C3, 0x20+C_OFFSET_27(C)
  movaps C4, 0x30+C_OFFSET_27(C)

  .align 16
block_222:

  # Check norm of product A(2,8)*B(8,7).
  movss 0x54(multiply_stream, base_pointer), B1
  mulss 0x210(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_223

  # Reset C(2,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,7) = A(2,8)*B(8,7).
  movaps 0x0+B_OFFSET_87(B), B1
  movaps 0x10+B_OFFSET_87(B), B2
  movaps 0x20+B_OFFSET_87(B), B3
  movaps 0x30+B_OFFSET_87(B), B4
  movaps 0x0+A_OFFSET_28(A), A11
  movaps 0x10+A_OFFSET_28(A), A12
  movaps 0x20+A_OFFSET_28(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_28(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_28(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_28(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_28(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_28(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_28(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_28(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_28(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_28(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_28(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_28(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_28(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_28(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,7) to already existing.
  addps 0x0+C_OFFSET_27(C), C1
  addps 0x10+C_OFFSET_27(C), C2
  addps 0x20+C_OFFSET_27(C), C3
  addps 0x30+C_OFFSET_27(C), C4

  # Write out C(2,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_27(C)
  movaps C2, 0x10+C_OFFSET_27(C)
  movaps C3, 0x20+C_OFFSET_27(C)
  movaps C4, 0x30+C_OFFSET_27(C)

  .align 16
block_223:

  # Check norm of product A(2,7)*B(7,8).
  movss 0x50(multiply_stream, base_pointer), B1
  mulss 0x1f4(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_224

  # Reset C(2,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,8) = A(2,7)*B(7,8).
  movaps 0x0+B_OFFSET_78(B), B1
  movaps 0x10+B_OFFSET_78(B), B2
  movaps 0x20+B_OFFSET_78(B), B3
  movaps 0x30+B_OFFSET_78(B), B4
  movaps 0x0+A_OFFSET_27(A), A11
  movaps 0x10+A_OFFSET_27(A), A12
  movaps 0x20+A_OFFSET_27(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_27(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_27(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_27(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_27(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_27(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_27(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_27(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_27(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_27(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_27(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_27(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_27(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_27(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,8) to already existing.
  addps 0x0+C_OFFSET_28(C), C1
  addps 0x10+C_OFFSET_28(C), C2
  addps 0x20+C_OFFSET_28(C), C3
  addps 0x30+C_OFFSET_28(C), C4

  # Write out C(2,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_28(C)
  movaps C2, 0x10+C_OFFSET_28(C)
  movaps C3, 0x20+C_OFFSET_28(C)
  movaps C4, 0x30+C_OFFSET_28(C)

  .align 16
block_224:

  # Check norm of product A(2,8)*B(8,8).
  movss 0x54(multiply_stream, base_pointer), B1
  mulss 0x214(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_225

  # Reset C(2,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(2,8) = A(2,8)*B(8,8).
  movaps 0x0+B_OFFSET_88(B), B1
  movaps 0x10+B_OFFSET_88(B), B2
  movaps 0x20+B_OFFSET_88(B), B3
  movaps 0x30+B_OFFSET_88(B), B4
  movaps 0x0+A_OFFSET_28(A), A11
  movaps 0x10+A_OFFSET_28(A), A12
  movaps 0x20+A_OFFSET_28(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_28(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_28(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_28(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_28(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_28(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_28(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_28(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_28(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_28(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_28(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_28(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_28(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_28(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(2,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(2,8) to already existing.
  addps 0x0+C_OFFSET_28(C), C1
  addps 0x10+C_OFFSET_28(C), C2
  addps 0x20+C_OFFSET_28(C), C3
  addps 0x30+C_OFFSET_28(C), C4

  # Write out C(2,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_28(C)
  movaps C2, 0x10+C_OFFSET_28(C)
  movaps C3, 0x20+C_OFFSET_28(C)
  movaps C4, 0x30+C_OFFSET_28(C)

  .align 16
block_225:

  # Check norm of product A(3,5)*B(5,5).
  movss 0x68(multiply_stream, base_pointer), B1
  mulss 0x1a8(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_226

  # Reset C(3,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,5) = A(3,5)*B(5,5).
  movaps 0x0+B_OFFSET_55(B), B1
  movaps 0x10+B_OFFSET_55(B), B2
  movaps 0x20+B_OFFSET_55(B), B3
  movaps 0x30+B_OFFSET_55(B), B4
  movaps 0x0+A_OFFSET_35(A), A11
  movaps 0x10+A_OFFSET_35(A), A12
  movaps 0x20+A_OFFSET_35(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_35(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_35(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_35(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_35(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_35(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_35(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_35(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_35(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_35(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_35(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_35(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_35(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_35(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,5) to already existing.
  addps 0x0+C_OFFSET_35(C), C1
  addps 0x10+C_OFFSET_35(C), C2
  addps 0x20+C_OFFSET_35(C), C3
  addps 0x30+C_OFFSET_35(C), C4

  # Write out C(3,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_35(C)
  movaps C2, 0x10+C_OFFSET_35(C)
  movaps C3, 0x20+C_OFFSET_35(C)
  movaps C4, 0x30+C_OFFSET_35(C)

  .align 16
block_226:

  # Check norm of product A(3,6)*B(6,5).
  movss 0x6c(multiply_stream, base_pointer), B1
  mulss 0x1c8(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_227

  # Reset C(3,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,5) = A(3,6)*B(6,5).
  movaps 0x0+B_OFFSET_65(B), B1
  movaps 0x10+B_OFFSET_65(B), B2
  movaps 0x20+B_OFFSET_65(B), B3
  movaps 0x30+B_OFFSET_65(B), B4
  movaps 0x0+A_OFFSET_36(A), A11
  movaps 0x10+A_OFFSET_36(A), A12
  movaps 0x20+A_OFFSET_36(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_36(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_36(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_36(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_36(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_36(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_36(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_36(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_36(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_36(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_36(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_36(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_36(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_36(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,5) to already existing.
  addps 0x0+C_OFFSET_35(C), C1
  addps 0x10+C_OFFSET_35(C), C2
  addps 0x20+C_OFFSET_35(C), C3
  addps 0x30+C_OFFSET_35(C), C4

  # Write out C(3,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_35(C)
  movaps C2, 0x10+C_OFFSET_35(C)
  movaps C3, 0x20+C_OFFSET_35(C)
  movaps C4, 0x30+C_OFFSET_35(C)

  .align 16
block_227:

  # Check norm of product A(3,5)*B(5,6).
  movss 0x68(multiply_stream, base_pointer), B1
  mulss 0x1ac(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_228

  # Reset C(3,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,6) = A(3,5)*B(5,6).
  movaps 0x0+B_OFFSET_56(B), B1
  movaps 0x10+B_OFFSET_56(B), B2
  movaps 0x20+B_OFFSET_56(B), B3
  movaps 0x30+B_OFFSET_56(B), B4
  movaps 0x0+A_OFFSET_35(A), A11
  movaps 0x10+A_OFFSET_35(A), A12
  movaps 0x20+A_OFFSET_35(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_35(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_35(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_35(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_35(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_35(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_35(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_35(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_35(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_35(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_35(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_35(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_35(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_35(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,6) to already existing.
  addps 0x0+C_OFFSET_36(C), C1
  addps 0x10+C_OFFSET_36(C), C2
  addps 0x20+C_OFFSET_36(C), C3
  addps 0x30+C_OFFSET_36(C), C4

  # Write out C(3,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_36(C)
  movaps C2, 0x10+C_OFFSET_36(C)
  movaps C3, 0x20+C_OFFSET_36(C)
  movaps C4, 0x30+C_OFFSET_36(C)

  .align 16
block_228:

  # Check norm of product A(3,6)*B(6,6).
  movss 0x6c(multiply_stream, base_pointer), B1
  mulss 0x1cc(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_229

  # Reset C(3,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,6) = A(3,6)*B(6,6).
  movaps 0x0+B_OFFSET_66(B), B1
  movaps 0x10+B_OFFSET_66(B), B2
  movaps 0x20+B_OFFSET_66(B), B3
  movaps 0x30+B_OFFSET_66(B), B4
  movaps 0x0+A_OFFSET_36(A), A11
  movaps 0x10+A_OFFSET_36(A), A12
  movaps 0x20+A_OFFSET_36(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_36(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_36(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_36(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_36(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_36(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_36(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_36(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_36(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_36(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_36(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_36(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_36(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_36(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,6) to already existing.
  addps 0x0+C_OFFSET_36(C), C1
  addps 0x10+C_OFFSET_36(C), C2
  addps 0x20+C_OFFSET_36(C), C3
  addps 0x30+C_OFFSET_36(C), C4

  # Write out C(3,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_36(C)
  movaps C2, 0x10+C_OFFSET_36(C)
  movaps C3, 0x20+C_OFFSET_36(C)
  movaps C4, 0x30+C_OFFSET_36(C)

  .align 16
block_229:

  # Check norm of product A(4,5)*B(5,5).
  movss 0x88(multiply_stream, base_pointer), B1
  mulss 0x1a8(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_230

  # Reset C(4,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,5) = A(4,5)*B(5,5).
  movaps 0x0+B_OFFSET_55(B), B1
  movaps 0x10+B_OFFSET_55(B), B2
  movaps 0x20+B_OFFSET_55(B), B3
  movaps 0x30+B_OFFSET_55(B), B4
  movaps 0x0+A_OFFSET_45(A), A11
  movaps 0x10+A_OFFSET_45(A), A12
  movaps 0x20+A_OFFSET_45(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_45(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_45(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_45(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_45(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_45(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_45(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_45(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_45(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_45(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_45(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_45(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_45(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_45(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,5) to already existing.
  addps 0x0+C_OFFSET_45(C), C1
  addps 0x10+C_OFFSET_45(C), C2
  addps 0x20+C_OFFSET_45(C), C3
  addps 0x30+C_OFFSET_45(C), C4

  # Write out C(4,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_45(C)
  movaps C2, 0x10+C_OFFSET_45(C)
  movaps C3, 0x20+C_OFFSET_45(C)
  movaps C4, 0x30+C_OFFSET_45(C)

  .align 16
block_230:

  # Check norm of product A(4,6)*B(6,5).
  movss 0x8c(multiply_stream, base_pointer), B1
  mulss 0x1c8(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_231

  # Reset C(4,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,5) = A(4,6)*B(6,5).
  movaps 0x0+B_OFFSET_65(B), B1
  movaps 0x10+B_OFFSET_65(B), B2
  movaps 0x20+B_OFFSET_65(B), B3
  movaps 0x30+B_OFFSET_65(B), B4
  movaps 0x0+A_OFFSET_46(A), A11
  movaps 0x10+A_OFFSET_46(A), A12
  movaps 0x20+A_OFFSET_46(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_46(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_46(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_46(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_46(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_46(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_46(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_46(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_46(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_46(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_46(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_46(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_46(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_46(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,5) to already existing.
  addps 0x0+C_OFFSET_45(C), C1
  addps 0x10+C_OFFSET_45(C), C2
  addps 0x20+C_OFFSET_45(C), C3
  addps 0x30+C_OFFSET_45(C), C4

  # Write out C(4,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_45(C)
  movaps C2, 0x10+C_OFFSET_45(C)
  movaps C3, 0x20+C_OFFSET_45(C)
  movaps C4, 0x30+C_OFFSET_45(C)

  .align 16
block_231:

  # Check norm of product A(4,5)*B(5,6).
  movss 0x88(multiply_stream, base_pointer), B1
  mulss 0x1ac(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_232

  # Reset C(4,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,6) = A(4,5)*B(5,6).
  movaps 0x0+B_OFFSET_56(B), B1
  movaps 0x10+B_OFFSET_56(B), B2
  movaps 0x20+B_OFFSET_56(B), B3
  movaps 0x30+B_OFFSET_56(B), B4
  movaps 0x0+A_OFFSET_45(A), A11
  movaps 0x10+A_OFFSET_45(A), A12
  movaps 0x20+A_OFFSET_45(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_45(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_45(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_45(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_45(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_45(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_45(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_45(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_45(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_45(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_45(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_45(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_45(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_45(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,6) to already existing.
  addps 0x0+C_OFFSET_46(C), C1
  addps 0x10+C_OFFSET_46(C), C2
  addps 0x20+C_OFFSET_46(C), C3
  addps 0x30+C_OFFSET_46(C), C4

  # Write out C(4,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_46(C)
  movaps C2, 0x10+C_OFFSET_46(C)
  movaps C3, 0x20+C_OFFSET_46(C)
  movaps C4, 0x30+C_OFFSET_46(C)

  .align 16
block_232:

  # Check norm of product A(4,6)*B(6,6).
  movss 0x8c(multiply_stream, base_pointer), B1
  mulss 0x1cc(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_233

  # Reset C(4,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,6) = A(4,6)*B(6,6).
  movaps 0x0+B_OFFSET_66(B), B1
  movaps 0x10+B_OFFSET_66(B), B2
  movaps 0x20+B_OFFSET_66(B), B3
  movaps 0x30+B_OFFSET_66(B), B4
  movaps 0x0+A_OFFSET_46(A), A11
  movaps 0x10+A_OFFSET_46(A), A12
  movaps 0x20+A_OFFSET_46(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_46(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_46(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_46(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_46(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_46(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_46(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_46(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_46(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_46(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_46(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_46(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_46(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_46(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,6) to already existing.
  addps 0x0+C_OFFSET_46(C), C1
  addps 0x10+C_OFFSET_46(C), C2
  addps 0x20+C_OFFSET_46(C), C3
  addps 0x30+C_OFFSET_46(C), C4

  # Write out C(4,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_46(C)
  movaps C2, 0x10+C_OFFSET_46(C)
  movaps C3, 0x20+C_OFFSET_46(C)
  movaps C4, 0x30+C_OFFSET_46(C)

  .align 16
block_233:

  # Check norm of product A(3,7)*B(7,5).
  movss 0x70(multiply_stream, base_pointer), B1
  mulss 0x1e8(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_234

  # Reset C(3,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,5) = A(3,7)*B(7,5).
  movaps 0x0+B_OFFSET_75(B), B1
  movaps 0x10+B_OFFSET_75(B), B2
  movaps 0x20+B_OFFSET_75(B), B3
  movaps 0x30+B_OFFSET_75(B), B4
  movaps 0x0+A_OFFSET_37(A), A11
  movaps 0x10+A_OFFSET_37(A), A12
  movaps 0x20+A_OFFSET_37(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_37(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_37(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_37(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_37(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_37(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_37(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_37(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_37(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_37(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_37(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_37(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_37(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_37(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,5) to already existing.
  addps 0x0+C_OFFSET_35(C), C1
  addps 0x10+C_OFFSET_35(C), C2
  addps 0x20+C_OFFSET_35(C), C3
  addps 0x30+C_OFFSET_35(C), C4

  # Write out C(3,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_35(C)
  movaps C2, 0x10+C_OFFSET_35(C)
  movaps C3, 0x20+C_OFFSET_35(C)
  movaps C4, 0x30+C_OFFSET_35(C)

  .align 16
block_234:

  # Check norm of product A(3,8)*B(8,5).
  movss 0x74(multiply_stream, base_pointer), B1
  mulss 0x208(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_235

  # Reset C(3,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,5) = A(3,8)*B(8,5).
  movaps 0x0+B_OFFSET_85(B), B1
  movaps 0x10+B_OFFSET_85(B), B2
  movaps 0x20+B_OFFSET_85(B), B3
  movaps 0x30+B_OFFSET_85(B), B4
  movaps 0x0+A_OFFSET_38(A), A11
  movaps 0x10+A_OFFSET_38(A), A12
  movaps 0x20+A_OFFSET_38(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_38(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_38(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_38(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_38(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_38(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_38(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_38(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_38(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_38(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_38(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_38(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_38(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_38(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,5) to already existing.
  addps 0x0+C_OFFSET_35(C), C1
  addps 0x10+C_OFFSET_35(C), C2
  addps 0x20+C_OFFSET_35(C), C3
  addps 0x30+C_OFFSET_35(C), C4

  # Write out C(3,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_35(C)
  movaps C2, 0x10+C_OFFSET_35(C)
  movaps C3, 0x20+C_OFFSET_35(C)
  movaps C4, 0x30+C_OFFSET_35(C)

  .align 16
block_235:

  # Check norm of product A(3,7)*B(7,6).
  movss 0x70(multiply_stream, base_pointer), B1
  mulss 0x1ec(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_236

  # Reset C(3,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,6) = A(3,7)*B(7,6).
  movaps 0x0+B_OFFSET_76(B), B1
  movaps 0x10+B_OFFSET_76(B), B2
  movaps 0x20+B_OFFSET_76(B), B3
  movaps 0x30+B_OFFSET_76(B), B4
  movaps 0x0+A_OFFSET_37(A), A11
  movaps 0x10+A_OFFSET_37(A), A12
  movaps 0x20+A_OFFSET_37(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_37(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_37(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_37(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_37(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_37(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_37(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_37(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_37(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_37(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_37(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_37(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_37(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_37(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,6) to already existing.
  addps 0x0+C_OFFSET_36(C), C1
  addps 0x10+C_OFFSET_36(C), C2
  addps 0x20+C_OFFSET_36(C), C3
  addps 0x30+C_OFFSET_36(C), C4

  # Write out C(3,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_36(C)
  movaps C2, 0x10+C_OFFSET_36(C)
  movaps C3, 0x20+C_OFFSET_36(C)
  movaps C4, 0x30+C_OFFSET_36(C)

  .align 16
block_236:

  # Check norm of product A(3,8)*B(8,6).
  movss 0x74(multiply_stream, base_pointer), B1
  mulss 0x20c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_237

  # Reset C(3,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,6) = A(3,8)*B(8,6).
  movaps 0x0+B_OFFSET_86(B), B1
  movaps 0x10+B_OFFSET_86(B), B2
  movaps 0x20+B_OFFSET_86(B), B3
  movaps 0x30+B_OFFSET_86(B), B4
  movaps 0x0+A_OFFSET_38(A), A11
  movaps 0x10+A_OFFSET_38(A), A12
  movaps 0x20+A_OFFSET_38(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_38(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_38(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_38(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_38(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_38(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_38(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_38(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_38(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_38(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_38(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_38(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_38(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_38(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,6) to already existing.
  addps 0x0+C_OFFSET_36(C), C1
  addps 0x10+C_OFFSET_36(C), C2
  addps 0x20+C_OFFSET_36(C), C3
  addps 0x30+C_OFFSET_36(C), C4

  # Write out C(3,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_36(C)
  movaps C2, 0x10+C_OFFSET_36(C)
  movaps C3, 0x20+C_OFFSET_36(C)
  movaps C4, 0x30+C_OFFSET_36(C)

  .align 16
block_237:

  # Check norm of product A(4,7)*B(7,5).
  movss 0x90(multiply_stream, base_pointer), B1
  mulss 0x1e8(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_238

  # Reset C(4,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,5) = A(4,7)*B(7,5).
  movaps 0x0+B_OFFSET_75(B), B1
  movaps 0x10+B_OFFSET_75(B), B2
  movaps 0x20+B_OFFSET_75(B), B3
  movaps 0x30+B_OFFSET_75(B), B4
  movaps 0x0+A_OFFSET_47(A), A11
  movaps 0x10+A_OFFSET_47(A), A12
  movaps 0x20+A_OFFSET_47(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_47(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_47(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_47(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_47(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_47(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_47(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_47(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_47(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_47(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_47(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_47(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_47(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_47(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,5) to already existing.
  addps 0x0+C_OFFSET_45(C), C1
  addps 0x10+C_OFFSET_45(C), C2
  addps 0x20+C_OFFSET_45(C), C3
  addps 0x30+C_OFFSET_45(C), C4

  # Write out C(4,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_45(C)
  movaps C2, 0x10+C_OFFSET_45(C)
  movaps C3, 0x20+C_OFFSET_45(C)
  movaps C4, 0x30+C_OFFSET_45(C)

  .align 16
block_238:

  # Check norm of product A(4,8)*B(8,5).
  movss 0x94(multiply_stream, base_pointer), B1
  mulss 0x208(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_239

  # Reset C(4,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,5) = A(4,8)*B(8,5).
  movaps 0x0+B_OFFSET_85(B), B1
  movaps 0x10+B_OFFSET_85(B), B2
  movaps 0x20+B_OFFSET_85(B), B3
  movaps 0x30+B_OFFSET_85(B), B4
  movaps 0x0+A_OFFSET_48(A), A11
  movaps 0x10+A_OFFSET_48(A), A12
  movaps 0x20+A_OFFSET_48(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_48(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_48(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_48(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_48(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_48(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_48(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_48(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_48(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_48(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_48(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_48(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_48(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_48(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,5) to already existing.
  addps 0x0+C_OFFSET_45(C), C1
  addps 0x10+C_OFFSET_45(C), C2
  addps 0x20+C_OFFSET_45(C), C3
  addps 0x30+C_OFFSET_45(C), C4

  # Write out C(4,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_45(C)
  movaps C2, 0x10+C_OFFSET_45(C)
  movaps C3, 0x20+C_OFFSET_45(C)
  movaps C4, 0x30+C_OFFSET_45(C)

  .align 16
block_239:

  # Check norm of product A(4,7)*B(7,6).
  movss 0x90(multiply_stream, base_pointer), B1
  mulss 0x1ec(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_240

  # Reset C(4,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,6) = A(4,7)*B(7,6).
  movaps 0x0+B_OFFSET_76(B), B1
  movaps 0x10+B_OFFSET_76(B), B2
  movaps 0x20+B_OFFSET_76(B), B3
  movaps 0x30+B_OFFSET_76(B), B4
  movaps 0x0+A_OFFSET_47(A), A11
  movaps 0x10+A_OFFSET_47(A), A12
  movaps 0x20+A_OFFSET_47(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_47(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_47(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_47(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_47(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_47(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_47(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_47(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_47(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_47(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_47(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_47(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_47(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_47(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,6) to already existing.
  addps 0x0+C_OFFSET_46(C), C1
  addps 0x10+C_OFFSET_46(C), C2
  addps 0x20+C_OFFSET_46(C), C3
  addps 0x30+C_OFFSET_46(C), C4

  # Write out C(4,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_46(C)
  movaps C2, 0x10+C_OFFSET_46(C)
  movaps C3, 0x20+C_OFFSET_46(C)
  movaps C4, 0x30+C_OFFSET_46(C)

  .align 16
block_240:

  # Check norm of product A(4,8)*B(8,6).
  movss 0x94(multiply_stream, base_pointer), B1
  mulss 0x20c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_241

  # Reset C(4,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,6) = A(4,8)*B(8,6).
  movaps 0x0+B_OFFSET_86(B), B1
  movaps 0x10+B_OFFSET_86(B), B2
  movaps 0x20+B_OFFSET_86(B), B3
  movaps 0x30+B_OFFSET_86(B), B4
  movaps 0x0+A_OFFSET_48(A), A11
  movaps 0x10+A_OFFSET_48(A), A12
  movaps 0x20+A_OFFSET_48(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_48(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_48(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_48(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_48(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_48(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_48(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_48(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_48(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_48(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_48(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_48(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_48(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_48(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,6) to already existing.
  addps 0x0+C_OFFSET_46(C), C1
  addps 0x10+C_OFFSET_46(C), C2
  addps 0x20+C_OFFSET_46(C), C3
  addps 0x30+C_OFFSET_46(C), C4

  # Write out C(4,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_46(C)
  movaps C2, 0x10+C_OFFSET_46(C)
  movaps C3, 0x20+C_OFFSET_46(C)
  movaps C4, 0x30+C_OFFSET_46(C)

  .align 16
block_241:

  # Check norm of product A(3,5)*B(5,7).
  movss 0x68(multiply_stream, base_pointer), B1
  mulss 0x1b0(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_242

  # Reset C(3,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,7) = A(3,5)*B(5,7).
  movaps 0x0+B_OFFSET_57(B), B1
  movaps 0x10+B_OFFSET_57(B), B2
  movaps 0x20+B_OFFSET_57(B), B3
  movaps 0x30+B_OFFSET_57(B), B4
  movaps 0x0+A_OFFSET_35(A), A11
  movaps 0x10+A_OFFSET_35(A), A12
  movaps 0x20+A_OFFSET_35(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_35(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_35(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_35(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_35(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_35(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_35(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_35(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_35(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_35(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_35(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_35(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_35(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_35(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,7) to already existing.
  addps 0x0+C_OFFSET_37(C), C1
  addps 0x10+C_OFFSET_37(C), C2
  addps 0x20+C_OFFSET_37(C), C3
  addps 0x30+C_OFFSET_37(C), C4

  # Write out C(3,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_37(C)
  movaps C2, 0x10+C_OFFSET_37(C)
  movaps C3, 0x20+C_OFFSET_37(C)
  movaps C4, 0x30+C_OFFSET_37(C)

  .align 16
block_242:

  # Check norm of product A(3,6)*B(6,7).
  movss 0x6c(multiply_stream, base_pointer), B1
  mulss 0x1d0(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_243

  # Reset C(3,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,7) = A(3,6)*B(6,7).
  movaps 0x0+B_OFFSET_67(B), B1
  movaps 0x10+B_OFFSET_67(B), B2
  movaps 0x20+B_OFFSET_67(B), B3
  movaps 0x30+B_OFFSET_67(B), B4
  movaps 0x0+A_OFFSET_36(A), A11
  movaps 0x10+A_OFFSET_36(A), A12
  movaps 0x20+A_OFFSET_36(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_36(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_36(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_36(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_36(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_36(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_36(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_36(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_36(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_36(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_36(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_36(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_36(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_36(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,7) to already existing.
  addps 0x0+C_OFFSET_37(C), C1
  addps 0x10+C_OFFSET_37(C), C2
  addps 0x20+C_OFFSET_37(C), C3
  addps 0x30+C_OFFSET_37(C), C4

  # Write out C(3,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_37(C)
  movaps C2, 0x10+C_OFFSET_37(C)
  movaps C3, 0x20+C_OFFSET_37(C)
  movaps C4, 0x30+C_OFFSET_37(C)

  .align 16
block_243:

  # Check norm of product A(3,5)*B(5,8).
  movss 0x68(multiply_stream, base_pointer), B1
  mulss 0x1b4(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_244

  # Reset C(3,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,8) = A(3,5)*B(5,8).
  movaps 0x0+B_OFFSET_58(B), B1
  movaps 0x10+B_OFFSET_58(B), B2
  movaps 0x20+B_OFFSET_58(B), B3
  movaps 0x30+B_OFFSET_58(B), B4
  movaps 0x0+A_OFFSET_35(A), A11
  movaps 0x10+A_OFFSET_35(A), A12
  movaps 0x20+A_OFFSET_35(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_35(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_35(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_35(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_35(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_35(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_35(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_35(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_35(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_35(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_35(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_35(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_35(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_35(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,8) to already existing.
  addps 0x0+C_OFFSET_38(C), C1
  addps 0x10+C_OFFSET_38(C), C2
  addps 0x20+C_OFFSET_38(C), C3
  addps 0x30+C_OFFSET_38(C), C4

  # Write out C(3,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_38(C)
  movaps C2, 0x10+C_OFFSET_38(C)
  movaps C3, 0x20+C_OFFSET_38(C)
  movaps C4, 0x30+C_OFFSET_38(C)

  .align 16
block_244:

  # Check norm of product A(3,6)*B(6,8).
  movss 0x6c(multiply_stream, base_pointer), B1
  mulss 0x1d4(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_245

  # Reset C(3,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,8) = A(3,6)*B(6,8).
  movaps 0x0+B_OFFSET_68(B), B1
  movaps 0x10+B_OFFSET_68(B), B2
  movaps 0x20+B_OFFSET_68(B), B3
  movaps 0x30+B_OFFSET_68(B), B4
  movaps 0x0+A_OFFSET_36(A), A11
  movaps 0x10+A_OFFSET_36(A), A12
  movaps 0x20+A_OFFSET_36(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_36(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_36(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_36(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_36(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_36(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_36(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_36(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_36(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_36(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_36(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_36(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_36(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_36(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,8) to already existing.
  addps 0x0+C_OFFSET_38(C), C1
  addps 0x10+C_OFFSET_38(C), C2
  addps 0x20+C_OFFSET_38(C), C3
  addps 0x30+C_OFFSET_38(C), C4

  # Write out C(3,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_38(C)
  movaps C2, 0x10+C_OFFSET_38(C)
  movaps C3, 0x20+C_OFFSET_38(C)
  movaps C4, 0x30+C_OFFSET_38(C)

  .align 16
block_245:

  # Check norm of product A(4,5)*B(5,7).
  movss 0x88(multiply_stream, base_pointer), B1
  mulss 0x1b0(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_246

  # Reset C(4,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,7) = A(4,5)*B(5,7).
  movaps 0x0+B_OFFSET_57(B), B1
  movaps 0x10+B_OFFSET_57(B), B2
  movaps 0x20+B_OFFSET_57(B), B3
  movaps 0x30+B_OFFSET_57(B), B4
  movaps 0x0+A_OFFSET_45(A), A11
  movaps 0x10+A_OFFSET_45(A), A12
  movaps 0x20+A_OFFSET_45(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_45(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_45(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_45(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_45(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_45(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_45(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_45(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_45(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_45(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_45(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_45(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_45(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_45(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,7) to already existing.
  addps 0x0+C_OFFSET_47(C), C1
  addps 0x10+C_OFFSET_47(C), C2
  addps 0x20+C_OFFSET_47(C), C3
  addps 0x30+C_OFFSET_47(C), C4

  # Write out C(4,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_47(C)
  movaps C2, 0x10+C_OFFSET_47(C)
  movaps C3, 0x20+C_OFFSET_47(C)
  movaps C4, 0x30+C_OFFSET_47(C)

  .align 16
block_246:

  # Check norm of product A(4,6)*B(6,7).
  movss 0x8c(multiply_stream, base_pointer), B1
  mulss 0x1d0(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_247

  # Reset C(4,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,7) = A(4,6)*B(6,7).
  movaps 0x0+B_OFFSET_67(B), B1
  movaps 0x10+B_OFFSET_67(B), B2
  movaps 0x20+B_OFFSET_67(B), B3
  movaps 0x30+B_OFFSET_67(B), B4
  movaps 0x0+A_OFFSET_46(A), A11
  movaps 0x10+A_OFFSET_46(A), A12
  movaps 0x20+A_OFFSET_46(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_46(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_46(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_46(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_46(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_46(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_46(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_46(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_46(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_46(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_46(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_46(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_46(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_46(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,7) to already existing.
  addps 0x0+C_OFFSET_47(C), C1
  addps 0x10+C_OFFSET_47(C), C2
  addps 0x20+C_OFFSET_47(C), C3
  addps 0x30+C_OFFSET_47(C), C4

  # Write out C(4,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_47(C)
  movaps C2, 0x10+C_OFFSET_47(C)
  movaps C3, 0x20+C_OFFSET_47(C)
  movaps C4, 0x30+C_OFFSET_47(C)

  .align 16
block_247:

  # Check norm of product A(4,5)*B(5,8).
  movss 0x88(multiply_stream, base_pointer), B1
  mulss 0x1b4(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_248

  # Reset C(4,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,8) = A(4,5)*B(5,8).
  movaps 0x0+B_OFFSET_58(B), B1
  movaps 0x10+B_OFFSET_58(B), B2
  movaps 0x20+B_OFFSET_58(B), B3
  movaps 0x30+B_OFFSET_58(B), B4
  movaps 0x0+A_OFFSET_45(A), A11
  movaps 0x10+A_OFFSET_45(A), A12
  movaps 0x20+A_OFFSET_45(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_45(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_45(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_45(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_45(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_45(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_45(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_45(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_45(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_45(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_45(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_45(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_45(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_45(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,8) to already existing.
  addps 0x0+C_OFFSET_48(C), C1
  addps 0x10+C_OFFSET_48(C), C2
  addps 0x20+C_OFFSET_48(C), C3
  addps 0x30+C_OFFSET_48(C), C4

  # Write out C(4,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_48(C)
  movaps C2, 0x10+C_OFFSET_48(C)
  movaps C3, 0x20+C_OFFSET_48(C)
  movaps C4, 0x30+C_OFFSET_48(C)

  .align 16
block_248:

  # Check norm of product A(4,6)*B(6,8).
  movss 0x8c(multiply_stream, base_pointer), B1
  mulss 0x1d4(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_249

  # Reset C(4,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,8) = A(4,6)*B(6,8).
  movaps 0x0+B_OFFSET_68(B), B1
  movaps 0x10+B_OFFSET_68(B), B2
  movaps 0x20+B_OFFSET_68(B), B3
  movaps 0x30+B_OFFSET_68(B), B4
  movaps 0x0+A_OFFSET_46(A), A11
  movaps 0x10+A_OFFSET_46(A), A12
  movaps 0x20+A_OFFSET_46(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_46(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_46(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_46(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_46(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_46(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_46(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_46(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_46(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_46(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_46(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_46(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_46(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_46(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,8) to already existing.
  addps 0x0+C_OFFSET_48(C), C1
  addps 0x10+C_OFFSET_48(C), C2
  addps 0x20+C_OFFSET_48(C), C3
  addps 0x30+C_OFFSET_48(C), C4

  # Write out C(4,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_48(C)
  movaps C2, 0x10+C_OFFSET_48(C)
  movaps C3, 0x20+C_OFFSET_48(C)
  movaps C4, 0x30+C_OFFSET_48(C)

  .align 16
block_249:

  # Check norm of product A(3,7)*B(7,7).
  movss 0x70(multiply_stream, base_pointer), B1
  mulss 0x1f0(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_250

  # Reset C(3,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,7) = A(3,7)*B(7,7).
  movaps 0x0+B_OFFSET_77(B), B1
  movaps 0x10+B_OFFSET_77(B), B2
  movaps 0x20+B_OFFSET_77(B), B3
  movaps 0x30+B_OFFSET_77(B), B4
  movaps 0x0+A_OFFSET_37(A), A11
  movaps 0x10+A_OFFSET_37(A), A12
  movaps 0x20+A_OFFSET_37(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_37(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_37(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_37(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_37(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_37(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_37(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_37(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_37(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_37(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_37(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_37(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_37(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_37(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,7) to already existing.
  addps 0x0+C_OFFSET_37(C), C1
  addps 0x10+C_OFFSET_37(C), C2
  addps 0x20+C_OFFSET_37(C), C3
  addps 0x30+C_OFFSET_37(C), C4

  # Write out C(3,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_37(C)
  movaps C2, 0x10+C_OFFSET_37(C)
  movaps C3, 0x20+C_OFFSET_37(C)
  movaps C4, 0x30+C_OFFSET_37(C)

  .align 16
block_250:

  # Check norm of product A(3,8)*B(8,7).
  movss 0x74(multiply_stream, base_pointer), B1
  mulss 0x210(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_251

  # Reset C(3,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,7) = A(3,8)*B(8,7).
  movaps 0x0+B_OFFSET_87(B), B1
  movaps 0x10+B_OFFSET_87(B), B2
  movaps 0x20+B_OFFSET_87(B), B3
  movaps 0x30+B_OFFSET_87(B), B4
  movaps 0x0+A_OFFSET_38(A), A11
  movaps 0x10+A_OFFSET_38(A), A12
  movaps 0x20+A_OFFSET_38(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_38(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_38(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_38(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_38(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_38(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_38(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_38(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_38(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_38(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_38(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_38(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_38(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_38(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,7) to already existing.
  addps 0x0+C_OFFSET_37(C), C1
  addps 0x10+C_OFFSET_37(C), C2
  addps 0x20+C_OFFSET_37(C), C3
  addps 0x30+C_OFFSET_37(C), C4

  # Write out C(3,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_37(C)
  movaps C2, 0x10+C_OFFSET_37(C)
  movaps C3, 0x20+C_OFFSET_37(C)
  movaps C4, 0x30+C_OFFSET_37(C)

  .align 16
block_251:

  # Check norm of product A(3,7)*B(7,8).
  movss 0x70(multiply_stream, base_pointer), B1
  mulss 0x1f4(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_252

  # Reset C(3,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,8) = A(3,7)*B(7,8).
  movaps 0x0+B_OFFSET_78(B), B1
  movaps 0x10+B_OFFSET_78(B), B2
  movaps 0x20+B_OFFSET_78(B), B3
  movaps 0x30+B_OFFSET_78(B), B4
  movaps 0x0+A_OFFSET_37(A), A11
  movaps 0x10+A_OFFSET_37(A), A12
  movaps 0x20+A_OFFSET_37(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_37(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_37(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_37(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_37(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_37(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_37(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_37(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_37(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_37(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_37(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_37(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_37(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_37(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,8) to already existing.
  addps 0x0+C_OFFSET_38(C), C1
  addps 0x10+C_OFFSET_38(C), C2
  addps 0x20+C_OFFSET_38(C), C3
  addps 0x30+C_OFFSET_38(C), C4

  # Write out C(3,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_38(C)
  movaps C2, 0x10+C_OFFSET_38(C)
  movaps C3, 0x20+C_OFFSET_38(C)
  movaps C4, 0x30+C_OFFSET_38(C)

  .align 16
block_252:

  # Check norm of product A(3,8)*B(8,8).
  movss 0x74(multiply_stream, base_pointer), B1
  mulss 0x214(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_253

  # Reset C(3,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(3,8) = A(3,8)*B(8,8).
  movaps 0x0+B_OFFSET_88(B), B1
  movaps 0x10+B_OFFSET_88(B), B2
  movaps 0x20+B_OFFSET_88(B), B3
  movaps 0x30+B_OFFSET_88(B), B4
  movaps 0x0+A_OFFSET_38(A), A11
  movaps 0x10+A_OFFSET_38(A), A12
  movaps 0x20+A_OFFSET_38(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_38(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_38(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_38(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_38(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_38(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_38(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_38(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_38(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_38(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_38(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_38(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_38(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_38(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(3,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(3,8) to already existing.
  addps 0x0+C_OFFSET_38(C), C1
  addps 0x10+C_OFFSET_38(C), C2
  addps 0x20+C_OFFSET_38(C), C3
  addps 0x30+C_OFFSET_38(C), C4

  # Write out C(3,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_38(C)
  movaps C2, 0x10+C_OFFSET_38(C)
  movaps C3, 0x20+C_OFFSET_38(C)
  movaps C4, 0x30+C_OFFSET_38(C)

  .align 16
block_253:

  # Check norm of product A(4,7)*B(7,7).
  movss 0x90(multiply_stream, base_pointer), B1
  mulss 0x1f0(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_254

  # Reset C(4,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,7) = A(4,7)*B(7,7).
  movaps 0x0+B_OFFSET_77(B), B1
  movaps 0x10+B_OFFSET_77(B), B2
  movaps 0x20+B_OFFSET_77(B), B3
  movaps 0x30+B_OFFSET_77(B), B4
  movaps 0x0+A_OFFSET_47(A), A11
  movaps 0x10+A_OFFSET_47(A), A12
  movaps 0x20+A_OFFSET_47(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_47(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_47(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_47(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_47(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_47(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_47(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_47(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_47(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_47(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_47(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_47(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_47(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_47(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,7) to already existing.
  addps 0x0+C_OFFSET_47(C), C1
  addps 0x10+C_OFFSET_47(C), C2
  addps 0x20+C_OFFSET_47(C), C3
  addps 0x30+C_OFFSET_47(C), C4

  # Write out C(4,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_47(C)
  movaps C2, 0x10+C_OFFSET_47(C)
  movaps C3, 0x20+C_OFFSET_47(C)
  movaps C4, 0x30+C_OFFSET_47(C)

  .align 16
block_254:

  # Check norm of product A(4,8)*B(8,7).
  movss 0x94(multiply_stream, base_pointer), B1
  mulss 0x210(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_255

  # Reset C(4,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,7) = A(4,8)*B(8,7).
  movaps 0x0+B_OFFSET_87(B), B1
  movaps 0x10+B_OFFSET_87(B), B2
  movaps 0x20+B_OFFSET_87(B), B3
  movaps 0x30+B_OFFSET_87(B), B4
  movaps 0x0+A_OFFSET_48(A), A11
  movaps 0x10+A_OFFSET_48(A), A12
  movaps 0x20+A_OFFSET_48(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_48(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_48(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_48(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_48(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_48(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_48(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_48(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_48(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_48(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_48(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_48(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_48(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_48(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,7) to already existing.
  addps 0x0+C_OFFSET_47(C), C1
  addps 0x10+C_OFFSET_47(C), C2
  addps 0x20+C_OFFSET_47(C), C3
  addps 0x30+C_OFFSET_47(C), C4

  # Write out C(4,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_47(C)
  movaps C2, 0x10+C_OFFSET_47(C)
  movaps C3, 0x20+C_OFFSET_47(C)
  movaps C4, 0x30+C_OFFSET_47(C)

  .align 16
block_255:

  # Check norm of product A(4,7)*B(7,8).
  movss 0x90(multiply_stream, base_pointer), B1
  mulss 0x1f4(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_256

  # Reset C(4,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,8) = A(4,7)*B(7,8).
  movaps 0x0+B_OFFSET_78(B), B1
  movaps 0x10+B_OFFSET_78(B), B2
  movaps 0x20+B_OFFSET_78(B), B3
  movaps 0x30+B_OFFSET_78(B), B4
  movaps 0x0+A_OFFSET_47(A), A11
  movaps 0x10+A_OFFSET_47(A), A12
  movaps 0x20+A_OFFSET_47(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_47(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_47(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_47(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_47(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_47(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_47(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_47(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_47(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_47(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_47(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_47(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_47(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_47(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,8) to already existing.
  addps 0x0+C_OFFSET_48(C), C1
  addps 0x10+C_OFFSET_48(C), C2
  addps 0x20+C_OFFSET_48(C), C3
  addps 0x30+C_OFFSET_48(C), C4

  # Write out C(4,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_48(C)
  movaps C2, 0x10+C_OFFSET_48(C)
  movaps C3, 0x20+C_OFFSET_48(C)
  movaps C4, 0x30+C_OFFSET_48(C)

  .align 16
block_256:

  # Check norm of product A(4,8)*B(8,8).
  movss 0x94(multiply_stream, base_pointer), B1
  mulss 0x214(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_257

  # Reset C(4,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(4,8) = A(4,8)*B(8,8).
  movaps 0x0+B_OFFSET_88(B), B1
  movaps 0x10+B_OFFSET_88(B), B2
  movaps 0x20+B_OFFSET_88(B), B3
  movaps 0x30+B_OFFSET_88(B), B4
  movaps 0x0+A_OFFSET_48(A), A11
  movaps 0x10+A_OFFSET_48(A), A12
  movaps 0x20+A_OFFSET_48(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_48(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_48(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_48(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_48(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_48(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_48(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_48(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_48(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_48(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_48(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_48(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_48(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_48(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(4,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(4,8) to already existing.
  addps 0x0+C_OFFSET_48(C), C1
  addps 0x10+C_OFFSET_48(C), C2
  addps 0x20+C_OFFSET_48(C), C3
  addps 0x30+C_OFFSET_48(C), C4

  # Write out C(4,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_48(C)
  movaps C2, 0x10+C_OFFSET_48(C)
  movaps C3, 0x20+C_OFFSET_48(C)
  movaps C4, 0x30+C_OFFSET_48(C)

  .align 16
block_257:

  # Check norm of product A(5,1)*B(1,1).
  movss 0x98(multiply_stream, base_pointer), B1
  mulss 0x118(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_258

  # Reset C(5,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,1) = A(5,1)*B(1,1).
  movaps 0x0+B_OFFSET_11(B), B1
  movaps 0x10+B_OFFSET_11(B), B2
  movaps 0x20+B_OFFSET_11(B), B3
  movaps 0x30+B_OFFSET_11(B), B4
  movaps 0x0+A_OFFSET_51(A), A11
  movaps 0x10+A_OFFSET_51(A), A12
  movaps 0x20+A_OFFSET_51(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_51(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_51(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_51(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_51(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_51(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_51(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_51(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_51(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_51(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_51(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_51(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_51(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_51(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,1) to already existing.
  addps 0x0+C_OFFSET_51(C), C1
  addps 0x10+C_OFFSET_51(C), C2
  addps 0x20+C_OFFSET_51(C), C3
  addps 0x30+C_OFFSET_51(C), C4

  # Write out C(5,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_51(C)
  movaps C2, 0x10+C_OFFSET_51(C)
  movaps C3, 0x20+C_OFFSET_51(C)
  movaps C4, 0x30+C_OFFSET_51(C)

  .align 16
block_258:

  # Check norm of product A(5,2)*B(2,1).
  movss 0x9c(multiply_stream, base_pointer), B1
  mulss 0x138(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_259

  # Reset C(5,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,1) = A(5,2)*B(2,1).
  movaps 0x0+B_OFFSET_21(B), B1
  movaps 0x10+B_OFFSET_21(B), B2
  movaps 0x20+B_OFFSET_21(B), B3
  movaps 0x30+B_OFFSET_21(B), B4
  movaps 0x0+A_OFFSET_52(A), A11
  movaps 0x10+A_OFFSET_52(A), A12
  movaps 0x20+A_OFFSET_52(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_52(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_52(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_52(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_52(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_52(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_52(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_52(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_52(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_52(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_52(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_52(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_52(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_52(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,1) to already existing.
  addps 0x0+C_OFFSET_51(C), C1
  addps 0x10+C_OFFSET_51(C), C2
  addps 0x20+C_OFFSET_51(C), C3
  addps 0x30+C_OFFSET_51(C), C4

  # Write out C(5,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_51(C)
  movaps C2, 0x10+C_OFFSET_51(C)
  movaps C3, 0x20+C_OFFSET_51(C)
  movaps C4, 0x30+C_OFFSET_51(C)

  .align 16
block_259:

  # Check norm of product A(5,1)*B(1,2).
  movss 0x98(multiply_stream, base_pointer), B1
  mulss 0x11c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_260

  # Reset C(5,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,2) = A(5,1)*B(1,2).
  movaps 0x0+B_OFFSET_12(B), B1
  movaps 0x10+B_OFFSET_12(B), B2
  movaps 0x20+B_OFFSET_12(B), B3
  movaps 0x30+B_OFFSET_12(B), B4
  movaps 0x0+A_OFFSET_51(A), A11
  movaps 0x10+A_OFFSET_51(A), A12
  movaps 0x20+A_OFFSET_51(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_51(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_51(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_51(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_51(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_51(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_51(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_51(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_51(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_51(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_51(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_51(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_51(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_51(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,2) to already existing.
  addps 0x0+C_OFFSET_52(C), C1
  addps 0x10+C_OFFSET_52(C), C2
  addps 0x20+C_OFFSET_52(C), C3
  addps 0x30+C_OFFSET_52(C), C4

  # Write out C(5,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_52(C)
  movaps C2, 0x10+C_OFFSET_52(C)
  movaps C3, 0x20+C_OFFSET_52(C)
  movaps C4, 0x30+C_OFFSET_52(C)

  .align 16
block_260:

  # Check norm of product A(5,2)*B(2,2).
  movss 0x9c(multiply_stream, base_pointer), B1
  mulss 0x13c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_261

  # Reset C(5,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,2) = A(5,2)*B(2,2).
  movaps 0x0+B_OFFSET_22(B), B1
  movaps 0x10+B_OFFSET_22(B), B2
  movaps 0x20+B_OFFSET_22(B), B3
  movaps 0x30+B_OFFSET_22(B), B4
  movaps 0x0+A_OFFSET_52(A), A11
  movaps 0x10+A_OFFSET_52(A), A12
  movaps 0x20+A_OFFSET_52(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_52(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_52(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_52(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_52(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_52(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_52(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_52(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_52(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_52(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_52(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_52(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_52(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_52(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,2) to already existing.
  addps 0x0+C_OFFSET_52(C), C1
  addps 0x10+C_OFFSET_52(C), C2
  addps 0x20+C_OFFSET_52(C), C3
  addps 0x30+C_OFFSET_52(C), C4

  # Write out C(5,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_52(C)
  movaps C2, 0x10+C_OFFSET_52(C)
  movaps C3, 0x20+C_OFFSET_52(C)
  movaps C4, 0x30+C_OFFSET_52(C)

  .align 16
block_261:

  # Check norm of product A(6,1)*B(1,1).
  movss 0xb8(multiply_stream, base_pointer), B1
  mulss 0x118(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_262

  # Reset C(6,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,1) = A(6,1)*B(1,1).
  movaps 0x0+B_OFFSET_11(B), B1
  movaps 0x10+B_OFFSET_11(B), B2
  movaps 0x20+B_OFFSET_11(B), B3
  movaps 0x30+B_OFFSET_11(B), B4
  movaps 0x0+A_OFFSET_61(A), A11
  movaps 0x10+A_OFFSET_61(A), A12
  movaps 0x20+A_OFFSET_61(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_61(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_61(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_61(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_61(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_61(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_61(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_61(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_61(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_61(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_61(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_61(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_61(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_61(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,1) to already existing.
  addps 0x0+C_OFFSET_61(C), C1
  addps 0x10+C_OFFSET_61(C), C2
  addps 0x20+C_OFFSET_61(C), C3
  addps 0x30+C_OFFSET_61(C), C4

  # Write out C(6,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_61(C)
  movaps C2, 0x10+C_OFFSET_61(C)
  movaps C3, 0x20+C_OFFSET_61(C)
  movaps C4, 0x30+C_OFFSET_61(C)

  .align 16
block_262:

  # Check norm of product A(6,2)*B(2,1).
  movss 0xbc(multiply_stream, base_pointer), B1
  mulss 0x138(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_263

  # Reset C(6,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,1) = A(6,2)*B(2,1).
  movaps 0x0+B_OFFSET_21(B), B1
  movaps 0x10+B_OFFSET_21(B), B2
  movaps 0x20+B_OFFSET_21(B), B3
  movaps 0x30+B_OFFSET_21(B), B4
  movaps 0x0+A_OFFSET_62(A), A11
  movaps 0x10+A_OFFSET_62(A), A12
  movaps 0x20+A_OFFSET_62(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_62(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_62(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_62(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_62(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_62(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_62(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_62(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_62(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_62(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_62(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_62(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_62(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_62(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,1) to already existing.
  addps 0x0+C_OFFSET_61(C), C1
  addps 0x10+C_OFFSET_61(C), C2
  addps 0x20+C_OFFSET_61(C), C3
  addps 0x30+C_OFFSET_61(C), C4

  # Write out C(6,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_61(C)
  movaps C2, 0x10+C_OFFSET_61(C)
  movaps C3, 0x20+C_OFFSET_61(C)
  movaps C4, 0x30+C_OFFSET_61(C)

  .align 16
block_263:

  # Check norm of product A(6,1)*B(1,2).
  movss 0xb8(multiply_stream, base_pointer), B1
  mulss 0x11c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_264

  # Reset C(6,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,2) = A(6,1)*B(1,2).
  movaps 0x0+B_OFFSET_12(B), B1
  movaps 0x10+B_OFFSET_12(B), B2
  movaps 0x20+B_OFFSET_12(B), B3
  movaps 0x30+B_OFFSET_12(B), B4
  movaps 0x0+A_OFFSET_61(A), A11
  movaps 0x10+A_OFFSET_61(A), A12
  movaps 0x20+A_OFFSET_61(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_61(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_61(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_61(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_61(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_61(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_61(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_61(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_61(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_61(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_61(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_61(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_61(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_61(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,2) to already existing.
  addps 0x0+C_OFFSET_62(C), C1
  addps 0x10+C_OFFSET_62(C), C2
  addps 0x20+C_OFFSET_62(C), C3
  addps 0x30+C_OFFSET_62(C), C4

  # Write out C(6,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_62(C)
  movaps C2, 0x10+C_OFFSET_62(C)
  movaps C3, 0x20+C_OFFSET_62(C)
  movaps C4, 0x30+C_OFFSET_62(C)

  .align 16
block_264:

  # Check norm of product A(6,2)*B(2,2).
  movss 0xbc(multiply_stream, base_pointer), B1
  mulss 0x13c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_265

  # Reset C(6,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,2) = A(6,2)*B(2,2).
  movaps 0x0+B_OFFSET_22(B), B1
  movaps 0x10+B_OFFSET_22(B), B2
  movaps 0x20+B_OFFSET_22(B), B3
  movaps 0x30+B_OFFSET_22(B), B4
  movaps 0x0+A_OFFSET_62(A), A11
  movaps 0x10+A_OFFSET_62(A), A12
  movaps 0x20+A_OFFSET_62(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_62(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_62(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_62(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_62(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_62(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_62(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_62(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_62(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_62(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_62(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_62(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_62(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_62(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,2) to already existing.
  addps 0x0+C_OFFSET_62(C), C1
  addps 0x10+C_OFFSET_62(C), C2
  addps 0x20+C_OFFSET_62(C), C3
  addps 0x30+C_OFFSET_62(C), C4

  # Write out C(6,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_62(C)
  movaps C2, 0x10+C_OFFSET_62(C)
  movaps C3, 0x20+C_OFFSET_62(C)
  movaps C4, 0x30+C_OFFSET_62(C)

  .align 16
block_265:

  # Check norm of product A(5,3)*B(3,1).
  movss 0xa0(multiply_stream, base_pointer), B1
  mulss 0x158(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_266

  # Reset C(5,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,1) = A(5,3)*B(3,1).
  movaps 0x0+B_OFFSET_31(B), B1
  movaps 0x10+B_OFFSET_31(B), B2
  movaps 0x20+B_OFFSET_31(B), B3
  movaps 0x30+B_OFFSET_31(B), B4
  movaps 0x0+A_OFFSET_53(A), A11
  movaps 0x10+A_OFFSET_53(A), A12
  movaps 0x20+A_OFFSET_53(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_53(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_53(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_53(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_53(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_53(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_53(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_53(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_53(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_53(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_53(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_53(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_53(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_53(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,1) to already existing.
  addps 0x0+C_OFFSET_51(C), C1
  addps 0x10+C_OFFSET_51(C), C2
  addps 0x20+C_OFFSET_51(C), C3
  addps 0x30+C_OFFSET_51(C), C4

  # Write out C(5,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_51(C)
  movaps C2, 0x10+C_OFFSET_51(C)
  movaps C3, 0x20+C_OFFSET_51(C)
  movaps C4, 0x30+C_OFFSET_51(C)

  .align 16
block_266:

  # Check norm of product A(5,4)*B(4,1).
  movss 0xa4(multiply_stream, base_pointer), B1
  mulss 0x178(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_267

  # Reset C(5,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,1) = A(5,4)*B(4,1).
  movaps 0x0+B_OFFSET_41(B), B1
  movaps 0x10+B_OFFSET_41(B), B2
  movaps 0x20+B_OFFSET_41(B), B3
  movaps 0x30+B_OFFSET_41(B), B4
  movaps 0x0+A_OFFSET_54(A), A11
  movaps 0x10+A_OFFSET_54(A), A12
  movaps 0x20+A_OFFSET_54(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_54(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_54(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_54(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_54(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_54(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_54(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_54(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_54(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_54(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_54(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_54(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_54(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_54(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,1) to already existing.
  addps 0x0+C_OFFSET_51(C), C1
  addps 0x10+C_OFFSET_51(C), C2
  addps 0x20+C_OFFSET_51(C), C3
  addps 0x30+C_OFFSET_51(C), C4

  # Write out C(5,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_51(C)
  movaps C2, 0x10+C_OFFSET_51(C)
  movaps C3, 0x20+C_OFFSET_51(C)
  movaps C4, 0x30+C_OFFSET_51(C)

  .align 16
block_267:

  # Check norm of product A(5,3)*B(3,2).
  movss 0xa0(multiply_stream, base_pointer), B1
  mulss 0x15c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_268

  # Reset C(5,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,2) = A(5,3)*B(3,2).
  movaps 0x0+B_OFFSET_32(B), B1
  movaps 0x10+B_OFFSET_32(B), B2
  movaps 0x20+B_OFFSET_32(B), B3
  movaps 0x30+B_OFFSET_32(B), B4
  movaps 0x0+A_OFFSET_53(A), A11
  movaps 0x10+A_OFFSET_53(A), A12
  movaps 0x20+A_OFFSET_53(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_53(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_53(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_53(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_53(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_53(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_53(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_53(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_53(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_53(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_53(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_53(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_53(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_53(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,2) to already existing.
  addps 0x0+C_OFFSET_52(C), C1
  addps 0x10+C_OFFSET_52(C), C2
  addps 0x20+C_OFFSET_52(C), C3
  addps 0x30+C_OFFSET_52(C), C4

  # Write out C(5,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_52(C)
  movaps C2, 0x10+C_OFFSET_52(C)
  movaps C3, 0x20+C_OFFSET_52(C)
  movaps C4, 0x30+C_OFFSET_52(C)

  .align 16
block_268:

  # Check norm of product A(5,4)*B(4,2).
  movss 0xa4(multiply_stream, base_pointer), B1
  mulss 0x17c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_269

  # Reset C(5,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,2) = A(5,4)*B(4,2).
  movaps 0x0+B_OFFSET_42(B), B1
  movaps 0x10+B_OFFSET_42(B), B2
  movaps 0x20+B_OFFSET_42(B), B3
  movaps 0x30+B_OFFSET_42(B), B4
  movaps 0x0+A_OFFSET_54(A), A11
  movaps 0x10+A_OFFSET_54(A), A12
  movaps 0x20+A_OFFSET_54(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_54(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_54(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_54(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_54(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_54(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_54(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_54(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_54(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_54(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_54(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_54(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_54(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_54(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,2) to already existing.
  addps 0x0+C_OFFSET_52(C), C1
  addps 0x10+C_OFFSET_52(C), C2
  addps 0x20+C_OFFSET_52(C), C3
  addps 0x30+C_OFFSET_52(C), C4

  # Write out C(5,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_52(C)
  movaps C2, 0x10+C_OFFSET_52(C)
  movaps C3, 0x20+C_OFFSET_52(C)
  movaps C4, 0x30+C_OFFSET_52(C)

  .align 16
block_269:

  # Check norm of product A(6,3)*B(3,1).
  movss 0xc0(multiply_stream, base_pointer), B1
  mulss 0x158(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_270

  # Reset C(6,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,1) = A(6,3)*B(3,1).
  movaps 0x0+B_OFFSET_31(B), B1
  movaps 0x10+B_OFFSET_31(B), B2
  movaps 0x20+B_OFFSET_31(B), B3
  movaps 0x30+B_OFFSET_31(B), B4
  movaps 0x0+A_OFFSET_63(A), A11
  movaps 0x10+A_OFFSET_63(A), A12
  movaps 0x20+A_OFFSET_63(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_63(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_63(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_63(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_63(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_63(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_63(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_63(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_63(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_63(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_63(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_63(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_63(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_63(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,1) to already existing.
  addps 0x0+C_OFFSET_61(C), C1
  addps 0x10+C_OFFSET_61(C), C2
  addps 0x20+C_OFFSET_61(C), C3
  addps 0x30+C_OFFSET_61(C), C4

  # Write out C(6,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_61(C)
  movaps C2, 0x10+C_OFFSET_61(C)
  movaps C3, 0x20+C_OFFSET_61(C)
  movaps C4, 0x30+C_OFFSET_61(C)

  .align 16
block_270:

  # Check norm of product A(6,4)*B(4,1).
  movss 0xc4(multiply_stream, base_pointer), B1
  mulss 0x178(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_271

  # Reset C(6,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,1) = A(6,4)*B(4,1).
  movaps 0x0+B_OFFSET_41(B), B1
  movaps 0x10+B_OFFSET_41(B), B2
  movaps 0x20+B_OFFSET_41(B), B3
  movaps 0x30+B_OFFSET_41(B), B4
  movaps 0x0+A_OFFSET_64(A), A11
  movaps 0x10+A_OFFSET_64(A), A12
  movaps 0x20+A_OFFSET_64(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_64(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_64(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_64(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_64(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_64(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_64(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_64(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_64(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_64(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_64(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_64(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_64(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_64(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,1) to already existing.
  addps 0x0+C_OFFSET_61(C), C1
  addps 0x10+C_OFFSET_61(C), C2
  addps 0x20+C_OFFSET_61(C), C3
  addps 0x30+C_OFFSET_61(C), C4

  # Write out C(6,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_61(C)
  movaps C2, 0x10+C_OFFSET_61(C)
  movaps C3, 0x20+C_OFFSET_61(C)
  movaps C4, 0x30+C_OFFSET_61(C)

  .align 16
block_271:

  # Check norm of product A(6,3)*B(3,2).
  movss 0xc0(multiply_stream, base_pointer), B1
  mulss 0x15c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_272

  # Reset C(6,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,2) = A(6,3)*B(3,2).
  movaps 0x0+B_OFFSET_32(B), B1
  movaps 0x10+B_OFFSET_32(B), B2
  movaps 0x20+B_OFFSET_32(B), B3
  movaps 0x30+B_OFFSET_32(B), B4
  movaps 0x0+A_OFFSET_63(A), A11
  movaps 0x10+A_OFFSET_63(A), A12
  movaps 0x20+A_OFFSET_63(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_63(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_63(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_63(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_63(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_63(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_63(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_63(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_63(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_63(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_63(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_63(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_63(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_63(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,2) to already existing.
  addps 0x0+C_OFFSET_62(C), C1
  addps 0x10+C_OFFSET_62(C), C2
  addps 0x20+C_OFFSET_62(C), C3
  addps 0x30+C_OFFSET_62(C), C4

  # Write out C(6,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_62(C)
  movaps C2, 0x10+C_OFFSET_62(C)
  movaps C3, 0x20+C_OFFSET_62(C)
  movaps C4, 0x30+C_OFFSET_62(C)

  .align 16
block_272:

  # Check norm of product A(6,4)*B(4,2).
  movss 0xc4(multiply_stream, base_pointer), B1
  mulss 0x17c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_273

  # Reset C(6,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,2) = A(6,4)*B(4,2).
  movaps 0x0+B_OFFSET_42(B), B1
  movaps 0x10+B_OFFSET_42(B), B2
  movaps 0x20+B_OFFSET_42(B), B3
  movaps 0x30+B_OFFSET_42(B), B4
  movaps 0x0+A_OFFSET_64(A), A11
  movaps 0x10+A_OFFSET_64(A), A12
  movaps 0x20+A_OFFSET_64(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_64(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_64(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_64(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_64(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_64(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_64(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_64(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_64(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_64(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_64(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_64(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_64(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_64(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,2) to already existing.
  addps 0x0+C_OFFSET_62(C), C1
  addps 0x10+C_OFFSET_62(C), C2
  addps 0x20+C_OFFSET_62(C), C3
  addps 0x30+C_OFFSET_62(C), C4

  # Write out C(6,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_62(C)
  movaps C2, 0x10+C_OFFSET_62(C)
  movaps C3, 0x20+C_OFFSET_62(C)
  movaps C4, 0x30+C_OFFSET_62(C)

  .align 16
block_273:

  # Check norm of product A(5,1)*B(1,3).
  movss 0x98(multiply_stream, base_pointer), B1
  mulss 0x120(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_274

  # Reset C(5,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,3) = A(5,1)*B(1,3).
  movaps 0x0+B_OFFSET_13(B), B1
  movaps 0x10+B_OFFSET_13(B), B2
  movaps 0x20+B_OFFSET_13(B), B3
  movaps 0x30+B_OFFSET_13(B), B4
  movaps 0x0+A_OFFSET_51(A), A11
  movaps 0x10+A_OFFSET_51(A), A12
  movaps 0x20+A_OFFSET_51(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_51(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_51(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_51(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_51(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_51(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_51(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_51(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_51(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_51(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_51(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_51(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_51(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_51(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,3) to already existing.
  addps 0x0+C_OFFSET_53(C), C1
  addps 0x10+C_OFFSET_53(C), C2
  addps 0x20+C_OFFSET_53(C), C3
  addps 0x30+C_OFFSET_53(C), C4

  # Write out C(5,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_53(C)
  movaps C2, 0x10+C_OFFSET_53(C)
  movaps C3, 0x20+C_OFFSET_53(C)
  movaps C4, 0x30+C_OFFSET_53(C)

  .align 16
block_274:

  # Check norm of product A(5,2)*B(2,3).
  movss 0x9c(multiply_stream, base_pointer), B1
  mulss 0x140(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_275

  # Reset C(5,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,3) = A(5,2)*B(2,3).
  movaps 0x0+B_OFFSET_23(B), B1
  movaps 0x10+B_OFFSET_23(B), B2
  movaps 0x20+B_OFFSET_23(B), B3
  movaps 0x30+B_OFFSET_23(B), B4
  movaps 0x0+A_OFFSET_52(A), A11
  movaps 0x10+A_OFFSET_52(A), A12
  movaps 0x20+A_OFFSET_52(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_52(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_52(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_52(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_52(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_52(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_52(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_52(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_52(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_52(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_52(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_52(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_52(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_52(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,3) to already existing.
  addps 0x0+C_OFFSET_53(C), C1
  addps 0x10+C_OFFSET_53(C), C2
  addps 0x20+C_OFFSET_53(C), C3
  addps 0x30+C_OFFSET_53(C), C4

  # Write out C(5,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_53(C)
  movaps C2, 0x10+C_OFFSET_53(C)
  movaps C3, 0x20+C_OFFSET_53(C)
  movaps C4, 0x30+C_OFFSET_53(C)

  .align 16
block_275:

  # Check norm of product A(5,1)*B(1,4).
  movss 0x98(multiply_stream, base_pointer), B1
  mulss 0x124(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_276

  # Reset C(5,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,4) = A(5,1)*B(1,4).
  movaps 0x0+B_OFFSET_14(B), B1
  movaps 0x10+B_OFFSET_14(B), B2
  movaps 0x20+B_OFFSET_14(B), B3
  movaps 0x30+B_OFFSET_14(B), B4
  movaps 0x0+A_OFFSET_51(A), A11
  movaps 0x10+A_OFFSET_51(A), A12
  movaps 0x20+A_OFFSET_51(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_51(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_51(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_51(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_51(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_51(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_51(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_51(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_51(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_51(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_51(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_51(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_51(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_51(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,4) to already existing.
  addps 0x0+C_OFFSET_54(C), C1
  addps 0x10+C_OFFSET_54(C), C2
  addps 0x20+C_OFFSET_54(C), C3
  addps 0x30+C_OFFSET_54(C), C4

  # Write out C(5,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_54(C)
  movaps C2, 0x10+C_OFFSET_54(C)
  movaps C3, 0x20+C_OFFSET_54(C)
  movaps C4, 0x30+C_OFFSET_54(C)

  .align 16
block_276:

  # Check norm of product A(5,2)*B(2,4).
  movss 0x9c(multiply_stream, base_pointer), B1
  mulss 0x144(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_277

  # Reset C(5,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,4) = A(5,2)*B(2,4).
  movaps 0x0+B_OFFSET_24(B), B1
  movaps 0x10+B_OFFSET_24(B), B2
  movaps 0x20+B_OFFSET_24(B), B3
  movaps 0x30+B_OFFSET_24(B), B4
  movaps 0x0+A_OFFSET_52(A), A11
  movaps 0x10+A_OFFSET_52(A), A12
  movaps 0x20+A_OFFSET_52(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_52(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_52(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_52(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_52(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_52(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_52(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_52(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_52(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_52(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_52(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_52(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_52(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_52(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,4) to already existing.
  addps 0x0+C_OFFSET_54(C), C1
  addps 0x10+C_OFFSET_54(C), C2
  addps 0x20+C_OFFSET_54(C), C3
  addps 0x30+C_OFFSET_54(C), C4

  # Write out C(5,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_54(C)
  movaps C2, 0x10+C_OFFSET_54(C)
  movaps C3, 0x20+C_OFFSET_54(C)
  movaps C4, 0x30+C_OFFSET_54(C)

  .align 16
block_277:

  # Check norm of product A(6,1)*B(1,3).
  movss 0xb8(multiply_stream, base_pointer), B1
  mulss 0x120(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_278

  # Reset C(6,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,3) = A(6,1)*B(1,3).
  movaps 0x0+B_OFFSET_13(B), B1
  movaps 0x10+B_OFFSET_13(B), B2
  movaps 0x20+B_OFFSET_13(B), B3
  movaps 0x30+B_OFFSET_13(B), B4
  movaps 0x0+A_OFFSET_61(A), A11
  movaps 0x10+A_OFFSET_61(A), A12
  movaps 0x20+A_OFFSET_61(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_61(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_61(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_61(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_61(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_61(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_61(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_61(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_61(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_61(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_61(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_61(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_61(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_61(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,3) to already existing.
  addps 0x0+C_OFFSET_63(C), C1
  addps 0x10+C_OFFSET_63(C), C2
  addps 0x20+C_OFFSET_63(C), C3
  addps 0x30+C_OFFSET_63(C), C4

  # Write out C(6,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_63(C)
  movaps C2, 0x10+C_OFFSET_63(C)
  movaps C3, 0x20+C_OFFSET_63(C)
  movaps C4, 0x30+C_OFFSET_63(C)

  .align 16
block_278:

  # Check norm of product A(6,2)*B(2,3).
  movss 0xbc(multiply_stream, base_pointer), B1
  mulss 0x140(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_279

  # Reset C(6,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,3) = A(6,2)*B(2,3).
  movaps 0x0+B_OFFSET_23(B), B1
  movaps 0x10+B_OFFSET_23(B), B2
  movaps 0x20+B_OFFSET_23(B), B3
  movaps 0x30+B_OFFSET_23(B), B4
  movaps 0x0+A_OFFSET_62(A), A11
  movaps 0x10+A_OFFSET_62(A), A12
  movaps 0x20+A_OFFSET_62(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_62(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_62(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_62(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_62(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_62(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_62(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_62(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_62(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_62(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_62(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_62(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_62(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_62(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,3) to already existing.
  addps 0x0+C_OFFSET_63(C), C1
  addps 0x10+C_OFFSET_63(C), C2
  addps 0x20+C_OFFSET_63(C), C3
  addps 0x30+C_OFFSET_63(C), C4

  # Write out C(6,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_63(C)
  movaps C2, 0x10+C_OFFSET_63(C)
  movaps C3, 0x20+C_OFFSET_63(C)
  movaps C4, 0x30+C_OFFSET_63(C)

  .align 16
block_279:

  # Check norm of product A(6,1)*B(1,4).
  movss 0xb8(multiply_stream, base_pointer), B1
  mulss 0x124(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_280

  # Reset C(6,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,4) = A(6,1)*B(1,4).
  movaps 0x0+B_OFFSET_14(B), B1
  movaps 0x10+B_OFFSET_14(B), B2
  movaps 0x20+B_OFFSET_14(B), B3
  movaps 0x30+B_OFFSET_14(B), B4
  movaps 0x0+A_OFFSET_61(A), A11
  movaps 0x10+A_OFFSET_61(A), A12
  movaps 0x20+A_OFFSET_61(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_61(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_61(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_61(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_61(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_61(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_61(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_61(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_61(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_61(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_61(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_61(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_61(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_61(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,4) to already existing.
  addps 0x0+C_OFFSET_64(C), C1
  addps 0x10+C_OFFSET_64(C), C2
  addps 0x20+C_OFFSET_64(C), C3
  addps 0x30+C_OFFSET_64(C), C4

  # Write out C(6,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_64(C)
  movaps C2, 0x10+C_OFFSET_64(C)
  movaps C3, 0x20+C_OFFSET_64(C)
  movaps C4, 0x30+C_OFFSET_64(C)

  .align 16
block_280:

  # Check norm of product A(6,2)*B(2,4).
  movss 0xbc(multiply_stream, base_pointer), B1
  mulss 0x144(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_281

  # Reset C(6,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,4) = A(6,2)*B(2,4).
  movaps 0x0+B_OFFSET_24(B), B1
  movaps 0x10+B_OFFSET_24(B), B2
  movaps 0x20+B_OFFSET_24(B), B3
  movaps 0x30+B_OFFSET_24(B), B4
  movaps 0x0+A_OFFSET_62(A), A11
  movaps 0x10+A_OFFSET_62(A), A12
  movaps 0x20+A_OFFSET_62(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_62(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_62(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_62(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_62(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_62(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_62(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_62(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_62(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_62(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_62(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_62(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_62(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_62(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,4) to already existing.
  addps 0x0+C_OFFSET_64(C), C1
  addps 0x10+C_OFFSET_64(C), C2
  addps 0x20+C_OFFSET_64(C), C3
  addps 0x30+C_OFFSET_64(C), C4

  # Write out C(6,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_64(C)
  movaps C2, 0x10+C_OFFSET_64(C)
  movaps C3, 0x20+C_OFFSET_64(C)
  movaps C4, 0x30+C_OFFSET_64(C)

  .align 16
block_281:

  # Check norm of product A(5,3)*B(3,3).
  movss 0xa0(multiply_stream, base_pointer), B1
  mulss 0x160(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_282

  # Reset C(5,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,3) = A(5,3)*B(3,3).
  movaps 0x0+B_OFFSET_33(B), B1
  movaps 0x10+B_OFFSET_33(B), B2
  movaps 0x20+B_OFFSET_33(B), B3
  movaps 0x30+B_OFFSET_33(B), B4
  movaps 0x0+A_OFFSET_53(A), A11
  movaps 0x10+A_OFFSET_53(A), A12
  movaps 0x20+A_OFFSET_53(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_53(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_53(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_53(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_53(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_53(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_53(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_53(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_53(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_53(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_53(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_53(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_53(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_53(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,3) to already existing.
  addps 0x0+C_OFFSET_53(C), C1
  addps 0x10+C_OFFSET_53(C), C2
  addps 0x20+C_OFFSET_53(C), C3
  addps 0x30+C_OFFSET_53(C), C4

  # Write out C(5,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_53(C)
  movaps C2, 0x10+C_OFFSET_53(C)
  movaps C3, 0x20+C_OFFSET_53(C)
  movaps C4, 0x30+C_OFFSET_53(C)

  .align 16
block_282:

  # Check norm of product A(5,4)*B(4,3).
  movss 0xa4(multiply_stream, base_pointer), B1
  mulss 0x180(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_283

  # Reset C(5,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,3) = A(5,4)*B(4,3).
  movaps 0x0+B_OFFSET_43(B), B1
  movaps 0x10+B_OFFSET_43(B), B2
  movaps 0x20+B_OFFSET_43(B), B3
  movaps 0x30+B_OFFSET_43(B), B4
  movaps 0x0+A_OFFSET_54(A), A11
  movaps 0x10+A_OFFSET_54(A), A12
  movaps 0x20+A_OFFSET_54(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_54(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_54(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_54(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_54(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_54(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_54(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_54(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_54(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_54(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_54(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_54(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_54(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_54(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,3) to already existing.
  addps 0x0+C_OFFSET_53(C), C1
  addps 0x10+C_OFFSET_53(C), C2
  addps 0x20+C_OFFSET_53(C), C3
  addps 0x30+C_OFFSET_53(C), C4

  # Write out C(5,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_53(C)
  movaps C2, 0x10+C_OFFSET_53(C)
  movaps C3, 0x20+C_OFFSET_53(C)
  movaps C4, 0x30+C_OFFSET_53(C)

  .align 16
block_283:

  # Check norm of product A(5,3)*B(3,4).
  movss 0xa0(multiply_stream, base_pointer), B1
  mulss 0x164(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_284

  # Reset C(5,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,4) = A(5,3)*B(3,4).
  movaps 0x0+B_OFFSET_34(B), B1
  movaps 0x10+B_OFFSET_34(B), B2
  movaps 0x20+B_OFFSET_34(B), B3
  movaps 0x30+B_OFFSET_34(B), B4
  movaps 0x0+A_OFFSET_53(A), A11
  movaps 0x10+A_OFFSET_53(A), A12
  movaps 0x20+A_OFFSET_53(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_53(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_53(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_53(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_53(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_53(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_53(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_53(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_53(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_53(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_53(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_53(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_53(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_53(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,4) to already existing.
  addps 0x0+C_OFFSET_54(C), C1
  addps 0x10+C_OFFSET_54(C), C2
  addps 0x20+C_OFFSET_54(C), C3
  addps 0x30+C_OFFSET_54(C), C4

  # Write out C(5,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_54(C)
  movaps C2, 0x10+C_OFFSET_54(C)
  movaps C3, 0x20+C_OFFSET_54(C)
  movaps C4, 0x30+C_OFFSET_54(C)

  .align 16
block_284:

  # Check norm of product A(5,4)*B(4,4).
  movss 0xa4(multiply_stream, base_pointer), B1
  mulss 0x184(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_285

  # Reset C(5,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,4) = A(5,4)*B(4,4).
  movaps 0x0+B_OFFSET_44(B), B1
  movaps 0x10+B_OFFSET_44(B), B2
  movaps 0x20+B_OFFSET_44(B), B3
  movaps 0x30+B_OFFSET_44(B), B4
  movaps 0x0+A_OFFSET_54(A), A11
  movaps 0x10+A_OFFSET_54(A), A12
  movaps 0x20+A_OFFSET_54(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_54(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_54(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_54(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_54(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_54(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_54(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_54(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_54(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_54(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_54(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_54(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_54(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_54(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,4) to already existing.
  addps 0x0+C_OFFSET_54(C), C1
  addps 0x10+C_OFFSET_54(C), C2
  addps 0x20+C_OFFSET_54(C), C3
  addps 0x30+C_OFFSET_54(C), C4

  # Write out C(5,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_54(C)
  movaps C2, 0x10+C_OFFSET_54(C)
  movaps C3, 0x20+C_OFFSET_54(C)
  movaps C4, 0x30+C_OFFSET_54(C)

  .align 16
block_285:

  # Check norm of product A(6,3)*B(3,3).
  movss 0xc0(multiply_stream, base_pointer), B1
  mulss 0x160(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_286

  # Reset C(6,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,3) = A(6,3)*B(3,3).
  movaps 0x0+B_OFFSET_33(B), B1
  movaps 0x10+B_OFFSET_33(B), B2
  movaps 0x20+B_OFFSET_33(B), B3
  movaps 0x30+B_OFFSET_33(B), B4
  movaps 0x0+A_OFFSET_63(A), A11
  movaps 0x10+A_OFFSET_63(A), A12
  movaps 0x20+A_OFFSET_63(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_63(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_63(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_63(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_63(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_63(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_63(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_63(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_63(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_63(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_63(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_63(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_63(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_63(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,3) to already existing.
  addps 0x0+C_OFFSET_63(C), C1
  addps 0x10+C_OFFSET_63(C), C2
  addps 0x20+C_OFFSET_63(C), C3
  addps 0x30+C_OFFSET_63(C), C4

  # Write out C(6,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_63(C)
  movaps C2, 0x10+C_OFFSET_63(C)
  movaps C3, 0x20+C_OFFSET_63(C)
  movaps C4, 0x30+C_OFFSET_63(C)

  .align 16
block_286:

  # Check norm of product A(6,4)*B(4,3).
  movss 0xc4(multiply_stream, base_pointer), B1
  mulss 0x180(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_287

  # Reset C(6,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,3) = A(6,4)*B(4,3).
  movaps 0x0+B_OFFSET_43(B), B1
  movaps 0x10+B_OFFSET_43(B), B2
  movaps 0x20+B_OFFSET_43(B), B3
  movaps 0x30+B_OFFSET_43(B), B4
  movaps 0x0+A_OFFSET_64(A), A11
  movaps 0x10+A_OFFSET_64(A), A12
  movaps 0x20+A_OFFSET_64(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_64(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_64(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_64(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_64(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_64(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_64(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_64(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_64(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_64(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_64(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_64(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_64(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_64(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,3) to already existing.
  addps 0x0+C_OFFSET_63(C), C1
  addps 0x10+C_OFFSET_63(C), C2
  addps 0x20+C_OFFSET_63(C), C3
  addps 0x30+C_OFFSET_63(C), C4

  # Write out C(6,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_63(C)
  movaps C2, 0x10+C_OFFSET_63(C)
  movaps C3, 0x20+C_OFFSET_63(C)
  movaps C4, 0x30+C_OFFSET_63(C)

  .align 16
block_287:

  # Check norm of product A(6,3)*B(3,4).
  movss 0xc0(multiply_stream, base_pointer), B1
  mulss 0x164(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_288

  # Reset C(6,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,4) = A(6,3)*B(3,4).
  movaps 0x0+B_OFFSET_34(B), B1
  movaps 0x10+B_OFFSET_34(B), B2
  movaps 0x20+B_OFFSET_34(B), B3
  movaps 0x30+B_OFFSET_34(B), B4
  movaps 0x0+A_OFFSET_63(A), A11
  movaps 0x10+A_OFFSET_63(A), A12
  movaps 0x20+A_OFFSET_63(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_63(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_63(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_63(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_63(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_63(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_63(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_63(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_63(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_63(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_63(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_63(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_63(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_63(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,4) to already existing.
  addps 0x0+C_OFFSET_64(C), C1
  addps 0x10+C_OFFSET_64(C), C2
  addps 0x20+C_OFFSET_64(C), C3
  addps 0x30+C_OFFSET_64(C), C4

  # Write out C(6,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_64(C)
  movaps C2, 0x10+C_OFFSET_64(C)
  movaps C3, 0x20+C_OFFSET_64(C)
  movaps C4, 0x30+C_OFFSET_64(C)

  .align 16
block_288:

  # Check norm of product A(6,4)*B(4,4).
  movss 0xc4(multiply_stream, base_pointer), B1
  mulss 0x184(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_289

  # Reset C(6,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,4) = A(6,4)*B(4,4).
  movaps 0x0+B_OFFSET_44(B), B1
  movaps 0x10+B_OFFSET_44(B), B2
  movaps 0x20+B_OFFSET_44(B), B3
  movaps 0x30+B_OFFSET_44(B), B4
  movaps 0x0+A_OFFSET_64(A), A11
  movaps 0x10+A_OFFSET_64(A), A12
  movaps 0x20+A_OFFSET_64(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_64(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_64(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_64(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_64(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_64(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_64(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_64(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_64(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_64(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_64(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_64(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_64(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_64(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,4) to already existing.
  addps 0x0+C_OFFSET_64(C), C1
  addps 0x10+C_OFFSET_64(C), C2
  addps 0x20+C_OFFSET_64(C), C3
  addps 0x30+C_OFFSET_64(C), C4

  # Write out C(6,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_64(C)
  movaps C2, 0x10+C_OFFSET_64(C)
  movaps C3, 0x20+C_OFFSET_64(C)
  movaps C4, 0x30+C_OFFSET_64(C)

  .align 16
block_289:

  # Check norm of product A(7,1)*B(1,1).
  movss 0xd8(multiply_stream, base_pointer), B1
  mulss 0x118(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_290

  # Reset C(7,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,1) = A(7,1)*B(1,1).
  movaps 0x0+B_OFFSET_11(B), B1
  movaps 0x10+B_OFFSET_11(B), B2
  movaps 0x20+B_OFFSET_11(B), B3
  movaps 0x30+B_OFFSET_11(B), B4
  movaps 0x0+A_OFFSET_71(A), A11
  movaps 0x10+A_OFFSET_71(A), A12
  movaps 0x20+A_OFFSET_71(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_71(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_71(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_71(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_71(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_71(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_71(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_71(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_71(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_71(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_71(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_71(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_71(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_71(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,1) to already existing.
  addps 0x0+C_OFFSET_71(C), C1
  addps 0x10+C_OFFSET_71(C), C2
  addps 0x20+C_OFFSET_71(C), C3
  addps 0x30+C_OFFSET_71(C), C4

  # Write out C(7,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_71(C)
  movaps C2, 0x10+C_OFFSET_71(C)
  movaps C3, 0x20+C_OFFSET_71(C)
  movaps C4, 0x30+C_OFFSET_71(C)

  .align 16
block_290:

  # Check norm of product A(7,2)*B(2,1).
  movss 0xdc(multiply_stream, base_pointer), B1
  mulss 0x138(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_291

  # Reset C(7,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,1) = A(7,2)*B(2,1).
  movaps 0x0+B_OFFSET_21(B), B1
  movaps 0x10+B_OFFSET_21(B), B2
  movaps 0x20+B_OFFSET_21(B), B3
  movaps 0x30+B_OFFSET_21(B), B4
  movaps 0x0+A_OFFSET_72(A), A11
  movaps 0x10+A_OFFSET_72(A), A12
  movaps 0x20+A_OFFSET_72(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_72(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_72(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_72(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_72(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_72(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_72(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_72(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_72(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_72(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_72(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_72(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_72(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_72(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,1) to already existing.
  addps 0x0+C_OFFSET_71(C), C1
  addps 0x10+C_OFFSET_71(C), C2
  addps 0x20+C_OFFSET_71(C), C3
  addps 0x30+C_OFFSET_71(C), C4

  # Write out C(7,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_71(C)
  movaps C2, 0x10+C_OFFSET_71(C)
  movaps C3, 0x20+C_OFFSET_71(C)
  movaps C4, 0x30+C_OFFSET_71(C)

  .align 16
block_291:

  # Check norm of product A(7,1)*B(1,2).
  movss 0xd8(multiply_stream, base_pointer), B1
  mulss 0x11c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_292

  # Reset C(7,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,2) = A(7,1)*B(1,2).
  movaps 0x0+B_OFFSET_12(B), B1
  movaps 0x10+B_OFFSET_12(B), B2
  movaps 0x20+B_OFFSET_12(B), B3
  movaps 0x30+B_OFFSET_12(B), B4
  movaps 0x0+A_OFFSET_71(A), A11
  movaps 0x10+A_OFFSET_71(A), A12
  movaps 0x20+A_OFFSET_71(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_71(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_71(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_71(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_71(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_71(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_71(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_71(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_71(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_71(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_71(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_71(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_71(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_71(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,2) to already existing.
  addps 0x0+C_OFFSET_72(C), C1
  addps 0x10+C_OFFSET_72(C), C2
  addps 0x20+C_OFFSET_72(C), C3
  addps 0x30+C_OFFSET_72(C), C4

  # Write out C(7,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_72(C)
  movaps C2, 0x10+C_OFFSET_72(C)
  movaps C3, 0x20+C_OFFSET_72(C)
  movaps C4, 0x30+C_OFFSET_72(C)

  .align 16
block_292:

  # Check norm of product A(7,2)*B(2,2).
  movss 0xdc(multiply_stream, base_pointer), B1
  mulss 0x13c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_293

  # Reset C(7,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,2) = A(7,2)*B(2,2).
  movaps 0x0+B_OFFSET_22(B), B1
  movaps 0x10+B_OFFSET_22(B), B2
  movaps 0x20+B_OFFSET_22(B), B3
  movaps 0x30+B_OFFSET_22(B), B4
  movaps 0x0+A_OFFSET_72(A), A11
  movaps 0x10+A_OFFSET_72(A), A12
  movaps 0x20+A_OFFSET_72(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_72(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_72(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_72(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_72(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_72(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_72(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_72(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_72(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_72(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_72(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_72(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_72(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_72(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,2) to already existing.
  addps 0x0+C_OFFSET_72(C), C1
  addps 0x10+C_OFFSET_72(C), C2
  addps 0x20+C_OFFSET_72(C), C3
  addps 0x30+C_OFFSET_72(C), C4

  # Write out C(7,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_72(C)
  movaps C2, 0x10+C_OFFSET_72(C)
  movaps C3, 0x20+C_OFFSET_72(C)
  movaps C4, 0x30+C_OFFSET_72(C)

  .align 16
block_293:

  # Check norm of product A(8,1)*B(1,1).
  movss 0xf8(multiply_stream, base_pointer), B1
  mulss 0x118(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_294

  # Reset C(8,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,1) = A(8,1)*B(1,1).
  movaps 0x0+B_OFFSET_11(B), B1
  movaps 0x10+B_OFFSET_11(B), B2
  movaps 0x20+B_OFFSET_11(B), B3
  movaps 0x30+B_OFFSET_11(B), B4
  movaps 0x0+A_OFFSET_81(A), A11
  movaps 0x10+A_OFFSET_81(A), A12
  movaps 0x20+A_OFFSET_81(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_81(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_81(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_81(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_81(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_81(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_81(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_81(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_81(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_81(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_81(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_81(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_81(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_81(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,1) to already existing.
  addps 0x0+C_OFFSET_81(C), C1
  addps 0x10+C_OFFSET_81(C), C2
  addps 0x20+C_OFFSET_81(C), C3
  addps 0x30+C_OFFSET_81(C), C4

  # Write out C(8,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_81(C)
  movaps C2, 0x10+C_OFFSET_81(C)
  movaps C3, 0x20+C_OFFSET_81(C)
  movaps C4, 0x30+C_OFFSET_81(C)

  .align 16
block_294:

  # Check norm of product A(8,2)*B(2,1).
  movss 0xfc(multiply_stream, base_pointer), B1
  mulss 0x138(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_295

  # Reset C(8,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,1) = A(8,2)*B(2,1).
  movaps 0x0+B_OFFSET_21(B), B1
  movaps 0x10+B_OFFSET_21(B), B2
  movaps 0x20+B_OFFSET_21(B), B3
  movaps 0x30+B_OFFSET_21(B), B4
  movaps 0x0+A_OFFSET_82(A), A11
  movaps 0x10+A_OFFSET_82(A), A12
  movaps 0x20+A_OFFSET_82(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_82(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_82(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_82(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_82(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_82(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_82(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_82(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_82(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_82(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_82(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_82(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_82(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_82(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,1) to already existing.
  addps 0x0+C_OFFSET_81(C), C1
  addps 0x10+C_OFFSET_81(C), C2
  addps 0x20+C_OFFSET_81(C), C3
  addps 0x30+C_OFFSET_81(C), C4

  # Write out C(8,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_81(C)
  movaps C2, 0x10+C_OFFSET_81(C)
  movaps C3, 0x20+C_OFFSET_81(C)
  movaps C4, 0x30+C_OFFSET_81(C)

  .align 16
block_295:

  # Check norm of product A(8,1)*B(1,2).
  movss 0xf8(multiply_stream, base_pointer), B1
  mulss 0x11c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_296

  # Reset C(8,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,2) = A(8,1)*B(1,2).
  movaps 0x0+B_OFFSET_12(B), B1
  movaps 0x10+B_OFFSET_12(B), B2
  movaps 0x20+B_OFFSET_12(B), B3
  movaps 0x30+B_OFFSET_12(B), B4
  movaps 0x0+A_OFFSET_81(A), A11
  movaps 0x10+A_OFFSET_81(A), A12
  movaps 0x20+A_OFFSET_81(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_81(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_81(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_81(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_81(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_81(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_81(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_81(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_81(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_81(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_81(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_81(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_81(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_81(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,2) to already existing.
  addps 0x0+C_OFFSET_82(C), C1
  addps 0x10+C_OFFSET_82(C), C2
  addps 0x20+C_OFFSET_82(C), C3
  addps 0x30+C_OFFSET_82(C), C4

  # Write out C(8,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_82(C)
  movaps C2, 0x10+C_OFFSET_82(C)
  movaps C3, 0x20+C_OFFSET_82(C)
  movaps C4, 0x30+C_OFFSET_82(C)

  .align 16
block_296:

  # Check norm of product A(8,2)*B(2,2).
  movss 0xfc(multiply_stream, base_pointer), B1
  mulss 0x13c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_297

  # Reset C(8,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,2) = A(8,2)*B(2,2).
  movaps 0x0+B_OFFSET_22(B), B1
  movaps 0x10+B_OFFSET_22(B), B2
  movaps 0x20+B_OFFSET_22(B), B3
  movaps 0x30+B_OFFSET_22(B), B4
  movaps 0x0+A_OFFSET_82(A), A11
  movaps 0x10+A_OFFSET_82(A), A12
  movaps 0x20+A_OFFSET_82(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_82(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_82(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_82(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_82(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_82(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_82(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_82(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_82(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_82(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_82(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_82(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_82(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_82(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,2) to already existing.
  addps 0x0+C_OFFSET_82(C), C1
  addps 0x10+C_OFFSET_82(C), C2
  addps 0x20+C_OFFSET_82(C), C3
  addps 0x30+C_OFFSET_82(C), C4

  # Write out C(8,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_82(C)
  movaps C2, 0x10+C_OFFSET_82(C)
  movaps C3, 0x20+C_OFFSET_82(C)
  movaps C4, 0x30+C_OFFSET_82(C)

  .align 16
block_297:

  # Check norm of product A(7,3)*B(3,1).
  movss 0xe0(multiply_stream, base_pointer), B1
  mulss 0x158(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_298

  # Reset C(7,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,1) = A(7,3)*B(3,1).
  movaps 0x0+B_OFFSET_31(B), B1
  movaps 0x10+B_OFFSET_31(B), B2
  movaps 0x20+B_OFFSET_31(B), B3
  movaps 0x30+B_OFFSET_31(B), B4
  movaps 0x0+A_OFFSET_73(A), A11
  movaps 0x10+A_OFFSET_73(A), A12
  movaps 0x20+A_OFFSET_73(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_73(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_73(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_73(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_73(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_73(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_73(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_73(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_73(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_73(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_73(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_73(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_73(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_73(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,1) to already existing.
  addps 0x0+C_OFFSET_71(C), C1
  addps 0x10+C_OFFSET_71(C), C2
  addps 0x20+C_OFFSET_71(C), C3
  addps 0x30+C_OFFSET_71(C), C4

  # Write out C(7,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_71(C)
  movaps C2, 0x10+C_OFFSET_71(C)
  movaps C3, 0x20+C_OFFSET_71(C)
  movaps C4, 0x30+C_OFFSET_71(C)

  .align 16
block_298:

  # Check norm of product A(7,4)*B(4,1).
  movss 0xe4(multiply_stream, base_pointer), B1
  mulss 0x178(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_299

  # Reset C(7,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,1) = A(7,4)*B(4,1).
  movaps 0x0+B_OFFSET_41(B), B1
  movaps 0x10+B_OFFSET_41(B), B2
  movaps 0x20+B_OFFSET_41(B), B3
  movaps 0x30+B_OFFSET_41(B), B4
  movaps 0x0+A_OFFSET_74(A), A11
  movaps 0x10+A_OFFSET_74(A), A12
  movaps 0x20+A_OFFSET_74(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_74(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_74(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_74(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_74(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_74(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_74(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_74(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_74(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_74(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_74(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_74(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_74(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_74(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,1) to already existing.
  addps 0x0+C_OFFSET_71(C), C1
  addps 0x10+C_OFFSET_71(C), C2
  addps 0x20+C_OFFSET_71(C), C3
  addps 0x30+C_OFFSET_71(C), C4

  # Write out C(7,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_71(C)
  movaps C2, 0x10+C_OFFSET_71(C)
  movaps C3, 0x20+C_OFFSET_71(C)
  movaps C4, 0x30+C_OFFSET_71(C)

  .align 16
block_299:

  # Check norm of product A(7,3)*B(3,2).
  movss 0xe0(multiply_stream, base_pointer), B1
  mulss 0x15c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_300

  # Reset C(7,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,2) = A(7,3)*B(3,2).
  movaps 0x0+B_OFFSET_32(B), B1
  movaps 0x10+B_OFFSET_32(B), B2
  movaps 0x20+B_OFFSET_32(B), B3
  movaps 0x30+B_OFFSET_32(B), B4
  movaps 0x0+A_OFFSET_73(A), A11
  movaps 0x10+A_OFFSET_73(A), A12
  movaps 0x20+A_OFFSET_73(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_73(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_73(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_73(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_73(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_73(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_73(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_73(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_73(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_73(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_73(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_73(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_73(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_73(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,2) to already existing.
  addps 0x0+C_OFFSET_72(C), C1
  addps 0x10+C_OFFSET_72(C), C2
  addps 0x20+C_OFFSET_72(C), C3
  addps 0x30+C_OFFSET_72(C), C4

  # Write out C(7,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_72(C)
  movaps C2, 0x10+C_OFFSET_72(C)
  movaps C3, 0x20+C_OFFSET_72(C)
  movaps C4, 0x30+C_OFFSET_72(C)

  .align 16
block_300:

  # Check norm of product A(7,4)*B(4,2).
  movss 0xe4(multiply_stream, base_pointer), B1
  mulss 0x17c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_301

  # Reset C(7,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,2) = A(7,4)*B(4,2).
  movaps 0x0+B_OFFSET_42(B), B1
  movaps 0x10+B_OFFSET_42(B), B2
  movaps 0x20+B_OFFSET_42(B), B3
  movaps 0x30+B_OFFSET_42(B), B4
  movaps 0x0+A_OFFSET_74(A), A11
  movaps 0x10+A_OFFSET_74(A), A12
  movaps 0x20+A_OFFSET_74(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_74(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_74(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_74(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_74(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_74(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_74(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_74(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_74(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_74(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_74(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_74(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_74(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_74(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,2) to already existing.
  addps 0x0+C_OFFSET_72(C), C1
  addps 0x10+C_OFFSET_72(C), C2
  addps 0x20+C_OFFSET_72(C), C3
  addps 0x30+C_OFFSET_72(C), C4

  # Write out C(7,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_72(C)
  movaps C2, 0x10+C_OFFSET_72(C)
  movaps C3, 0x20+C_OFFSET_72(C)
  movaps C4, 0x30+C_OFFSET_72(C)

  .align 16
block_301:

  # Check norm of product A(8,3)*B(3,1).
  movss 0x100(multiply_stream, base_pointer), B1
  mulss 0x158(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_302

  # Reset C(8,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,1) = A(8,3)*B(3,1).
  movaps 0x0+B_OFFSET_31(B), B1
  movaps 0x10+B_OFFSET_31(B), B2
  movaps 0x20+B_OFFSET_31(B), B3
  movaps 0x30+B_OFFSET_31(B), B4
  movaps 0x0+A_OFFSET_83(A), A11
  movaps 0x10+A_OFFSET_83(A), A12
  movaps 0x20+A_OFFSET_83(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_83(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_83(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_83(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_83(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_83(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_83(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_83(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_83(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_83(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_83(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_83(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_83(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_83(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,1) to already existing.
  addps 0x0+C_OFFSET_81(C), C1
  addps 0x10+C_OFFSET_81(C), C2
  addps 0x20+C_OFFSET_81(C), C3
  addps 0x30+C_OFFSET_81(C), C4

  # Write out C(8,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_81(C)
  movaps C2, 0x10+C_OFFSET_81(C)
  movaps C3, 0x20+C_OFFSET_81(C)
  movaps C4, 0x30+C_OFFSET_81(C)

  .align 16
block_302:

  # Check norm of product A(8,4)*B(4,1).
  movss 0x104(multiply_stream, base_pointer), B1
  mulss 0x178(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_303

  # Reset C(8,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,1) = A(8,4)*B(4,1).
  movaps 0x0+B_OFFSET_41(B), B1
  movaps 0x10+B_OFFSET_41(B), B2
  movaps 0x20+B_OFFSET_41(B), B3
  movaps 0x30+B_OFFSET_41(B), B4
  movaps 0x0+A_OFFSET_84(A), A11
  movaps 0x10+A_OFFSET_84(A), A12
  movaps 0x20+A_OFFSET_84(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_84(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_84(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_84(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_84(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_84(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_84(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_84(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_84(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_84(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_84(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_84(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_84(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_84(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,1) to already existing.
  addps 0x0+C_OFFSET_81(C), C1
  addps 0x10+C_OFFSET_81(C), C2
  addps 0x20+C_OFFSET_81(C), C3
  addps 0x30+C_OFFSET_81(C), C4

  # Write out C(8,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_81(C)
  movaps C2, 0x10+C_OFFSET_81(C)
  movaps C3, 0x20+C_OFFSET_81(C)
  movaps C4, 0x30+C_OFFSET_81(C)

  .align 16
block_303:

  # Check norm of product A(8,3)*B(3,2).
  movss 0x100(multiply_stream, base_pointer), B1
  mulss 0x15c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_304

  # Reset C(8,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,2) = A(8,3)*B(3,2).
  movaps 0x0+B_OFFSET_32(B), B1
  movaps 0x10+B_OFFSET_32(B), B2
  movaps 0x20+B_OFFSET_32(B), B3
  movaps 0x30+B_OFFSET_32(B), B4
  movaps 0x0+A_OFFSET_83(A), A11
  movaps 0x10+A_OFFSET_83(A), A12
  movaps 0x20+A_OFFSET_83(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_83(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_83(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_83(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_83(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_83(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_83(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_83(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_83(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_83(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_83(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_83(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_83(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_83(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,2) to already existing.
  addps 0x0+C_OFFSET_82(C), C1
  addps 0x10+C_OFFSET_82(C), C2
  addps 0x20+C_OFFSET_82(C), C3
  addps 0x30+C_OFFSET_82(C), C4

  # Write out C(8,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_82(C)
  movaps C2, 0x10+C_OFFSET_82(C)
  movaps C3, 0x20+C_OFFSET_82(C)
  movaps C4, 0x30+C_OFFSET_82(C)

  .align 16
block_304:

  # Check norm of product A(8,4)*B(4,2).
  movss 0x104(multiply_stream, base_pointer), B1
  mulss 0x17c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_305

  # Reset C(8,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,2) = A(8,4)*B(4,2).
  movaps 0x0+B_OFFSET_42(B), B1
  movaps 0x10+B_OFFSET_42(B), B2
  movaps 0x20+B_OFFSET_42(B), B3
  movaps 0x30+B_OFFSET_42(B), B4
  movaps 0x0+A_OFFSET_84(A), A11
  movaps 0x10+A_OFFSET_84(A), A12
  movaps 0x20+A_OFFSET_84(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_84(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_84(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_84(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_84(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_84(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_84(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_84(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_84(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_84(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_84(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_84(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_84(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_84(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,2) to already existing.
  addps 0x0+C_OFFSET_82(C), C1
  addps 0x10+C_OFFSET_82(C), C2
  addps 0x20+C_OFFSET_82(C), C3
  addps 0x30+C_OFFSET_82(C), C4

  # Write out C(8,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_82(C)
  movaps C2, 0x10+C_OFFSET_82(C)
  movaps C3, 0x20+C_OFFSET_82(C)
  movaps C4, 0x30+C_OFFSET_82(C)

  .align 16
block_305:

  # Check norm of product A(7,1)*B(1,3).
  movss 0xd8(multiply_stream, base_pointer), B1
  mulss 0x120(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_306

  # Reset C(7,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,3) = A(7,1)*B(1,3).
  movaps 0x0+B_OFFSET_13(B), B1
  movaps 0x10+B_OFFSET_13(B), B2
  movaps 0x20+B_OFFSET_13(B), B3
  movaps 0x30+B_OFFSET_13(B), B4
  movaps 0x0+A_OFFSET_71(A), A11
  movaps 0x10+A_OFFSET_71(A), A12
  movaps 0x20+A_OFFSET_71(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_71(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_71(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_71(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_71(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_71(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_71(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_71(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_71(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_71(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_71(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_71(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_71(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_71(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,3) to already existing.
  addps 0x0+C_OFFSET_73(C), C1
  addps 0x10+C_OFFSET_73(C), C2
  addps 0x20+C_OFFSET_73(C), C3
  addps 0x30+C_OFFSET_73(C), C4

  # Write out C(7,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_73(C)
  movaps C2, 0x10+C_OFFSET_73(C)
  movaps C3, 0x20+C_OFFSET_73(C)
  movaps C4, 0x30+C_OFFSET_73(C)

  .align 16
block_306:

  # Check norm of product A(7,2)*B(2,3).
  movss 0xdc(multiply_stream, base_pointer), B1
  mulss 0x140(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_307

  # Reset C(7,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,3) = A(7,2)*B(2,3).
  movaps 0x0+B_OFFSET_23(B), B1
  movaps 0x10+B_OFFSET_23(B), B2
  movaps 0x20+B_OFFSET_23(B), B3
  movaps 0x30+B_OFFSET_23(B), B4
  movaps 0x0+A_OFFSET_72(A), A11
  movaps 0x10+A_OFFSET_72(A), A12
  movaps 0x20+A_OFFSET_72(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_72(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_72(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_72(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_72(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_72(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_72(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_72(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_72(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_72(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_72(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_72(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_72(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_72(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,3) to already existing.
  addps 0x0+C_OFFSET_73(C), C1
  addps 0x10+C_OFFSET_73(C), C2
  addps 0x20+C_OFFSET_73(C), C3
  addps 0x30+C_OFFSET_73(C), C4

  # Write out C(7,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_73(C)
  movaps C2, 0x10+C_OFFSET_73(C)
  movaps C3, 0x20+C_OFFSET_73(C)
  movaps C4, 0x30+C_OFFSET_73(C)

  .align 16
block_307:

  # Check norm of product A(7,1)*B(1,4).
  movss 0xd8(multiply_stream, base_pointer), B1
  mulss 0x124(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_308

  # Reset C(7,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,4) = A(7,1)*B(1,4).
  movaps 0x0+B_OFFSET_14(B), B1
  movaps 0x10+B_OFFSET_14(B), B2
  movaps 0x20+B_OFFSET_14(B), B3
  movaps 0x30+B_OFFSET_14(B), B4
  movaps 0x0+A_OFFSET_71(A), A11
  movaps 0x10+A_OFFSET_71(A), A12
  movaps 0x20+A_OFFSET_71(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_71(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_71(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_71(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_71(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_71(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_71(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_71(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_71(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_71(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_71(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_71(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_71(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_71(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,4) to already existing.
  addps 0x0+C_OFFSET_74(C), C1
  addps 0x10+C_OFFSET_74(C), C2
  addps 0x20+C_OFFSET_74(C), C3
  addps 0x30+C_OFFSET_74(C), C4

  # Write out C(7,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_74(C)
  movaps C2, 0x10+C_OFFSET_74(C)
  movaps C3, 0x20+C_OFFSET_74(C)
  movaps C4, 0x30+C_OFFSET_74(C)

  .align 16
block_308:

  # Check norm of product A(7,2)*B(2,4).
  movss 0xdc(multiply_stream, base_pointer), B1
  mulss 0x144(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_309

  # Reset C(7,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,4) = A(7,2)*B(2,4).
  movaps 0x0+B_OFFSET_24(B), B1
  movaps 0x10+B_OFFSET_24(B), B2
  movaps 0x20+B_OFFSET_24(B), B3
  movaps 0x30+B_OFFSET_24(B), B4
  movaps 0x0+A_OFFSET_72(A), A11
  movaps 0x10+A_OFFSET_72(A), A12
  movaps 0x20+A_OFFSET_72(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_72(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_72(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_72(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_72(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_72(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_72(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_72(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_72(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_72(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_72(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_72(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_72(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_72(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,4) to already existing.
  addps 0x0+C_OFFSET_74(C), C1
  addps 0x10+C_OFFSET_74(C), C2
  addps 0x20+C_OFFSET_74(C), C3
  addps 0x30+C_OFFSET_74(C), C4

  # Write out C(7,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_74(C)
  movaps C2, 0x10+C_OFFSET_74(C)
  movaps C3, 0x20+C_OFFSET_74(C)
  movaps C4, 0x30+C_OFFSET_74(C)

  .align 16
block_309:

  # Check norm of product A(8,1)*B(1,3).
  movss 0xf8(multiply_stream, base_pointer), B1
  mulss 0x120(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_310

  # Reset C(8,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,3) = A(8,1)*B(1,3).
  movaps 0x0+B_OFFSET_13(B), B1
  movaps 0x10+B_OFFSET_13(B), B2
  movaps 0x20+B_OFFSET_13(B), B3
  movaps 0x30+B_OFFSET_13(B), B4
  movaps 0x0+A_OFFSET_81(A), A11
  movaps 0x10+A_OFFSET_81(A), A12
  movaps 0x20+A_OFFSET_81(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_81(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_81(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_81(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_81(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_81(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_81(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_81(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_81(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_81(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_81(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_81(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_81(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_81(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,3) to already existing.
  addps 0x0+C_OFFSET_83(C), C1
  addps 0x10+C_OFFSET_83(C), C2
  addps 0x20+C_OFFSET_83(C), C3
  addps 0x30+C_OFFSET_83(C), C4

  # Write out C(8,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_83(C)
  movaps C2, 0x10+C_OFFSET_83(C)
  movaps C3, 0x20+C_OFFSET_83(C)
  movaps C4, 0x30+C_OFFSET_83(C)

  .align 16
block_310:

  # Check norm of product A(8,2)*B(2,3).
  movss 0xfc(multiply_stream, base_pointer), B1
  mulss 0x140(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_311

  # Reset C(8,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,3) = A(8,2)*B(2,3).
  movaps 0x0+B_OFFSET_23(B), B1
  movaps 0x10+B_OFFSET_23(B), B2
  movaps 0x20+B_OFFSET_23(B), B3
  movaps 0x30+B_OFFSET_23(B), B4
  movaps 0x0+A_OFFSET_82(A), A11
  movaps 0x10+A_OFFSET_82(A), A12
  movaps 0x20+A_OFFSET_82(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_82(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_82(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_82(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_82(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_82(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_82(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_82(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_82(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_82(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_82(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_82(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_82(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_82(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,3) to already existing.
  addps 0x0+C_OFFSET_83(C), C1
  addps 0x10+C_OFFSET_83(C), C2
  addps 0x20+C_OFFSET_83(C), C3
  addps 0x30+C_OFFSET_83(C), C4

  # Write out C(8,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_83(C)
  movaps C2, 0x10+C_OFFSET_83(C)
  movaps C3, 0x20+C_OFFSET_83(C)
  movaps C4, 0x30+C_OFFSET_83(C)

  .align 16
block_311:

  # Check norm of product A(8,1)*B(1,4).
  movss 0xf8(multiply_stream, base_pointer), B1
  mulss 0x124(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_312

  # Reset C(8,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,4) = A(8,1)*B(1,4).
  movaps 0x0+B_OFFSET_14(B), B1
  movaps 0x10+B_OFFSET_14(B), B2
  movaps 0x20+B_OFFSET_14(B), B3
  movaps 0x30+B_OFFSET_14(B), B4
  movaps 0x0+A_OFFSET_81(A), A11
  movaps 0x10+A_OFFSET_81(A), A12
  movaps 0x20+A_OFFSET_81(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_81(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_81(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_81(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_81(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_81(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_81(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_81(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_81(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_81(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_81(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_81(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_81(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_81(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,4) to already existing.
  addps 0x0+C_OFFSET_84(C), C1
  addps 0x10+C_OFFSET_84(C), C2
  addps 0x20+C_OFFSET_84(C), C3
  addps 0x30+C_OFFSET_84(C), C4

  # Write out C(8,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_84(C)
  movaps C2, 0x10+C_OFFSET_84(C)
  movaps C3, 0x20+C_OFFSET_84(C)
  movaps C4, 0x30+C_OFFSET_84(C)

  .align 16
block_312:

  # Check norm of product A(8,2)*B(2,4).
  movss 0xfc(multiply_stream, base_pointer), B1
  mulss 0x144(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_313

  # Reset C(8,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,4) = A(8,2)*B(2,4).
  movaps 0x0+B_OFFSET_24(B), B1
  movaps 0x10+B_OFFSET_24(B), B2
  movaps 0x20+B_OFFSET_24(B), B3
  movaps 0x30+B_OFFSET_24(B), B4
  movaps 0x0+A_OFFSET_82(A), A11
  movaps 0x10+A_OFFSET_82(A), A12
  movaps 0x20+A_OFFSET_82(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_82(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_82(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_82(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_82(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_82(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_82(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_82(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_82(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_82(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_82(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_82(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_82(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_82(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,4) to already existing.
  addps 0x0+C_OFFSET_84(C), C1
  addps 0x10+C_OFFSET_84(C), C2
  addps 0x20+C_OFFSET_84(C), C3
  addps 0x30+C_OFFSET_84(C), C4

  # Write out C(8,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_84(C)
  movaps C2, 0x10+C_OFFSET_84(C)
  movaps C3, 0x20+C_OFFSET_84(C)
  movaps C4, 0x30+C_OFFSET_84(C)

  .align 16
block_313:

  # Check norm of product A(7,3)*B(3,3).
  movss 0xe0(multiply_stream, base_pointer), B1
  mulss 0x160(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_314

  # Reset C(7,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,3) = A(7,3)*B(3,3).
  movaps 0x0+B_OFFSET_33(B), B1
  movaps 0x10+B_OFFSET_33(B), B2
  movaps 0x20+B_OFFSET_33(B), B3
  movaps 0x30+B_OFFSET_33(B), B4
  movaps 0x0+A_OFFSET_73(A), A11
  movaps 0x10+A_OFFSET_73(A), A12
  movaps 0x20+A_OFFSET_73(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_73(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_73(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_73(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_73(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_73(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_73(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_73(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_73(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_73(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_73(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_73(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_73(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_73(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,3) to already existing.
  addps 0x0+C_OFFSET_73(C), C1
  addps 0x10+C_OFFSET_73(C), C2
  addps 0x20+C_OFFSET_73(C), C3
  addps 0x30+C_OFFSET_73(C), C4

  # Write out C(7,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_73(C)
  movaps C2, 0x10+C_OFFSET_73(C)
  movaps C3, 0x20+C_OFFSET_73(C)
  movaps C4, 0x30+C_OFFSET_73(C)

  .align 16
block_314:

  # Check norm of product A(7,4)*B(4,3).
  movss 0xe4(multiply_stream, base_pointer), B1
  mulss 0x180(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_315

  # Reset C(7,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,3) = A(7,4)*B(4,3).
  movaps 0x0+B_OFFSET_43(B), B1
  movaps 0x10+B_OFFSET_43(B), B2
  movaps 0x20+B_OFFSET_43(B), B3
  movaps 0x30+B_OFFSET_43(B), B4
  movaps 0x0+A_OFFSET_74(A), A11
  movaps 0x10+A_OFFSET_74(A), A12
  movaps 0x20+A_OFFSET_74(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_74(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_74(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_74(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_74(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_74(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_74(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_74(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_74(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_74(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_74(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_74(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_74(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_74(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,3) to already existing.
  addps 0x0+C_OFFSET_73(C), C1
  addps 0x10+C_OFFSET_73(C), C2
  addps 0x20+C_OFFSET_73(C), C3
  addps 0x30+C_OFFSET_73(C), C4

  # Write out C(7,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_73(C)
  movaps C2, 0x10+C_OFFSET_73(C)
  movaps C3, 0x20+C_OFFSET_73(C)
  movaps C4, 0x30+C_OFFSET_73(C)

  .align 16
block_315:

  # Check norm of product A(7,3)*B(3,4).
  movss 0xe0(multiply_stream, base_pointer), B1
  mulss 0x164(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_316

  # Reset C(7,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,4) = A(7,3)*B(3,4).
  movaps 0x0+B_OFFSET_34(B), B1
  movaps 0x10+B_OFFSET_34(B), B2
  movaps 0x20+B_OFFSET_34(B), B3
  movaps 0x30+B_OFFSET_34(B), B4
  movaps 0x0+A_OFFSET_73(A), A11
  movaps 0x10+A_OFFSET_73(A), A12
  movaps 0x20+A_OFFSET_73(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_73(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_73(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_73(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_73(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_73(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_73(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_73(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_73(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_73(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_73(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_73(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_73(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_73(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,4) to already existing.
  addps 0x0+C_OFFSET_74(C), C1
  addps 0x10+C_OFFSET_74(C), C2
  addps 0x20+C_OFFSET_74(C), C3
  addps 0x30+C_OFFSET_74(C), C4

  # Write out C(7,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_74(C)
  movaps C2, 0x10+C_OFFSET_74(C)
  movaps C3, 0x20+C_OFFSET_74(C)
  movaps C4, 0x30+C_OFFSET_74(C)

  .align 16
block_316:

  # Check norm of product A(7,4)*B(4,4).
  movss 0xe4(multiply_stream, base_pointer), B1
  mulss 0x184(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_317

  # Reset C(7,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,4) = A(7,4)*B(4,4).
  movaps 0x0+B_OFFSET_44(B), B1
  movaps 0x10+B_OFFSET_44(B), B2
  movaps 0x20+B_OFFSET_44(B), B3
  movaps 0x30+B_OFFSET_44(B), B4
  movaps 0x0+A_OFFSET_74(A), A11
  movaps 0x10+A_OFFSET_74(A), A12
  movaps 0x20+A_OFFSET_74(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_74(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_74(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_74(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_74(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_74(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_74(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_74(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_74(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_74(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_74(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_74(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_74(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_74(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,4) to already existing.
  addps 0x0+C_OFFSET_74(C), C1
  addps 0x10+C_OFFSET_74(C), C2
  addps 0x20+C_OFFSET_74(C), C3
  addps 0x30+C_OFFSET_74(C), C4

  # Write out C(7,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_74(C)
  movaps C2, 0x10+C_OFFSET_74(C)
  movaps C3, 0x20+C_OFFSET_74(C)
  movaps C4, 0x30+C_OFFSET_74(C)

  .align 16
block_317:

  # Check norm of product A(8,3)*B(3,3).
  movss 0x100(multiply_stream, base_pointer), B1
  mulss 0x160(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_318

  # Reset C(8,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,3) = A(8,3)*B(3,3).
  movaps 0x0+B_OFFSET_33(B), B1
  movaps 0x10+B_OFFSET_33(B), B2
  movaps 0x20+B_OFFSET_33(B), B3
  movaps 0x30+B_OFFSET_33(B), B4
  movaps 0x0+A_OFFSET_83(A), A11
  movaps 0x10+A_OFFSET_83(A), A12
  movaps 0x20+A_OFFSET_83(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_83(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_83(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_83(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_83(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_83(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_83(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_83(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_83(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_83(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_83(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_83(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_83(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_83(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,3) to already existing.
  addps 0x0+C_OFFSET_83(C), C1
  addps 0x10+C_OFFSET_83(C), C2
  addps 0x20+C_OFFSET_83(C), C3
  addps 0x30+C_OFFSET_83(C), C4

  # Write out C(8,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_83(C)
  movaps C2, 0x10+C_OFFSET_83(C)
  movaps C3, 0x20+C_OFFSET_83(C)
  movaps C4, 0x30+C_OFFSET_83(C)

  .align 16
block_318:

  # Check norm of product A(8,4)*B(4,3).
  movss 0x104(multiply_stream, base_pointer), B1
  mulss 0x180(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_319

  # Reset C(8,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,3) = A(8,4)*B(4,3).
  movaps 0x0+B_OFFSET_43(B), B1
  movaps 0x10+B_OFFSET_43(B), B2
  movaps 0x20+B_OFFSET_43(B), B3
  movaps 0x30+B_OFFSET_43(B), B4
  movaps 0x0+A_OFFSET_84(A), A11
  movaps 0x10+A_OFFSET_84(A), A12
  movaps 0x20+A_OFFSET_84(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_84(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_84(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_84(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_84(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_84(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_84(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_84(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_84(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_84(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_84(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_84(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_84(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_84(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,3) to already existing.
  addps 0x0+C_OFFSET_83(C), C1
  addps 0x10+C_OFFSET_83(C), C2
  addps 0x20+C_OFFSET_83(C), C3
  addps 0x30+C_OFFSET_83(C), C4

  # Write out C(8,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_83(C)
  movaps C2, 0x10+C_OFFSET_83(C)
  movaps C3, 0x20+C_OFFSET_83(C)
  movaps C4, 0x30+C_OFFSET_83(C)

  .align 16
block_319:

  # Check norm of product A(8,3)*B(3,4).
  movss 0x100(multiply_stream, base_pointer), B1
  mulss 0x164(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_320

  # Reset C(8,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,4) = A(8,3)*B(3,4).
  movaps 0x0+B_OFFSET_34(B), B1
  movaps 0x10+B_OFFSET_34(B), B2
  movaps 0x20+B_OFFSET_34(B), B3
  movaps 0x30+B_OFFSET_34(B), B4
  movaps 0x0+A_OFFSET_83(A), A11
  movaps 0x10+A_OFFSET_83(A), A12
  movaps 0x20+A_OFFSET_83(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_83(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_83(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_83(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_83(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_83(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_83(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_83(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_83(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_83(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_83(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_83(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_83(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_83(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,4) to already existing.
  addps 0x0+C_OFFSET_84(C), C1
  addps 0x10+C_OFFSET_84(C), C2
  addps 0x20+C_OFFSET_84(C), C3
  addps 0x30+C_OFFSET_84(C), C4

  # Write out C(8,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_84(C)
  movaps C2, 0x10+C_OFFSET_84(C)
  movaps C3, 0x20+C_OFFSET_84(C)
  movaps C4, 0x30+C_OFFSET_84(C)

  .align 16
block_320:

  # Check norm of product A(8,4)*B(4,4).
  movss 0x104(multiply_stream, base_pointer), B1
  mulss 0x184(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_321

  # Reset C(8,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,4) = A(8,4)*B(4,4).
  movaps 0x0+B_OFFSET_44(B), B1
  movaps 0x10+B_OFFSET_44(B), B2
  movaps 0x20+B_OFFSET_44(B), B3
  movaps 0x30+B_OFFSET_44(B), B4
  movaps 0x0+A_OFFSET_84(A), A11
  movaps 0x10+A_OFFSET_84(A), A12
  movaps 0x20+A_OFFSET_84(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_84(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_84(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_84(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_84(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_84(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_84(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_84(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_84(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_84(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_84(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_84(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_84(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_84(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,4) to already existing.
  addps 0x0+C_OFFSET_84(C), C1
  addps 0x10+C_OFFSET_84(C), C2
  addps 0x20+C_OFFSET_84(C), C3
  addps 0x30+C_OFFSET_84(C), C4

  # Write out C(8,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_84(C)
  movaps C2, 0x10+C_OFFSET_84(C)
  movaps C3, 0x20+C_OFFSET_84(C)
  movaps C4, 0x30+C_OFFSET_84(C)

  .align 16
block_321:

  # Check norm of product A(5,5)*B(5,1).
  movss 0xa8(multiply_stream, base_pointer), B1
  mulss 0x198(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_322

  # Reset C(5,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,1) = A(5,5)*B(5,1).
  movaps 0x0+B_OFFSET_51(B), B1
  movaps 0x10+B_OFFSET_51(B), B2
  movaps 0x20+B_OFFSET_51(B), B3
  movaps 0x30+B_OFFSET_51(B), B4
  movaps 0x0+A_OFFSET_55(A), A11
  movaps 0x10+A_OFFSET_55(A), A12
  movaps 0x20+A_OFFSET_55(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_55(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_55(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_55(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_55(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_55(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_55(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_55(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_55(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_55(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_55(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_55(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_55(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_55(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,1) to already existing.
  addps 0x0+C_OFFSET_51(C), C1
  addps 0x10+C_OFFSET_51(C), C2
  addps 0x20+C_OFFSET_51(C), C3
  addps 0x30+C_OFFSET_51(C), C4

  # Write out C(5,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_51(C)
  movaps C2, 0x10+C_OFFSET_51(C)
  movaps C3, 0x20+C_OFFSET_51(C)
  movaps C4, 0x30+C_OFFSET_51(C)

  .align 16
block_322:

  # Check norm of product A(5,6)*B(6,1).
  movss 0xac(multiply_stream, base_pointer), B1
  mulss 0x1b8(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_323

  # Reset C(5,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,1) = A(5,6)*B(6,1).
  movaps 0x0+B_OFFSET_61(B), B1
  movaps 0x10+B_OFFSET_61(B), B2
  movaps 0x20+B_OFFSET_61(B), B3
  movaps 0x30+B_OFFSET_61(B), B4
  movaps 0x0+A_OFFSET_56(A), A11
  movaps 0x10+A_OFFSET_56(A), A12
  movaps 0x20+A_OFFSET_56(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_56(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_56(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_56(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_56(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_56(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_56(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_56(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_56(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_56(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_56(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_56(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_56(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_56(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,1) to already existing.
  addps 0x0+C_OFFSET_51(C), C1
  addps 0x10+C_OFFSET_51(C), C2
  addps 0x20+C_OFFSET_51(C), C3
  addps 0x30+C_OFFSET_51(C), C4

  # Write out C(5,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_51(C)
  movaps C2, 0x10+C_OFFSET_51(C)
  movaps C3, 0x20+C_OFFSET_51(C)
  movaps C4, 0x30+C_OFFSET_51(C)

  .align 16
block_323:

  # Check norm of product A(5,5)*B(5,2).
  movss 0xa8(multiply_stream, base_pointer), B1
  mulss 0x19c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_324

  # Reset C(5,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,2) = A(5,5)*B(5,2).
  movaps 0x0+B_OFFSET_52(B), B1
  movaps 0x10+B_OFFSET_52(B), B2
  movaps 0x20+B_OFFSET_52(B), B3
  movaps 0x30+B_OFFSET_52(B), B4
  movaps 0x0+A_OFFSET_55(A), A11
  movaps 0x10+A_OFFSET_55(A), A12
  movaps 0x20+A_OFFSET_55(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_55(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_55(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_55(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_55(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_55(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_55(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_55(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_55(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_55(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_55(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_55(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_55(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_55(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,2) to already existing.
  addps 0x0+C_OFFSET_52(C), C1
  addps 0x10+C_OFFSET_52(C), C2
  addps 0x20+C_OFFSET_52(C), C3
  addps 0x30+C_OFFSET_52(C), C4

  # Write out C(5,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_52(C)
  movaps C2, 0x10+C_OFFSET_52(C)
  movaps C3, 0x20+C_OFFSET_52(C)
  movaps C4, 0x30+C_OFFSET_52(C)

  .align 16
block_324:

  # Check norm of product A(5,6)*B(6,2).
  movss 0xac(multiply_stream, base_pointer), B1
  mulss 0x1bc(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_325

  # Reset C(5,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,2) = A(5,6)*B(6,2).
  movaps 0x0+B_OFFSET_62(B), B1
  movaps 0x10+B_OFFSET_62(B), B2
  movaps 0x20+B_OFFSET_62(B), B3
  movaps 0x30+B_OFFSET_62(B), B4
  movaps 0x0+A_OFFSET_56(A), A11
  movaps 0x10+A_OFFSET_56(A), A12
  movaps 0x20+A_OFFSET_56(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_56(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_56(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_56(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_56(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_56(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_56(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_56(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_56(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_56(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_56(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_56(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_56(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_56(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,2) to already existing.
  addps 0x0+C_OFFSET_52(C), C1
  addps 0x10+C_OFFSET_52(C), C2
  addps 0x20+C_OFFSET_52(C), C3
  addps 0x30+C_OFFSET_52(C), C4

  # Write out C(5,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_52(C)
  movaps C2, 0x10+C_OFFSET_52(C)
  movaps C3, 0x20+C_OFFSET_52(C)
  movaps C4, 0x30+C_OFFSET_52(C)

  .align 16
block_325:

  # Check norm of product A(6,5)*B(5,1).
  movss 0xc8(multiply_stream, base_pointer), B1
  mulss 0x198(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_326

  # Reset C(6,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,1) = A(6,5)*B(5,1).
  movaps 0x0+B_OFFSET_51(B), B1
  movaps 0x10+B_OFFSET_51(B), B2
  movaps 0x20+B_OFFSET_51(B), B3
  movaps 0x30+B_OFFSET_51(B), B4
  movaps 0x0+A_OFFSET_65(A), A11
  movaps 0x10+A_OFFSET_65(A), A12
  movaps 0x20+A_OFFSET_65(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_65(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_65(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_65(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_65(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_65(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_65(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_65(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_65(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_65(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_65(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_65(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_65(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_65(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,1) to already existing.
  addps 0x0+C_OFFSET_61(C), C1
  addps 0x10+C_OFFSET_61(C), C2
  addps 0x20+C_OFFSET_61(C), C3
  addps 0x30+C_OFFSET_61(C), C4

  # Write out C(6,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_61(C)
  movaps C2, 0x10+C_OFFSET_61(C)
  movaps C3, 0x20+C_OFFSET_61(C)
  movaps C4, 0x30+C_OFFSET_61(C)

  .align 16
block_326:

  # Check norm of product A(6,6)*B(6,1).
  movss 0xcc(multiply_stream, base_pointer), B1
  mulss 0x1b8(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_327

  # Reset C(6,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,1) = A(6,6)*B(6,1).
  movaps 0x0+B_OFFSET_61(B), B1
  movaps 0x10+B_OFFSET_61(B), B2
  movaps 0x20+B_OFFSET_61(B), B3
  movaps 0x30+B_OFFSET_61(B), B4
  movaps 0x0+A_OFFSET_66(A), A11
  movaps 0x10+A_OFFSET_66(A), A12
  movaps 0x20+A_OFFSET_66(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_66(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_66(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_66(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_66(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_66(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_66(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_66(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_66(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_66(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_66(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_66(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_66(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_66(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,1) to already existing.
  addps 0x0+C_OFFSET_61(C), C1
  addps 0x10+C_OFFSET_61(C), C2
  addps 0x20+C_OFFSET_61(C), C3
  addps 0x30+C_OFFSET_61(C), C4

  # Write out C(6,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_61(C)
  movaps C2, 0x10+C_OFFSET_61(C)
  movaps C3, 0x20+C_OFFSET_61(C)
  movaps C4, 0x30+C_OFFSET_61(C)

  .align 16
block_327:

  # Check norm of product A(6,5)*B(5,2).
  movss 0xc8(multiply_stream, base_pointer), B1
  mulss 0x19c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_328

  # Reset C(6,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,2) = A(6,5)*B(5,2).
  movaps 0x0+B_OFFSET_52(B), B1
  movaps 0x10+B_OFFSET_52(B), B2
  movaps 0x20+B_OFFSET_52(B), B3
  movaps 0x30+B_OFFSET_52(B), B4
  movaps 0x0+A_OFFSET_65(A), A11
  movaps 0x10+A_OFFSET_65(A), A12
  movaps 0x20+A_OFFSET_65(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_65(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_65(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_65(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_65(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_65(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_65(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_65(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_65(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_65(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_65(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_65(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_65(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_65(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,2) to already existing.
  addps 0x0+C_OFFSET_62(C), C1
  addps 0x10+C_OFFSET_62(C), C2
  addps 0x20+C_OFFSET_62(C), C3
  addps 0x30+C_OFFSET_62(C), C4

  # Write out C(6,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_62(C)
  movaps C2, 0x10+C_OFFSET_62(C)
  movaps C3, 0x20+C_OFFSET_62(C)
  movaps C4, 0x30+C_OFFSET_62(C)

  .align 16
block_328:

  # Check norm of product A(6,6)*B(6,2).
  movss 0xcc(multiply_stream, base_pointer), B1
  mulss 0x1bc(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_329

  # Reset C(6,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,2) = A(6,6)*B(6,2).
  movaps 0x0+B_OFFSET_62(B), B1
  movaps 0x10+B_OFFSET_62(B), B2
  movaps 0x20+B_OFFSET_62(B), B3
  movaps 0x30+B_OFFSET_62(B), B4
  movaps 0x0+A_OFFSET_66(A), A11
  movaps 0x10+A_OFFSET_66(A), A12
  movaps 0x20+A_OFFSET_66(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_66(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_66(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_66(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_66(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_66(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_66(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_66(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_66(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_66(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_66(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_66(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_66(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_66(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,2) to already existing.
  addps 0x0+C_OFFSET_62(C), C1
  addps 0x10+C_OFFSET_62(C), C2
  addps 0x20+C_OFFSET_62(C), C3
  addps 0x30+C_OFFSET_62(C), C4

  # Write out C(6,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_62(C)
  movaps C2, 0x10+C_OFFSET_62(C)
  movaps C3, 0x20+C_OFFSET_62(C)
  movaps C4, 0x30+C_OFFSET_62(C)

  .align 16
block_329:

  # Check norm of product A(5,7)*B(7,1).
  movss 0xb0(multiply_stream, base_pointer), B1
  mulss 0x1d8(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_330

  # Reset C(5,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,1) = A(5,7)*B(7,1).
  movaps 0x0+B_OFFSET_71(B), B1
  movaps 0x10+B_OFFSET_71(B), B2
  movaps 0x20+B_OFFSET_71(B), B3
  movaps 0x30+B_OFFSET_71(B), B4
  movaps 0x0+A_OFFSET_57(A), A11
  movaps 0x10+A_OFFSET_57(A), A12
  movaps 0x20+A_OFFSET_57(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_57(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_57(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_57(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_57(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_57(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_57(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_57(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_57(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_57(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_57(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_57(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_57(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_57(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,1) to already existing.
  addps 0x0+C_OFFSET_51(C), C1
  addps 0x10+C_OFFSET_51(C), C2
  addps 0x20+C_OFFSET_51(C), C3
  addps 0x30+C_OFFSET_51(C), C4

  # Write out C(5,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_51(C)
  movaps C2, 0x10+C_OFFSET_51(C)
  movaps C3, 0x20+C_OFFSET_51(C)
  movaps C4, 0x30+C_OFFSET_51(C)

  .align 16
block_330:

  # Check norm of product A(5,8)*B(8,1).
  movss 0xb4(multiply_stream, base_pointer), B1
  mulss 0x1f8(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_331

  # Reset C(5,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,1) = A(5,8)*B(8,1).
  movaps 0x0+B_OFFSET_81(B), B1
  movaps 0x10+B_OFFSET_81(B), B2
  movaps 0x20+B_OFFSET_81(B), B3
  movaps 0x30+B_OFFSET_81(B), B4
  movaps 0x0+A_OFFSET_58(A), A11
  movaps 0x10+A_OFFSET_58(A), A12
  movaps 0x20+A_OFFSET_58(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_58(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_58(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_58(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_58(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_58(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_58(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_58(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_58(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_58(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_58(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_58(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_58(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_58(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,1) to already existing.
  addps 0x0+C_OFFSET_51(C), C1
  addps 0x10+C_OFFSET_51(C), C2
  addps 0x20+C_OFFSET_51(C), C3
  addps 0x30+C_OFFSET_51(C), C4

  # Write out C(5,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_51(C)
  movaps C2, 0x10+C_OFFSET_51(C)
  movaps C3, 0x20+C_OFFSET_51(C)
  movaps C4, 0x30+C_OFFSET_51(C)

  .align 16
block_331:

  # Check norm of product A(5,7)*B(7,2).
  movss 0xb0(multiply_stream, base_pointer), B1
  mulss 0x1dc(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_332

  # Reset C(5,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,2) = A(5,7)*B(7,2).
  movaps 0x0+B_OFFSET_72(B), B1
  movaps 0x10+B_OFFSET_72(B), B2
  movaps 0x20+B_OFFSET_72(B), B3
  movaps 0x30+B_OFFSET_72(B), B4
  movaps 0x0+A_OFFSET_57(A), A11
  movaps 0x10+A_OFFSET_57(A), A12
  movaps 0x20+A_OFFSET_57(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_57(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_57(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_57(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_57(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_57(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_57(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_57(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_57(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_57(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_57(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_57(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_57(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_57(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,2) to already existing.
  addps 0x0+C_OFFSET_52(C), C1
  addps 0x10+C_OFFSET_52(C), C2
  addps 0x20+C_OFFSET_52(C), C3
  addps 0x30+C_OFFSET_52(C), C4

  # Write out C(5,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_52(C)
  movaps C2, 0x10+C_OFFSET_52(C)
  movaps C3, 0x20+C_OFFSET_52(C)
  movaps C4, 0x30+C_OFFSET_52(C)

  .align 16
block_332:

  # Check norm of product A(5,8)*B(8,2).
  movss 0xb4(multiply_stream, base_pointer), B1
  mulss 0x1fc(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_333

  # Reset C(5,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,2) = A(5,8)*B(8,2).
  movaps 0x0+B_OFFSET_82(B), B1
  movaps 0x10+B_OFFSET_82(B), B2
  movaps 0x20+B_OFFSET_82(B), B3
  movaps 0x30+B_OFFSET_82(B), B4
  movaps 0x0+A_OFFSET_58(A), A11
  movaps 0x10+A_OFFSET_58(A), A12
  movaps 0x20+A_OFFSET_58(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_58(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_58(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_58(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_58(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_58(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_58(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_58(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_58(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_58(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_58(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_58(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_58(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_58(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,2) to already existing.
  addps 0x0+C_OFFSET_52(C), C1
  addps 0x10+C_OFFSET_52(C), C2
  addps 0x20+C_OFFSET_52(C), C3
  addps 0x30+C_OFFSET_52(C), C4

  # Write out C(5,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_52(C)
  movaps C2, 0x10+C_OFFSET_52(C)
  movaps C3, 0x20+C_OFFSET_52(C)
  movaps C4, 0x30+C_OFFSET_52(C)

  .align 16
block_333:

  # Check norm of product A(6,7)*B(7,1).
  movss 0xd0(multiply_stream, base_pointer), B1
  mulss 0x1d8(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_334

  # Reset C(6,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,1) = A(6,7)*B(7,1).
  movaps 0x0+B_OFFSET_71(B), B1
  movaps 0x10+B_OFFSET_71(B), B2
  movaps 0x20+B_OFFSET_71(B), B3
  movaps 0x30+B_OFFSET_71(B), B4
  movaps 0x0+A_OFFSET_67(A), A11
  movaps 0x10+A_OFFSET_67(A), A12
  movaps 0x20+A_OFFSET_67(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_67(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_67(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_67(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_67(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_67(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_67(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_67(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_67(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_67(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_67(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_67(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_67(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_67(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,1) to already existing.
  addps 0x0+C_OFFSET_61(C), C1
  addps 0x10+C_OFFSET_61(C), C2
  addps 0x20+C_OFFSET_61(C), C3
  addps 0x30+C_OFFSET_61(C), C4

  # Write out C(6,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_61(C)
  movaps C2, 0x10+C_OFFSET_61(C)
  movaps C3, 0x20+C_OFFSET_61(C)
  movaps C4, 0x30+C_OFFSET_61(C)

  .align 16
block_334:

  # Check norm of product A(6,8)*B(8,1).
  movss 0xd4(multiply_stream, base_pointer), B1
  mulss 0x1f8(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_335

  # Reset C(6,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,1) = A(6,8)*B(8,1).
  movaps 0x0+B_OFFSET_81(B), B1
  movaps 0x10+B_OFFSET_81(B), B2
  movaps 0x20+B_OFFSET_81(B), B3
  movaps 0x30+B_OFFSET_81(B), B4
  movaps 0x0+A_OFFSET_68(A), A11
  movaps 0x10+A_OFFSET_68(A), A12
  movaps 0x20+A_OFFSET_68(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_68(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_68(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_68(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_68(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_68(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_68(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_68(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_68(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_68(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_68(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_68(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_68(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_68(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,1) to already existing.
  addps 0x0+C_OFFSET_61(C), C1
  addps 0x10+C_OFFSET_61(C), C2
  addps 0x20+C_OFFSET_61(C), C3
  addps 0x30+C_OFFSET_61(C), C4

  # Write out C(6,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_61(C)
  movaps C2, 0x10+C_OFFSET_61(C)
  movaps C3, 0x20+C_OFFSET_61(C)
  movaps C4, 0x30+C_OFFSET_61(C)

  .align 16
block_335:

  # Check norm of product A(6,7)*B(7,2).
  movss 0xd0(multiply_stream, base_pointer), B1
  mulss 0x1dc(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_336

  # Reset C(6,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,2) = A(6,7)*B(7,2).
  movaps 0x0+B_OFFSET_72(B), B1
  movaps 0x10+B_OFFSET_72(B), B2
  movaps 0x20+B_OFFSET_72(B), B3
  movaps 0x30+B_OFFSET_72(B), B4
  movaps 0x0+A_OFFSET_67(A), A11
  movaps 0x10+A_OFFSET_67(A), A12
  movaps 0x20+A_OFFSET_67(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_67(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_67(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_67(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_67(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_67(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_67(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_67(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_67(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_67(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_67(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_67(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_67(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_67(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,2) to already existing.
  addps 0x0+C_OFFSET_62(C), C1
  addps 0x10+C_OFFSET_62(C), C2
  addps 0x20+C_OFFSET_62(C), C3
  addps 0x30+C_OFFSET_62(C), C4

  # Write out C(6,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_62(C)
  movaps C2, 0x10+C_OFFSET_62(C)
  movaps C3, 0x20+C_OFFSET_62(C)
  movaps C4, 0x30+C_OFFSET_62(C)

  .align 16
block_336:

  # Check norm of product A(6,8)*B(8,2).
  movss 0xd4(multiply_stream, base_pointer), B1
  mulss 0x1fc(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_337

  # Reset C(6,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,2) = A(6,8)*B(8,2).
  movaps 0x0+B_OFFSET_82(B), B1
  movaps 0x10+B_OFFSET_82(B), B2
  movaps 0x20+B_OFFSET_82(B), B3
  movaps 0x30+B_OFFSET_82(B), B4
  movaps 0x0+A_OFFSET_68(A), A11
  movaps 0x10+A_OFFSET_68(A), A12
  movaps 0x20+A_OFFSET_68(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_68(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_68(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_68(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_68(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_68(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_68(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_68(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_68(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_68(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_68(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_68(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_68(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_68(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,2) to already existing.
  addps 0x0+C_OFFSET_62(C), C1
  addps 0x10+C_OFFSET_62(C), C2
  addps 0x20+C_OFFSET_62(C), C3
  addps 0x30+C_OFFSET_62(C), C4

  # Write out C(6,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_62(C)
  movaps C2, 0x10+C_OFFSET_62(C)
  movaps C3, 0x20+C_OFFSET_62(C)
  movaps C4, 0x30+C_OFFSET_62(C)

  .align 16
block_337:

  # Check norm of product A(5,5)*B(5,3).
  movss 0xa8(multiply_stream, base_pointer), B1
  mulss 0x1a0(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_338

  # Reset C(5,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,3) = A(5,5)*B(5,3).
  movaps 0x0+B_OFFSET_53(B), B1
  movaps 0x10+B_OFFSET_53(B), B2
  movaps 0x20+B_OFFSET_53(B), B3
  movaps 0x30+B_OFFSET_53(B), B4
  movaps 0x0+A_OFFSET_55(A), A11
  movaps 0x10+A_OFFSET_55(A), A12
  movaps 0x20+A_OFFSET_55(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_55(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_55(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_55(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_55(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_55(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_55(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_55(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_55(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_55(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_55(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_55(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_55(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_55(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,3) to already existing.
  addps 0x0+C_OFFSET_53(C), C1
  addps 0x10+C_OFFSET_53(C), C2
  addps 0x20+C_OFFSET_53(C), C3
  addps 0x30+C_OFFSET_53(C), C4

  # Write out C(5,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_53(C)
  movaps C2, 0x10+C_OFFSET_53(C)
  movaps C3, 0x20+C_OFFSET_53(C)
  movaps C4, 0x30+C_OFFSET_53(C)

  .align 16
block_338:

  # Check norm of product A(5,6)*B(6,3).
  movss 0xac(multiply_stream, base_pointer), B1
  mulss 0x1c0(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_339

  # Reset C(5,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,3) = A(5,6)*B(6,3).
  movaps 0x0+B_OFFSET_63(B), B1
  movaps 0x10+B_OFFSET_63(B), B2
  movaps 0x20+B_OFFSET_63(B), B3
  movaps 0x30+B_OFFSET_63(B), B4
  movaps 0x0+A_OFFSET_56(A), A11
  movaps 0x10+A_OFFSET_56(A), A12
  movaps 0x20+A_OFFSET_56(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_56(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_56(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_56(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_56(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_56(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_56(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_56(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_56(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_56(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_56(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_56(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_56(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_56(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,3) to already existing.
  addps 0x0+C_OFFSET_53(C), C1
  addps 0x10+C_OFFSET_53(C), C2
  addps 0x20+C_OFFSET_53(C), C3
  addps 0x30+C_OFFSET_53(C), C4

  # Write out C(5,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_53(C)
  movaps C2, 0x10+C_OFFSET_53(C)
  movaps C3, 0x20+C_OFFSET_53(C)
  movaps C4, 0x30+C_OFFSET_53(C)

  .align 16
block_339:

  # Check norm of product A(5,5)*B(5,4).
  movss 0xa8(multiply_stream, base_pointer), B1
  mulss 0x1a4(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_340

  # Reset C(5,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,4) = A(5,5)*B(5,4).
  movaps 0x0+B_OFFSET_54(B), B1
  movaps 0x10+B_OFFSET_54(B), B2
  movaps 0x20+B_OFFSET_54(B), B3
  movaps 0x30+B_OFFSET_54(B), B4
  movaps 0x0+A_OFFSET_55(A), A11
  movaps 0x10+A_OFFSET_55(A), A12
  movaps 0x20+A_OFFSET_55(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_55(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_55(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_55(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_55(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_55(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_55(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_55(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_55(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_55(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_55(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_55(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_55(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_55(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,4) to already existing.
  addps 0x0+C_OFFSET_54(C), C1
  addps 0x10+C_OFFSET_54(C), C2
  addps 0x20+C_OFFSET_54(C), C3
  addps 0x30+C_OFFSET_54(C), C4

  # Write out C(5,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_54(C)
  movaps C2, 0x10+C_OFFSET_54(C)
  movaps C3, 0x20+C_OFFSET_54(C)
  movaps C4, 0x30+C_OFFSET_54(C)

  .align 16
block_340:

  # Check norm of product A(5,6)*B(6,4).
  movss 0xac(multiply_stream, base_pointer), B1
  mulss 0x1c4(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_341

  # Reset C(5,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,4) = A(5,6)*B(6,4).
  movaps 0x0+B_OFFSET_64(B), B1
  movaps 0x10+B_OFFSET_64(B), B2
  movaps 0x20+B_OFFSET_64(B), B3
  movaps 0x30+B_OFFSET_64(B), B4
  movaps 0x0+A_OFFSET_56(A), A11
  movaps 0x10+A_OFFSET_56(A), A12
  movaps 0x20+A_OFFSET_56(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_56(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_56(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_56(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_56(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_56(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_56(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_56(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_56(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_56(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_56(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_56(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_56(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_56(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,4) to already existing.
  addps 0x0+C_OFFSET_54(C), C1
  addps 0x10+C_OFFSET_54(C), C2
  addps 0x20+C_OFFSET_54(C), C3
  addps 0x30+C_OFFSET_54(C), C4

  # Write out C(5,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_54(C)
  movaps C2, 0x10+C_OFFSET_54(C)
  movaps C3, 0x20+C_OFFSET_54(C)
  movaps C4, 0x30+C_OFFSET_54(C)

  .align 16
block_341:

  # Check norm of product A(6,5)*B(5,3).
  movss 0xc8(multiply_stream, base_pointer), B1
  mulss 0x1a0(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_342

  # Reset C(6,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,3) = A(6,5)*B(5,3).
  movaps 0x0+B_OFFSET_53(B), B1
  movaps 0x10+B_OFFSET_53(B), B2
  movaps 0x20+B_OFFSET_53(B), B3
  movaps 0x30+B_OFFSET_53(B), B4
  movaps 0x0+A_OFFSET_65(A), A11
  movaps 0x10+A_OFFSET_65(A), A12
  movaps 0x20+A_OFFSET_65(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_65(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_65(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_65(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_65(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_65(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_65(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_65(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_65(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_65(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_65(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_65(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_65(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_65(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,3) to already existing.
  addps 0x0+C_OFFSET_63(C), C1
  addps 0x10+C_OFFSET_63(C), C2
  addps 0x20+C_OFFSET_63(C), C3
  addps 0x30+C_OFFSET_63(C), C4

  # Write out C(6,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_63(C)
  movaps C2, 0x10+C_OFFSET_63(C)
  movaps C3, 0x20+C_OFFSET_63(C)
  movaps C4, 0x30+C_OFFSET_63(C)

  .align 16
block_342:

  # Check norm of product A(6,6)*B(6,3).
  movss 0xcc(multiply_stream, base_pointer), B1
  mulss 0x1c0(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_343

  # Reset C(6,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,3) = A(6,6)*B(6,3).
  movaps 0x0+B_OFFSET_63(B), B1
  movaps 0x10+B_OFFSET_63(B), B2
  movaps 0x20+B_OFFSET_63(B), B3
  movaps 0x30+B_OFFSET_63(B), B4
  movaps 0x0+A_OFFSET_66(A), A11
  movaps 0x10+A_OFFSET_66(A), A12
  movaps 0x20+A_OFFSET_66(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_66(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_66(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_66(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_66(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_66(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_66(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_66(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_66(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_66(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_66(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_66(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_66(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_66(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,3) to already existing.
  addps 0x0+C_OFFSET_63(C), C1
  addps 0x10+C_OFFSET_63(C), C2
  addps 0x20+C_OFFSET_63(C), C3
  addps 0x30+C_OFFSET_63(C), C4

  # Write out C(6,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_63(C)
  movaps C2, 0x10+C_OFFSET_63(C)
  movaps C3, 0x20+C_OFFSET_63(C)
  movaps C4, 0x30+C_OFFSET_63(C)

  .align 16
block_343:

  # Check norm of product A(6,5)*B(5,4).
  movss 0xc8(multiply_stream, base_pointer), B1
  mulss 0x1a4(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_344

  # Reset C(6,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,4) = A(6,5)*B(5,4).
  movaps 0x0+B_OFFSET_54(B), B1
  movaps 0x10+B_OFFSET_54(B), B2
  movaps 0x20+B_OFFSET_54(B), B3
  movaps 0x30+B_OFFSET_54(B), B4
  movaps 0x0+A_OFFSET_65(A), A11
  movaps 0x10+A_OFFSET_65(A), A12
  movaps 0x20+A_OFFSET_65(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_65(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_65(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_65(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_65(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_65(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_65(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_65(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_65(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_65(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_65(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_65(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_65(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_65(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,4) to already existing.
  addps 0x0+C_OFFSET_64(C), C1
  addps 0x10+C_OFFSET_64(C), C2
  addps 0x20+C_OFFSET_64(C), C3
  addps 0x30+C_OFFSET_64(C), C4

  # Write out C(6,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_64(C)
  movaps C2, 0x10+C_OFFSET_64(C)
  movaps C3, 0x20+C_OFFSET_64(C)
  movaps C4, 0x30+C_OFFSET_64(C)

  .align 16
block_344:

  # Check norm of product A(6,6)*B(6,4).
  movss 0xcc(multiply_stream, base_pointer), B1
  mulss 0x1c4(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_345

  # Reset C(6,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,4) = A(6,6)*B(6,4).
  movaps 0x0+B_OFFSET_64(B), B1
  movaps 0x10+B_OFFSET_64(B), B2
  movaps 0x20+B_OFFSET_64(B), B3
  movaps 0x30+B_OFFSET_64(B), B4
  movaps 0x0+A_OFFSET_66(A), A11
  movaps 0x10+A_OFFSET_66(A), A12
  movaps 0x20+A_OFFSET_66(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_66(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_66(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_66(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_66(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_66(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_66(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_66(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_66(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_66(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_66(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_66(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_66(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_66(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,4) to already existing.
  addps 0x0+C_OFFSET_64(C), C1
  addps 0x10+C_OFFSET_64(C), C2
  addps 0x20+C_OFFSET_64(C), C3
  addps 0x30+C_OFFSET_64(C), C4

  # Write out C(6,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_64(C)
  movaps C2, 0x10+C_OFFSET_64(C)
  movaps C3, 0x20+C_OFFSET_64(C)
  movaps C4, 0x30+C_OFFSET_64(C)

  .align 16
block_345:

  # Check norm of product A(5,7)*B(7,3).
  movss 0xb0(multiply_stream, base_pointer), B1
  mulss 0x1e0(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_346

  # Reset C(5,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,3) = A(5,7)*B(7,3).
  movaps 0x0+B_OFFSET_73(B), B1
  movaps 0x10+B_OFFSET_73(B), B2
  movaps 0x20+B_OFFSET_73(B), B3
  movaps 0x30+B_OFFSET_73(B), B4
  movaps 0x0+A_OFFSET_57(A), A11
  movaps 0x10+A_OFFSET_57(A), A12
  movaps 0x20+A_OFFSET_57(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_57(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_57(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_57(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_57(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_57(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_57(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_57(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_57(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_57(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_57(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_57(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_57(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_57(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,3) to already existing.
  addps 0x0+C_OFFSET_53(C), C1
  addps 0x10+C_OFFSET_53(C), C2
  addps 0x20+C_OFFSET_53(C), C3
  addps 0x30+C_OFFSET_53(C), C4

  # Write out C(5,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_53(C)
  movaps C2, 0x10+C_OFFSET_53(C)
  movaps C3, 0x20+C_OFFSET_53(C)
  movaps C4, 0x30+C_OFFSET_53(C)

  .align 16
block_346:

  # Check norm of product A(5,8)*B(8,3).
  movss 0xb4(multiply_stream, base_pointer), B1
  mulss 0x200(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_347

  # Reset C(5,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,3) = A(5,8)*B(8,3).
  movaps 0x0+B_OFFSET_83(B), B1
  movaps 0x10+B_OFFSET_83(B), B2
  movaps 0x20+B_OFFSET_83(B), B3
  movaps 0x30+B_OFFSET_83(B), B4
  movaps 0x0+A_OFFSET_58(A), A11
  movaps 0x10+A_OFFSET_58(A), A12
  movaps 0x20+A_OFFSET_58(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_58(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_58(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_58(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_58(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_58(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_58(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_58(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_58(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_58(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_58(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_58(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_58(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_58(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,3) to already existing.
  addps 0x0+C_OFFSET_53(C), C1
  addps 0x10+C_OFFSET_53(C), C2
  addps 0x20+C_OFFSET_53(C), C3
  addps 0x30+C_OFFSET_53(C), C4

  # Write out C(5,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_53(C)
  movaps C2, 0x10+C_OFFSET_53(C)
  movaps C3, 0x20+C_OFFSET_53(C)
  movaps C4, 0x30+C_OFFSET_53(C)

  .align 16
block_347:

  # Check norm of product A(5,7)*B(7,4).
  movss 0xb0(multiply_stream, base_pointer), B1
  mulss 0x1e4(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_348

  # Reset C(5,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,4) = A(5,7)*B(7,4).
  movaps 0x0+B_OFFSET_74(B), B1
  movaps 0x10+B_OFFSET_74(B), B2
  movaps 0x20+B_OFFSET_74(B), B3
  movaps 0x30+B_OFFSET_74(B), B4
  movaps 0x0+A_OFFSET_57(A), A11
  movaps 0x10+A_OFFSET_57(A), A12
  movaps 0x20+A_OFFSET_57(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_57(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_57(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_57(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_57(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_57(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_57(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_57(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_57(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_57(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_57(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_57(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_57(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_57(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,4) to already existing.
  addps 0x0+C_OFFSET_54(C), C1
  addps 0x10+C_OFFSET_54(C), C2
  addps 0x20+C_OFFSET_54(C), C3
  addps 0x30+C_OFFSET_54(C), C4

  # Write out C(5,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_54(C)
  movaps C2, 0x10+C_OFFSET_54(C)
  movaps C3, 0x20+C_OFFSET_54(C)
  movaps C4, 0x30+C_OFFSET_54(C)

  .align 16
block_348:

  # Check norm of product A(5,8)*B(8,4).
  movss 0xb4(multiply_stream, base_pointer), B1
  mulss 0x204(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_349

  # Reset C(5,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,4) = A(5,8)*B(8,4).
  movaps 0x0+B_OFFSET_84(B), B1
  movaps 0x10+B_OFFSET_84(B), B2
  movaps 0x20+B_OFFSET_84(B), B3
  movaps 0x30+B_OFFSET_84(B), B4
  movaps 0x0+A_OFFSET_58(A), A11
  movaps 0x10+A_OFFSET_58(A), A12
  movaps 0x20+A_OFFSET_58(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_58(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_58(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_58(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_58(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_58(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_58(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_58(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_58(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_58(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_58(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_58(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_58(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_58(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,4) to already existing.
  addps 0x0+C_OFFSET_54(C), C1
  addps 0x10+C_OFFSET_54(C), C2
  addps 0x20+C_OFFSET_54(C), C3
  addps 0x30+C_OFFSET_54(C), C4

  # Write out C(5,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_54(C)
  movaps C2, 0x10+C_OFFSET_54(C)
  movaps C3, 0x20+C_OFFSET_54(C)
  movaps C4, 0x30+C_OFFSET_54(C)

  .align 16
block_349:

  # Check norm of product A(6,7)*B(7,3).
  movss 0xd0(multiply_stream, base_pointer), B1
  mulss 0x1e0(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_350

  # Reset C(6,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,3) = A(6,7)*B(7,3).
  movaps 0x0+B_OFFSET_73(B), B1
  movaps 0x10+B_OFFSET_73(B), B2
  movaps 0x20+B_OFFSET_73(B), B3
  movaps 0x30+B_OFFSET_73(B), B4
  movaps 0x0+A_OFFSET_67(A), A11
  movaps 0x10+A_OFFSET_67(A), A12
  movaps 0x20+A_OFFSET_67(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_67(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_67(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_67(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_67(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_67(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_67(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_67(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_67(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_67(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_67(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_67(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_67(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_67(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,3) to already existing.
  addps 0x0+C_OFFSET_63(C), C1
  addps 0x10+C_OFFSET_63(C), C2
  addps 0x20+C_OFFSET_63(C), C3
  addps 0x30+C_OFFSET_63(C), C4

  # Write out C(6,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_63(C)
  movaps C2, 0x10+C_OFFSET_63(C)
  movaps C3, 0x20+C_OFFSET_63(C)
  movaps C4, 0x30+C_OFFSET_63(C)

  .align 16
block_350:

  # Check norm of product A(6,8)*B(8,3).
  movss 0xd4(multiply_stream, base_pointer), B1
  mulss 0x200(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_351

  # Reset C(6,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,3) = A(6,8)*B(8,3).
  movaps 0x0+B_OFFSET_83(B), B1
  movaps 0x10+B_OFFSET_83(B), B2
  movaps 0x20+B_OFFSET_83(B), B3
  movaps 0x30+B_OFFSET_83(B), B4
  movaps 0x0+A_OFFSET_68(A), A11
  movaps 0x10+A_OFFSET_68(A), A12
  movaps 0x20+A_OFFSET_68(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_68(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_68(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_68(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_68(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_68(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_68(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_68(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_68(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_68(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_68(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_68(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_68(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_68(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,3) to already existing.
  addps 0x0+C_OFFSET_63(C), C1
  addps 0x10+C_OFFSET_63(C), C2
  addps 0x20+C_OFFSET_63(C), C3
  addps 0x30+C_OFFSET_63(C), C4

  # Write out C(6,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_63(C)
  movaps C2, 0x10+C_OFFSET_63(C)
  movaps C3, 0x20+C_OFFSET_63(C)
  movaps C4, 0x30+C_OFFSET_63(C)

  .align 16
block_351:

  # Check norm of product A(6,7)*B(7,4).
  movss 0xd0(multiply_stream, base_pointer), B1
  mulss 0x1e4(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_352

  # Reset C(6,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,4) = A(6,7)*B(7,4).
  movaps 0x0+B_OFFSET_74(B), B1
  movaps 0x10+B_OFFSET_74(B), B2
  movaps 0x20+B_OFFSET_74(B), B3
  movaps 0x30+B_OFFSET_74(B), B4
  movaps 0x0+A_OFFSET_67(A), A11
  movaps 0x10+A_OFFSET_67(A), A12
  movaps 0x20+A_OFFSET_67(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_67(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_67(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_67(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_67(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_67(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_67(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_67(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_67(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_67(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_67(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_67(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_67(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_67(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,4) to already existing.
  addps 0x0+C_OFFSET_64(C), C1
  addps 0x10+C_OFFSET_64(C), C2
  addps 0x20+C_OFFSET_64(C), C3
  addps 0x30+C_OFFSET_64(C), C4

  # Write out C(6,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_64(C)
  movaps C2, 0x10+C_OFFSET_64(C)
  movaps C3, 0x20+C_OFFSET_64(C)
  movaps C4, 0x30+C_OFFSET_64(C)

  .align 16
block_352:

  # Check norm of product A(6,8)*B(8,4).
  movss 0xd4(multiply_stream, base_pointer), B1
  mulss 0x204(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_353

  # Reset C(6,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,4) = A(6,8)*B(8,4).
  movaps 0x0+B_OFFSET_84(B), B1
  movaps 0x10+B_OFFSET_84(B), B2
  movaps 0x20+B_OFFSET_84(B), B3
  movaps 0x30+B_OFFSET_84(B), B4
  movaps 0x0+A_OFFSET_68(A), A11
  movaps 0x10+A_OFFSET_68(A), A12
  movaps 0x20+A_OFFSET_68(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_68(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_68(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_68(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_68(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_68(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_68(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_68(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_68(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_68(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_68(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_68(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_68(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_68(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,4) to already existing.
  addps 0x0+C_OFFSET_64(C), C1
  addps 0x10+C_OFFSET_64(C), C2
  addps 0x20+C_OFFSET_64(C), C3
  addps 0x30+C_OFFSET_64(C), C4

  # Write out C(6,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_64(C)
  movaps C2, 0x10+C_OFFSET_64(C)
  movaps C3, 0x20+C_OFFSET_64(C)
  movaps C4, 0x30+C_OFFSET_64(C)

  .align 16
block_353:

  # Check norm of product A(7,5)*B(5,1).
  movss 0xe8(multiply_stream, base_pointer), B1
  mulss 0x198(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_354

  # Reset C(7,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,1) = A(7,5)*B(5,1).
  movaps 0x0+B_OFFSET_51(B), B1
  movaps 0x10+B_OFFSET_51(B), B2
  movaps 0x20+B_OFFSET_51(B), B3
  movaps 0x30+B_OFFSET_51(B), B4
  movaps 0x0+A_OFFSET_75(A), A11
  movaps 0x10+A_OFFSET_75(A), A12
  movaps 0x20+A_OFFSET_75(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_75(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_75(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_75(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_75(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_75(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_75(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_75(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_75(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_75(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_75(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_75(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_75(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_75(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,1) to already existing.
  addps 0x0+C_OFFSET_71(C), C1
  addps 0x10+C_OFFSET_71(C), C2
  addps 0x20+C_OFFSET_71(C), C3
  addps 0x30+C_OFFSET_71(C), C4

  # Write out C(7,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_71(C)
  movaps C2, 0x10+C_OFFSET_71(C)
  movaps C3, 0x20+C_OFFSET_71(C)
  movaps C4, 0x30+C_OFFSET_71(C)

  .align 16
block_354:

  # Check norm of product A(7,6)*B(6,1).
  movss 0xec(multiply_stream, base_pointer), B1
  mulss 0x1b8(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_355

  # Reset C(7,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,1) = A(7,6)*B(6,1).
  movaps 0x0+B_OFFSET_61(B), B1
  movaps 0x10+B_OFFSET_61(B), B2
  movaps 0x20+B_OFFSET_61(B), B3
  movaps 0x30+B_OFFSET_61(B), B4
  movaps 0x0+A_OFFSET_76(A), A11
  movaps 0x10+A_OFFSET_76(A), A12
  movaps 0x20+A_OFFSET_76(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_76(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_76(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_76(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_76(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_76(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_76(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_76(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_76(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_76(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_76(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_76(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_76(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_76(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,1) to already existing.
  addps 0x0+C_OFFSET_71(C), C1
  addps 0x10+C_OFFSET_71(C), C2
  addps 0x20+C_OFFSET_71(C), C3
  addps 0x30+C_OFFSET_71(C), C4

  # Write out C(7,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_71(C)
  movaps C2, 0x10+C_OFFSET_71(C)
  movaps C3, 0x20+C_OFFSET_71(C)
  movaps C4, 0x30+C_OFFSET_71(C)

  .align 16
block_355:

  # Check norm of product A(7,5)*B(5,2).
  movss 0xe8(multiply_stream, base_pointer), B1
  mulss 0x19c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_356

  # Reset C(7,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,2) = A(7,5)*B(5,2).
  movaps 0x0+B_OFFSET_52(B), B1
  movaps 0x10+B_OFFSET_52(B), B2
  movaps 0x20+B_OFFSET_52(B), B3
  movaps 0x30+B_OFFSET_52(B), B4
  movaps 0x0+A_OFFSET_75(A), A11
  movaps 0x10+A_OFFSET_75(A), A12
  movaps 0x20+A_OFFSET_75(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_75(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_75(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_75(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_75(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_75(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_75(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_75(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_75(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_75(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_75(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_75(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_75(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_75(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,2) to already existing.
  addps 0x0+C_OFFSET_72(C), C1
  addps 0x10+C_OFFSET_72(C), C2
  addps 0x20+C_OFFSET_72(C), C3
  addps 0x30+C_OFFSET_72(C), C4

  # Write out C(7,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_72(C)
  movaps C2, 0x10+C_OFFSET_72(C)
  movaps C3, 0x20+C_OFFSET_72(C)
  movaps C4, 0x30+C_OFFSET_72(C)

  .align 16
block_356:

  # Check norm of product A(7,6)*B(6,2).
  movss 0xec(multiply_stream, base_pointer), B1
  mulss 0x1bc(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_357

  # Reset C(7,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,2) = A(7,6)*B(6,2).
  movaps 0x0+B_OFFSET_62(B), B1
  movaps 0x10+B_OFFSET_62(B), B2
  movaps 0x20+B_OFFSET_62(B), B3
  movaps 0x30+B_OFFSET_62(B), B4
  movaps 0x0+A_OFFSET_76(A), A11
  movaps 0x10+A_OFFSET_76(A), A12
  movaps 0x20+A_OFFSET_76(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_76(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_76(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_76(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_76(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_76(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_76(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_76(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_76(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_76(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_76(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_76(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_76(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_76(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,2) to already existing.
  addps 0x0+C_OFFSET_72(C), C1
  addps 0x10+C_OFFSET_72(C), C2
  addps 0x20+C_OFFSET_72(C), C3
  addps 0x30+C_OFFSET_72(C), C4

  # Write out C(7,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_72(C)
  movaps C2, 0x10+C_OFFSET_72(C)
  movaps C3, 0x20+C_OFFSET_72(C)
  movaps C4, 0x30+C_OFFSET_72(C)

  .align 16
block_357:

  # Check norm of product A(8,5)*B(5,1).
  movss 0x108(multiply_stream, base_pointer), B1
  mulss 0x198(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_358

  # Reset C(8,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,1) = A(8,5)*B(5,1).
  movaps 0x0+B_OFFSET_51(B), B1
  movaps 0x10+B_OFFSET_51(B), B2
  movaps 0x20+B_OFFSET_51(B), B3
  movaps 0x30+B_OFFSET_51(B), B4
  movaps 0x0+A_OFFSET_85(A), A11
  movaps 0x10+A_OFFSET_85(A), A12
  movaps 0x20+A_OFFSET_85(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_85(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_85(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_85(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_85(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_85(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_85(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_85(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_85(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_85(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_85(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_85(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_85(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_85(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,1) to already existing.
  addps 0x0+C_OFFSET_81(C), C1
  addps 0x10+C_OFFSET_81(C), C2
  addps 0x20+C_OFFSET_81(C), C3
  addps 0x30+C_OFFSET_81(C), C4

  # Write out C(8,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_81(C)
  movaps C2, 0x10+C_OFFSET_81(C)
  movaps C3, 0x20+C_OFFSET_81(C)
  movaps C4, 0x30+C_OFFSET_81(C)

  .align 16
block_358:

  # Check norm of product A(8,6)*B(6,1).
  movss 0x10c(multiply_stream, base_pointer), B1
  mulss 0x1b8(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_359

  # Reset C(8,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,1) = A(8,6)*B(6,1).
  movaps 0x0+B_OFFSET_61(B), B1
  movaps 0x10+B_OFFSET_61(B), B2
  movaps 0x20+B_OFFSET_61(B), B3
  movaps 0x30+B_OFFSET_61(B), B4
  movaps 0x0+A_OFFSET_86(A), A11
  movaps 0x10+A_OFFSET_86(A), A12
  movaps 0x20+A_OFFSET_86(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_86(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_86(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_86(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_86(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_86(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_86(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_86(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_86(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_86(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_86(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_86(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_86(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_86(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,1) to already existing.
  addps 0x0+C_OFFSET_81(C), C1
  addps 0x10+C_OFFSET_81(C), C2
  addps 0x20+C_OFFSET_81(C), C3
  addps 0x30+C_OFFSET_81(C), C4

  # Write out C(8,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_81(C)
  movaps C2, 0x10+C_OFFSET_81(C)
  movaps C3, 0x20+C_OFFSET_81(C)
  movaps C4, 0x30+C_OFFSET_81(C)

  .align 16
block_359:

  # Check norm of product A(8,5)*B(5,2).
  movss 0x108(multiply_stream, base_pointer), B1
  mulss 0x19c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_360

  # Reset C(8,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,2) = A(8,5)*B(5,2).
  movaps 0x0+B_OFFSET_52(B), B1
  movaps 0x10+B_OFFSET_52(B), B2
  movaps 0x20+B_OFFSET_52(B), B3
  movaps 0x30+B_OFFSET_52(B), B4
  movaps 0x0+A_OFFSET_85(A), A11
  movaps 0x10+A_OFFSET_85(A), A12
  movaps 0x20+A_OFFSET_85(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_85(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_85(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_85(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_85(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_85(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_85(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_85(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_85(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_85(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_85(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_85(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_85(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_85(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,2) to already existing.
  addps 0x0+C_OFFSET_82(C), C1
  addps 0x10+C_OFFSET_82(C), C2
  addps 0x20+C_OFFSET_82(C), C3
  addps 0x30+C_OFFSET_82(C), C4

  # Write out C(8,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_82(C)
  movaps C2, 0x10+C_OFFSET_82(C)
  movaps C3, 0x20+C_OFFSET_82(C)
  movaps C4, 0x30+C_OFFSET_82(C)

  .align 16
block_360:

  # Check norm of product A(8,6)*B(6,2).
  movss 0x10c(multiply_stream, base_pointer), B1
  mulss 0x1bc(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_361

  # Reset C(8,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,2) = A(8,6)*B(6,2).
  movaps 0x0+B_OFFSET_62(B), B1
  movaps 0x10+B_OFFSET_62(B), B2
  movaps 0x20+B_OFFSET_62(B), B3
  movaps 0x30+B_OFFSET_62(B), B4
  movaps 0x0+A_OFFSET_86(A), A11
  movaps 0x10+A_OFFSET_86(A), A12
  movaps 0x20+A_OFFSET_86(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_86(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_86(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_86(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_86(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_86(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_86(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_86(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_86(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_86(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_86(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_86(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_86(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_86(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,2) to already existing.
  addps 0x0+C_OFFSET_82(C), C1
  addps 0x10+C_OFFSET_82(C), C2
  addps 0x20+C_OFFSET_82(C), C3
  addps 0x30+C_OFFSET_82(C), C4

  # Write out C(8,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_82(C)
  movaps C2, 0x10+C_OFFSET_82(C)
  movaps C3, 0x20+C_OFFSET_82(C)
  movaps C4, 0x30+C_OFFSET_82(C)

  .align 16
block_361:

  # Check norm of product A(7,7)*B(7,1).
  movss 0xf0(multiply_stream, base_pointer), B1
  mulss 0x1d8(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_362

  # Reset C(7,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,1) = A(7,7)*B(7,1).
  movaps 0x0+B_OFFSET_71(B), B1
  movaps 0x10+B_OFFSET_71(B), B2
  movaps 0x20+B_OFFSET_71(B), B3
  movaps 0x30+B_OFFSET_71(B), B4
  movaps 0x0+A_OFFSET_77(A), A11
  movaps 0x10+A_OFFSET_77(A), A12
  movaps 0x20+A_OFFSET_77(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_77(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_77(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_77(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_77(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_77(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_77(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_77(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_77(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_77(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_77(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_77(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_77(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_77(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,1) to already existing.
  addps 0x0+C_OFFSET_71(C), C1
  addps 0x10+C_OFFSET_71(C), C2
  addps 0x20+C_OFFSET_71(C), C3
  addps 0x30+C_OFFSET_71(C), C4

  # Write out C(7,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_71(C)
  movaps C2, 0x10+C_OFFSET_71(C)
  movaps C3, 0x20+C_OFFSET_71(C)
  movaps C4, 0x30+C_OFFSET_71(C)

  .align 16
block_362:

  # Check norm of product A(7,8)*B(8,1).
  movss 0xf4(multiply_stream, base_pointer), B1
  mulss 0x1f8(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_363

  # Reset C(7,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,1) = A(7,8)*B(8,1).
  movaps 0x0+B_OFFSET_81(B), B1
  movaps 0x10+B_OFFSET_81(B), B2
  movaps 0x20+B_OFFSET_81(B), B3
  movaps 0x30+B_OFFSET_81(B), B4
  movaps 0x0+A_OFFSET_78(A), A11
  movaps 0x10+A_OFFSET_78(A), A12
  movaps 0x20+A_OFFSET_78(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_78(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_78(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_78(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_78(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_78(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_78(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_78(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_78(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_78(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_78(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_78(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_78(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_78(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,1) to already existing.
  addps 0x0+C_OFFSET_71(C), C1
  addps 0x10+C_OFFSET_71(C), C2
  addps 0x20+C_OFFSET_71(C), C3
  addps 0x30+C_OFFSET_71(C), C4

  # Write out C(7,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_71(C)
  movaps C2, 0x10+C_OFFSET_71(C)
  movaps C3, 0x20+C_OFFSET_71(C)
  movaps C4, 0x30+C_OFFSET_71(C)

  .align 16
block_363:

  # Check norm of product A(7,7)*B(7,2).
  movss 0xf0(multiply_stream, base_pointer), B1
  mulss 0x1dc(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_364

  # Reset C(7,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,2) = A(7,7)*B(7,2).
  movaps 0x0+B_OFFSET_72(B), B1
  movaps 0x10+B_OFFSET_72(B), B2
  movaps 0x20+B_OFFSET_72(B), B3
  movaps 0x30+B_OFFSET_72(B), B4
  movaps 0x0+A_OFFSET_77(A), A11
  movaps 0x10+A_OFFSET_77(A), A12
  movaps 0x20+A_OFFSET_77(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_77(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_77(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_77(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_77(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_77(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_77(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_77(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_77(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_77(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_77(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_77(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_77(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_77(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,2) to already existing.
  addps 0x0+C_OFFSET_72(C), C1
  addps 0x10+C_OFFSET_72(C), C2
  addps 0x20+C_OFFSET_72(C), C3
  addps 0x30+C_OFFSET_72(C), C4

  # Write out C(7,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_72(C)
  movaps C2, 0x10+C_OFFSET_72(C)
  movaps C3, 0x20+C_OFFSET_72(C)
  movaps C4, 0x30+C_OFFSET_72(C)

  .align 16
block_364:

  # Check norm of product A(7,8)*B(8,2).
  movss 0xf4(multiply_stream, base_pointer), B1
  mulss 0x1fc(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_365

  # Reset C(7,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,2) = A(7,8)*B(8,2).
  movaps 0x0+B_OFFSET_82(B), B1
  movaps 0x10+B_OFFSET_82(B), B2
  movaps 0x20+B_OFFSET_82(B), B3
  movaps 0x30+B_OFFSET_82(B), B4
  movaps 0x0+A_OFFSET_78(A), A11
  movaps 0x10+A_OFFSET_78(A), A12
  movaps 0x20+A_OFFSET_78(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_78(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_78(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_78(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_78(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_78(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_78(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_78(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_78(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_78(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_78(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_78(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_78(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_78(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,2) to already existing.
  addps 0x0+C_OFFSET_72(C), C1
  addps 0x10+C_OFFSET_72(C), C2
  addps 0x20+C_OFFSET_72(C), C3
  addps 0x30+C_OFFSET_72(C), C4

  # Write out C(7,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_72(C)
  movaps C2, 0x10+C_OFFSET_72(C)
  movaps C3, 0x20+C_OFFSET_72(C)
  movaps C4, 0x30+C_OFFSET_72(C)

  .align 16
block_365:

  # Check norm of product A(8,7)*B(7,1).
  movss 0x110(multiply_stream, base_pointer), B1
  mulss 0x1d8(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_366

  # Reset C(8,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,1) = A(8,7)*B(7,1).
  movaps 0x0+B_OFFSET_71(B), B1
  movaps 0x10+B_OFFSET_71(B), B2
  movaps 0x20+B_OFFSET_71(B), B3
  movaps 0x30+B_OFFSET_71(B), B4
  movaps 0x0+A_OFFSET_87(A), A11
  movaps 0x10+A_OFFSET_87(A), A12
  movaps 0x20+A_OFFSET_87(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_87(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_87(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_87(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_87(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_87(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_87(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_87(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_87(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_87(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_87(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_87(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_87(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_87(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,1) to already existing.
  addps 0x0+C_OFFSET_81(C), C1
  addps 0x10+C_OFFSET_81(C), C2
  addps 0x20+C_OFFSET_81(C), C3
  addps 0x30+C_OFFSET_81(C), C4

  # Write out C(8,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_81(C)
  movaps C2, 0x10+C_OFFSET_81(C)
  movaps C3, 0x20+C_OFFSET_81(C)
  movaps C4, 0x30+C_OFFSET_81(C)

  .align 16
block_366:

  # Check norm of product A(8,8)*B(8,1).
  movss 0x114(multiply_stream, base_pointer), B1
  mulss 0x1f8(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_367

  # Reset C(8,1) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,1) = A(8,8)*B(8,1).
  movaps 0x0+B_OFFSET_81(B), B1
  movaps 0x10+B_OFFSET_81(B), B2
  movaps 0x20+B_OFFSET_81(B), B3
  movaps 0x30+B_OFFSET_81(B), B4
  movaps 0x0+A_OFFSET_88(A), A11
  movaps 0x10+A_OFFSET_88(A), A12
  movaps 0x20+A_OFFSET_88(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_88(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_88(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_88(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_88(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_88(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_88(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_88(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_88(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_88(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_88(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_88(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_88(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_88(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,1) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,1) to already existing.
  addps 0x0+C_OFFSET_81(C), C1
  addps 0x10+C_OFFSET_81(C), C2
  addps 0x20+C_OFFSET_81(C), C3
  addps 0x30+C_OFFSET_81(C), C4

  # Write out C(8,1) submatrix block.
  movaps C1, 0x0+C_OFFSET_81(C)
  movaps C2, 0x10+C_OFFSET_81(C)
  movaps C3, 0x20+C_OFFSET_81(C)
  movaps C4, 0x30+C_OFFSET_81(C)

  .align 16
block_367:

  # Check norm of product A(8,7)*B(7,2).
  movss 0x110(multiply_stream, base_pointer), B1
  mulss 0x1dc(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_368

  # Reset C(8,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,2) = A(8,7)*B(7,2).
  movaps 0x0+B_OFFSET_72(B), B1
  movaps 0x10+B_OFFSET_72(B), B2
  movaps 0x20+B_OFFSET_72(B), B3
  movaps 0x30+B_OFFSET_72(B), B4
  movaps 0x0+A_OFFSET_87(A), A11
  movaps 0x10+A_OFFSET_87(A), A12
  movaps 0x20+A_OFFSET_87(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_87(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_87(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_87(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_87(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_87(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_87(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_87(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_87(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_87(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_87(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_87(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_87(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_87(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,2) to already existing.
  addps 0x0+C_OFFSET_82(C), C1
  addps 0x10+C_OFFSET_82(C), C2
  addps 0x20+C_OFFSET_82(C), C3
  addps 0x30+C_OFFSET_82(C), C4

  # Write out C(8,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_82(C)
  movaps C2, 0x10+C_OFFSET_82(C)
  movaps C3, 0x20+C_OFFSET_82(C)
  movaps C4, 0x30+C_OFFSET_82(C)

  .align 16
block_368:

  # Check norm of product A(8,8)*B(8,2).
  movss 0x114(multiply_stream, base_pointer), B1
  mulss 0x1fc(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_369

  # Reset C(8,2) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,2) = A(8,8)*B(8,2).
  movaps 0x0+B_OFFSET_82(B), B1
  movaps 0x10+B_OFFSET_82(B), B2
  movaps 0x20+B_OFFSET_82(B), B3
  movaps 0x30+B_OFFSET_82(B), B4
  movaps 0x0+A_OFFSET_88(A), A11
  movaps 0x10+A_OFFSET_88(A), A12
  movaps 0x20+A_OFFSET_88(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_88(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_88(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_88(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_88(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_88(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_88(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_88(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_88(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_88(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_88(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_88(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_88(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_88(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,2) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,2) to already existing.
  addps 0x0+C_OFFSET_82(C), C1
  addps 0x10+C_OFFSET_82(C), C2
  addps 0x20+C_OFFSET_82(C), C3
  addps 0x30+C_OFFSET_82(C), C4

  # Write out C(8,2) submatrix block.
  movaps C1, 0x0+C_OFFSET_82(C)
  movaps C2, 0x10+C_OFFSET_82(C)
  movaps C3, 0x20+C_OFFSET_82(C)
  movaps C4, 0x30+C_OFFSET_82(C)

  .align 16
block_369:

  # Check norm of product A(7,5)*B(5,3).
  movss 0xe8(multiply_stream, base_pointer), B1
  mulss 0x1a0(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_370

  # Reset C(7,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,3) = A(7,5)*B(5,3).
  movaps 0x0+B_OFFSET_53(B), B1
  movaps 0x10+B_OFFSET_53(B), B2
  movaps 0x20+B_OFFSET_53(B), B3
  movaps 0x30+B_OFFSET_53(B), B4
  movaps 0x0+A_OFFSET_75(A), A11
  movaps 0x10+A_OFFSET_75(A), A12
  movaps 0x20+A_OFFSET_75(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_75(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_75(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_75(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_75(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_75(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_75(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_75(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_75(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_75(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_75(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_75(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_75(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_75(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,3) to already existing.
  addps 0x0+C_OFFSET_73(C), C1
  addps 0x10+C_OFFSET_73(C), C2
  addps 0x20+C_OFFSET_73(C), C3
  addps 0x30+C_OFFSET_73(C), C4

  # Write out C(7,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_73(C)
  movaps C2, 0x10+C_OFFSET_73(C)
  movaps C3, 0x20+C_OFFSET_73(C)
  movaps C4, 0x30+C_OFFSET_73(C)

  .align 16
block_370:

  # Check norm of product A(7,6)*B(6,3).
  movss 0xec(multiply_stream, base_pointer), B1
  mulss 0x1c0(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_371

  # Reset C(7,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,3) = A(7,6)*B(6,3).
  movaps 0x0+B_OFFSET_63(B), B1
  movaps 0x10+B_OFFSET_63(B), B2
  movaps 0x20+B_OFFSET_63(B), B3
  movaps 0x30+B_OFFSET_63(B), B4
  movaps 0x0+A_OFFSET_76(A), A11
  movaps 0x10+A_OFFSET_76(A), A12
  movaps 0x20+A_OFFSET_76(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_76(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_76(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_76(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_76(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_76(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_76(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_76(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_76(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_76(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_76(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_76(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_76(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_76(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,3) to already existing.
  addps 0x0+C_OFFSET_73(C), C1
  addps 0x10+C_OFFSET_73(C), C2
  addps 0x20+C_OFFSET_73(C), C3
  addps 0x30+C_OFFSET_73(C), C4

  # Write out C(7,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_73(C)
  movaps C2, 0x10+C_OFFSET_73(C)
  movaps C3, 0x20+C_OFFSET_73(C)
  movaps C4, 0x30+C_OFFSET_73(C)

  .align 16
block_371:

  # Check norm of product A(7,5)*B(5,4).
  movss 0xe8(multiply_stream, base_pointer), B1
  mulss 0x1a4(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_372

  # Reset C(7,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,4) = A(7,5)*B(5,4).
  movaps 0x0+B_OFFSET_54(B), B1
  movaps 0x10+B_OFFSET_54(B), B2
  movaps 0x20+B_OFFSET_54(B), B3
  movaps 0x30+B_OFFSET_54(B), B4
  movaps 0x0+A_OFFSET_75(A), A11
  movaps 0x10+A_OFFSET_75(A), A12
  movaps 0x20+A_OFFSET_75(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_75(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_75(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_75(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_75(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_75(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_75(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_75(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_75(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_75(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_75(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_75(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_75(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_75(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,4) to already existing.
  addps 0x0+C_OFFSET_74(C), C1
  addps 0x10+C_OFFSET_74(C), C2
  addps 0x20+C_OFFSET_74(C), C3
  addps 0x30+C_OFFSET_74(C), C4

  # Write out C(7,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_74(C)
  movaps C2, 0x10+C_OFFSET_74(C)
  movaps C3, 0x20+C_OFFSET_74(C)
  movaps C4, 0x30+C_OFFSET_74(C)

  .align 16
block_372:

  # Check norm of product A(7,6)*B(6,4).
  movss 0xec(multiply_stream, base_pointer), B1
  mulss 0x1c4(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_373

  # Reset C(7,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,4) = A(7,6)*B(6,4).
  movaps 0x0+B_OFFSET_64(B), B1
  movaps 0x10+B_OFFSET_64(B), B2
  movaps 0x20+B_OFFSET_64(B), B3
  movaps 0x30+B_OFFSET_64(B), B4
  movaps 0x0+A_OFFSET_76(A), A11
  movaps 0x10+A_OFFSET_76(A), A12
  movaps 0x20+A_OFFSET_76(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_76(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_76(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_76(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_76(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_76(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_76(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_76(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_76(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_76(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_76(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_76(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_76(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_76(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,4) to already existing.
  addps 0x0+C_OFFSET_74(C), C1
  addps 0x10+C_OFFSET_74(C), C2
  addps 0x20+C_OFFSET_74(C), C3
  addps 0x30+C_OFFSET_74(C), C4

  # Write out C(7,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_74(C)
  movaps C2, 0x10+C_OFFSET_74(C)
  movaps C3, 0x20+C_OFFSET_74(C)
  movaps C4, 0x30+C_OFFSET_74(C)

  .align 16
block_373:

  # Check norm of product A(8,5)*B(5,3).
  movss 0x108(multiply_stream, base_pointer), B1
  mulss 0x1a0(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_374

  # Reset C(8,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,3) = A(8,5)*B(5,3).
  movaps 0x0+B_OFFSET_53(B), B1
  movaps 0x10+B_OFFSET_53(B), B2
  movaps 0x20+B_OFFSET_53(B), B3
  movaps 0x30+B_OFFSET_53(B), B4
  movaps 0x0+A_OFFSET_85(A), A11
  movaps 0x10+A_OFFSET_85(A), A12
  movaps 0x20+A_OFFSET_85(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_85(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_85(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_85(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_85(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_85(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_85(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_85(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_85(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_85(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_85(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_85(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_85(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_85(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,3) to already existing.
  addps 0x0+C_OFFSET_83(C), C1
  addps 0x10+C_OFFSET_83(C), C2
  addps 0x20+C_OFFSET_83(C), C3
  addps 0x30+C_OFFSET_83(C), C4

  # Write out C(8,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_83(C)
  movaps C2, 0x10+C_OFFSET_83(C)
  movaps C3, 0x20+C_OFFSET_83(C)
  movaps C4, 0x30+C_OFFSET_83(C)

  .align 16
block_374:

  # Check norm of product A(8,6)*B(6,3).
  movss 0x10c(multiply_stream, base_pointer), B1
  mulss 0x1c0(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_375

  # Reset C(8,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,3) = A(8,6)*B(6,3).
  movaps 0x0+B_OFFSET_63(B), B1
  movaps 0x10+B_OFFSET_63(B), B2
  movaps 0x20+B_OFFSET_63(B), B3
  movaps 0x30+B_OFFSET_63(B), B4
  movaps 0x0+A_OFFSET_86(A), A11
  movaps 0x10+A_OFFSET_86(A), A12
  movaps 0x20+A_OFFSET_86(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_86(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_86(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_86(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_86(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_86(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_86(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_86(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_86(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_86(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_86(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_86(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_86(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_86(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,3) to already existing.
  addps 0x0+C_OFFSET_83(C), C1
  addps 0x10+C_OFFSET_83(C), C2
  addps 0x20+C_OFFSET_83(C), C3
  addps 0x30+C_OFFSET_83(C), C4

  # Write out C(8,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_83(C)
  movaps C2, 0x10+C_OFFSET_83(C)
  movaps C3, 0x20+C_OFFSET_83(C)
  movaps C4, 0x30+C_OFFSET_83(C)

  .align 16
block_375:

  # Check norm of product A(8,5)*B(5,4).
  movss 0x108(multiply_stream, base_pointer), B1
  mulss 0x1a4(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_376

  # Reset C(8,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,4) = A(8,5)*B(5,4).
  movaps 0x0+B_OFFSET_54(B), B1
  movaps 0x10+B_OFFSET_54(B), B2
  movaps 0x20+B_OFFSET_54(B), B3
  movaps 0x30+B_OFFSET_54(B), B4
  movaps 0x0+A_OFFSET_85(A), A11
  movaps 0x10+A_OFFSET_85(A), A12
  movaps 0x20+A_OFFSET_85(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_85(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_85(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_85(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_85(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_85(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_85(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_85(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_85(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_85(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_85(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_85(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_85(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_85(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,4) to already existing.
  addps 0x0+C_OFFSET_84(C), C1
  addps 0x10+C_OFFSET_84(C), C2
  addps 0x20+C_OFFSET_84(C), C3
  addps 0x30+C_OFFSET_84(C), C4

  # Write out C(8,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_84(C)
  movaps C2, 0x10+C_OFFSET_84(C)
  movaps C3, 0x20+C_OFFSET_84(C)
  movaps C4, 0x30+C_OFFSET_84(C)

  .align 16
block_376:

  # Check norm of product A(8,6)*B(6,4).
  movss 0x10c(multiply_stream, base_pointer), B1
  mulss 0x1c4(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_377

  # Reset C(8,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,4) = A(8,6)*B(6,4).
  movaps 0x0+B_OFFSET_64(B), B1
  movaps 0x10+B_OFFSET_64(B), B2
  movaps 0x20+B_OFFSET_64(B), B3
  movaps 0x30+B_OFFSET_64(B), B4
  movaps 0x0+A_OFFSET_86(A), A11
  movaps 0x10+A_OFFSET_86(A), A12
  movaps 0x20+A_OFFSET_86(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_86(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_86(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_86(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_86(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_86(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_86(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_86(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_86(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_86(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_86(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_86(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_86(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_86(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,4) to already existing.
  addps 0x0+C_OFFSET_84(C), C1
  addps 0x10+C_OFFSET_84(C), C2
  addps 0x20+C_OFFSET_84(C), C3
  addps 0x30+C_OFFSET_84(C), C4

  # Write out C(8,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_84(C)
  movaps C2, 0x10+C_OFFSET_84(C)
  movaps C3, 0x20+C_OFFSET_84(C)
  movaps C4, 0x30+C_OFFSET_84(C)

  .align 16
block_377:

  # Check norm of product A(7,7)*B(7,3).
  movss 0xf0(multiply_stream, base_pointer), B1
  mulss 0x1e0(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_378

  # Reset C(7,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,3) = A(7,7)*B(7,3).
  movaps 0x0+B_OFFSET_73(B), B1
  movaps 0x10+B_OFFSET_73(B), B2
  movaps 0x20+B_OFFSET_73(B), B3
  movaps 0x30+B_OFFSET_73(B), B4
  movaps 0x0+A_OFFSET_77(A), A11
  movaps 0x10+A_OFFSET_77(A), A12
  movaps 0x20+A_OFFSET_77(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_77(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_77(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_77(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_77(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_77(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_77(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_77(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_77(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_77(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_77(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_77(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_77(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_77(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,3) to already existing.
  addps 0x0+C_OFFSET_73(C), C1
  addps 0x10+C_OFFSET_73(C), C2
  addps 0x20+C_OFFSET_73(C), C3
  addps 0x30+C_OFFSET_73(C), C4

  # Write out C(7,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_73(C)
  movaps C2, 0x10+C_OFFSET_73(C)
  movaps C3, 0x20+C_OFFSET_73(C)
  movaps C4, 0x30+C_OFFSET_73(C)

  .align 16
block_378:

  # Check norm of product A(7,8)*B(8,3).
  movss 0xf4(multiply_stream, base_pointer), B1
  mulss 0x200(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_379

  # Reset C(7,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,3) = A(7,8)*B(8,3).
  movaps 0x0+B_OFFSET_83(B), B1
  movaps 0x10+B_OFFSET_83(B), B2
  movaps 0x20+B_OFFSET_83(B), B3
  movaps 0x30+B_OFFSET_83(B), B4
  movaps 0x0+A_OFFSET_78(A), A11
  movaps 0x10+A_OFFSET_78(A), A12
  movaps 0x20+A_OFFSET_78(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_78(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_78(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_78(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_78(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_78(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_78(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_78(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_78(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_78(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_78(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_78(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_78(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_78(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,3) to already existing.
  addps 0x0+C_OFFSET_73(C), C1
  addps 0x10+C_OFFSET_73(C), C2
  addps 0x20+C_OFFSET_73(C), C3
  addps 0x30+C_OFFSET_73(C), C4

  # Write out C(7,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_73(C)
  movaps C2, 0x10+C_OFFSET_73(C)
  movaps C3, 0x20+C_OFFSET_73(C)
  movaps C4, 0x30+C_OFFSET_73(C)

  .align 16
block_379:

  # Check norm of product A(7,7)*B(7,4).
  movss 0xf0(multiply_stream, base_pointer), B1
  mulss 0x1e4(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_380

  # Reset C(7,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,4) = A(7,7)*B(7,4).
  movaps 0x0+B_OFFSET_74(B), B1
  movaps 0x10+B_OFFSET_74(B), B2
  movaps 0x20+B_OFFSET_74(B), B3
  movaps 0x30+B_OFFSET_74(B), B4
  movaps 0x0+A_OFFSET_77(A), A11
  movaps 0x10+A_OFFSET_77(A), A12
  movaps 0x20+A_OFFSET_77(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_77(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_77(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_77(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_77(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_77(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_77(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_77(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_77(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_77(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_77(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_77(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_77(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_77(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,4) to already existing.
  addps 0x0+C_OFFSET_74(C), C1
  addps 0x10+C_OFFSET_74(C), C2
  addps 0x20+C_OFFSET_74(C), C3
  addps 0x30+C_OFFSET_74(C), C4

  # Write out C(7,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_74(C)
  movaps C2, 0x10+C_OFFSET_74(C)
  movaps C3, 0x20+C_OFFSET_74(C)
  movaps C4, 0x30+C_OFFSET_74(C)

  .align 16
block_380:

  # Check norm of product A(7,8)*B(8,4).
  movss 0xf4(multiply_stream, base_pointer), B1
  mulss 0x204(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_381

  # Reset C(7,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,4) = A(7,8)*B(8,4).
  movaps 0x0+B_OFFSET_84(B), B1
  movaps 0x10+B_OFFSET_84(B), B2
  movaps 0x20+B_OFFSET_84(B), B3
  movaps 0x30+B_OFFSET_84(B), B4
  movaps 0x0+A_OFFSET_78(A), A11
  movaps 0x10+A_OFFSET_78(A), A12
  movaps 0x20+A_OFFSET_78(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_78(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_78(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_78(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_78(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_78(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_78(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_78(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_78(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_78(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_78(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_78(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_78(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_78(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,4) to already existing.
  addps 0x0+C_OFFSET_74(C), C1
  addps 0x10+C_OFFSET_74(C), C2
  addps 0x20+C_OFFSET_74(C), C3
  addps 0x30+C_OFFSET_74(C), C4

  # Write out C(7,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_74(C)
  movaps C2, 0x10+C_OFFSET_74(C)
  movaps C3, 0x20+C_OFFSET_74(C)
  movaps C4, 0x30+C_OFFSET_74(C)

  .align 16
block_381:

  # Check norm of product A(8,7)*B(7,3).
  movss 0x110(multiply_stream, base_pointer), B1
  mulss 0x1e0(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_382

  # Reset C(8,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,3) = A(8,7)*B(7,3).
  movaps 0x0+B_OFFSET_73(B), B1
  movaps 0x10+B_OFFSET_73(B), B2
  movaps 0x20+B_OFFSET_73(B), B3
  movaps 0x30+B_OFFSET_73(B), B4
  movaps 0x0+A_OFFSET_87(A), A11
  movaps 0x10+A_OFFSET_87(A), A12
  movaps 0x20+A_OFFSET_87(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_87(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_87(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_87(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_87(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_87(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_87(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_87(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_87(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_87(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_87(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_87(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_87(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_87(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,3) to already existing.
  addps 0x0+C_OFFSET_83(C), C1
  addps 0x10+C_OFFSET_83(C), C2
  addps 0x20+C_OFFSET_83(C), C3
  addps 0x30+C_OFFSET_83(C), C4

  # Write out C(8,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_83(C)
  movaps C2, 0x10+C_OFFSET_83(C)
  movaps C3, 0x20+C_OFFSET_83(C)
  movaps C4, 0x30+C_OFFSET_83(C)

  .align 16
block_382:

  # Check norm of product A(8,8)*B(8,3).
  movss 0x114(multiply_stream, base_pointer), B1
  mulss 0x200(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_383

  # Reset C(8,3) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,3) = A(8,8)*B(8,3).
  movaps 0x0+B_OFFSET_83(B), B1
  movaps 0x10+B_OFFSET_83(B), B2
  movaps 0x20+B_OFFSET_83(B), B3
  movaps 0x30+B_OFFSET_83(B), B4
  movaps 0x0+A_OFFSET_88(A), A11
  movaps 0x10+A_OFFSET_88(A), A12
  movaps 0x20+A_OFFSET_88(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_88(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_88(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_88(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_88(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_88(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_88(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_88(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_88(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_88(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_88(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_88(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_88(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_88(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,3) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,3) to already existing.
  addps 0x0+C_OFFSET_83(C), C1
  addps 0x10+C_OFFSET_83(C), C2
  addps 0x20+C_OFFSET_83(C), C3
  addps 0x30+C_OFFSET_83(C), C4

  # Write out C(8,3) submatrix block.
  movaps C1, 0x0+C_OFFSET_83(C)
  movaps C2, 0x10+C_OFFSET_83(C)
  movaps C3, 0x20+C_OFFSET_83(C)
  movaps C4, 0x30+C_OFFSET_83(C)

  .align 16
block_383:

  # Check norm of product A(8,7)*B(7,4).
  movss 0x110(multiply_stream, base_pointer), B1
  mulss 0x1e4(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_384

  # Reset C(8,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,4) = A(8,7)*B(7,4).
  movaps 0x0+B_OFFSET_74(B), B1
  movaps 0x10+B_OFFSET_74(B), B2
  movaps 0x20+B_OFFSET_74(B), B3
  movaps 0x30+B_OFFSET_74(B), B4
  movaps 0x0+A_OFFSET_87(A), A11
  movaps 0x10+A_OFFSET_87(A), A12
  movaps 0x20+A_OFFSET_87(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_87(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_87(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_87(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_87(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_87(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_87(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_87(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_87(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_87(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_87(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_87(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_87(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_87(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,4) to already existing.
  addps 0x0+C_OFFSET_84(C), C1
  addps 0x10+C_OFFSET_84(C), C2
  addps 0x20+C_OFFSET_84(C), C3
  addps 0x30+C_OFFSET_84(C), C4

  # Write out C(8,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_84(C)
  movaps C2, 0x10+C_OFFSET_84(C)
  movaps C3, 0x20+C_OFFSET_84(C)
  movaps C4, 0x30+C_OFFSET_84(C)

  .align 16
block_384:

  # Check norm of product A(8,8)*B(8,4).
  movss 0x114(multiply_stream, base_pointer), B1
  mulss 0x204(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_385

  # Reset C(8,4) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,4) = A(8,8)*B(8,4).
  movaps 0x0+B_OFFSET_84(B), B1
  movaps 0x10+B_OFFSET_84(B), B2
  movaps 0x20+B_OFFSET_84(B), B3
  movaps 0x30+B_OFFSET_84(B), B4
  movaps 0x0+A_OFFSET_88(A), A11
  movaps 0x10+A_OFFSET_88(A), A12
  movaps 0x20+A_OFFSET_88(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_88(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_88(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_88(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_88(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_88(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_88(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_88(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_88(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_88(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_88(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_88(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_88(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_88(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,4) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,4) to already existing.
  addps 0x0+C_OFFSET_84(C), C1
  addps 0x10+C_OFFSET_84(C), C2
  addps 0x20+C_OFFSET_84(C), C3
  addps 0x30+C_OFFSET_84(C), C4

  # Write out C(8,4) submatrix block.
  movaps C1, 0x0+C_OFFSET_84(C)
  movaps C2, 0x10+C_OFFSET_84(C)
  movaps C3, 0x20+C_OFFSET_84(C)
  movaps C4, 0x30+C_OFFSET_84(C)

  .align 16
block_385:

  # Check norm of product A(5,1)*B(1,5).
  movss 0x98(multiply_stream, base_pointer), B1
  mulss 0x128(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_386

  # Reset C(5,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,5) = A(5,1)*B(1,5).
  movaps 0x0+B_OFFSET_15(B), B1
  movaps 0x10+B_OFFSET_15(B), B2
  movaps 0x20+B_OFFSET_15(B), B3
  movaps 0x30+B_OFFSET_15(B), B4
  movaps 0x0+A_OFFSET_51(A), A11
  movaps 0x10+A_OFFSET_51(A), A12
  movaps 0x20+A_OFFSET_51(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_51(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_51(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_51(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_51(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_51(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_51(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_51(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_51(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_51(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_51(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_51(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_51(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_51(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,5) to already existing.
  addps 0x0+C_OFFSET_55(C), C1
  addps 0x10+C_OFFSET_55(C), C2
  addps 0x20+C_OFFSET_55(C), C3
  addps 0x30+C_OFFSET_55(C), C4

  # Write out C(5,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_55(C)
  movaps C2, 0x10+C_OFFSET_55(C)
  movaps C3, 0x20+C_OFFSET_55(C)
  movaps C4, 0x30+C_OFFSET_55(C)

  .align 16
block_386:

  # Check norm of product A(5,2)*B(2,5).
  movss 0x9c(multiply_stream, base_pointer), B1
  mulss 0x148(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_387

  # Reset C(5,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,5) = A(5,2)*B(2,5).
  movaps 0x0+B_OFFSET_25(B), B1
  movaps 0x10+B_OFFSET_25(B), B2
  movaps 0x20+B_OFFSET_25(B), B3
  movaps 0x30+B_OFFSET_25(B), B4
  movaps 0x0+A_OFFSET_52(A), A11
  movaps 0x10+A_OFFSET_52(A), A12
  movaps 0x20+A_OFFSET_52(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_52(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_52(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_52(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_52(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_52(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_52(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_52(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_52(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_52(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_52(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_52(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_52(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_52(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,5) to already existing.
  addps 0x0+C_OFFSET_55(C), C1
  addps 0x10+C_OFFSET_55(C), C2
  addps 0x20+C_OFFSET_55(C), C3
  addps 0x30+C_OFFSET_55(C), C4

  # Write out C(5,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_55(C)
  movaps C2, 0x10+C_OFFSET_55(C)
  movaps C3, 0x20+C_OFFSET_55(C)
  movaps C4, 0x30+C_OFFSET_55(C)

  .align 16
block_387:

  # Check norm of product A(5,1)*B(1,6).
  movss 0x98(multiply_stream, base_pointer), B1
  mulss 0x12c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_388

  # Reset C(5,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,6) = A(5,1)*B(1,6).
  movaps 0x0+B_OFFSET_16(B), B1
  movaps 0x10+B_OFFSET_16(B), B2
  movaps 0x20+B_OFFSET_16(B), B3
  movaps 0x30+B_OFFSET_16(B), B4
  movaps 0x0+A_OFFSET_51(A), A11
  movaps 0x10+A_OFFSET_51(A), A12
  movaps 0x20+A_OFFSET_51(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_51(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_51(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_51(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_51(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_51(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_51(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_51(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_51(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_51(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_51(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_51(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_51(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_51(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,6) to already existing.
  addps 0x0+C_OFFSET_56(C), C1
  addps 0x10+C_OFFSET_56(C), C2
  addps 0x20+C_OFFSET_56(C), C3
  addps 0x30+C_OFFSET_56(C), C4

  # Write out C(5,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_56(C)
  movaps C2, 0x10+C_OFFSET_56(C)
  movaps C3, 0x20+C_OFFSET_56(C)
  movaps C4, 0x30+C_OFFSET_56(C)

  .align 16
block_388:

  # Check norm of product A(5,2)*B(2,6).
  movss 0x9c(multiply_stream, base_pointer), B1
  mulss 0x14c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_389

  # Reset C(5,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,6) = A(5,2)*B(2,6).
  movaps 0x0+B_OFFSET_26(B), B1
  movaps 0x10+B_OFFSET_26(B), B2
  movaps 0x20+B_OFFSET_26(B), B3
  movaps 0x30+B_OFFSET_26(B), B4
  movaps 0x0+A_OFFSET_52(A), A11
  movaps 0x10+A_OFFSET_52(A), A12
  movaps 0x20+A_OFFSET_52(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_52(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_52(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_52(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_52(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_52(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_52(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_52(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_52(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_52(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_52(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_52(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_52(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_52(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,6) to already existing.
  addps 0x0+C_OFFSET_56(C), C1
  addps 0x10+C_OFFSET_56(C), C2
  addps 0x20+C_OFFSET_56(C), C3
  addps 0x30+C_OFFSET_56(C), C4

  # Write out C(5,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_56(C)
  movaps C2, 0x10+C_OFFSET_56(C)
  movaps C3, 0x20+C_OFFSET_56(C)
  movaps C4, 0x30+C_OFFSET_56(C)

  .align 16
block_389:

  # Check norm of product A(6,1)*B(1,5).
  movss 0xb8(multiply_stream, base_pointer), B1
  mulss 0x128(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_390

  # Reset C(6,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,5) = A(6,1)*B(1,5).
  movaps 0x0+B_OFFSET_15(B), B1
  movaps 0x10+B_OFFSET_15(B), B2
  movaps 0x20+B_OFFSET_15(B), B3
  movaps 0x30+B_OFFSET_15(B), B4
  movaps 0x0+A_OFFSET_61(A), A11
  movaps 0x10+A_OFFSET_61(A), A12
  movaps 0x20+A_OFFSET_61(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_61(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_61(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_61(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_61(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_61(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_61(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_61(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_61(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_61(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_61(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_61(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_61(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_61(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,5) to already existing.
  addps 0x0+C_OFFSET_65(C), C1
  addps 0x10+C_OFFSET_65(C), C2
  addps 0x20+C_OFFSET_65(C), C3
  addps 0x30+C_OFFSET_65(C), C4

  # Write out C(6,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_65(C)
  movaps C2, 0x10+C_OFFSET_65(C)
  movaps C3, 0x20+C_OFFSET_65(C)
  movaps C4, 0x30+C_OFFSET_65(C)

  .align 16
block_390:

  # Check norm of product A(6,2)*B(2,5).
  movss 0xbc(multiply_stream, base_pointer), B1
  mulss 0x148(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_391

  # Reset C(6,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,5) = A(6,2)*B(2,5).
  movaps 0x0+B_OFFSET_25(B), B1
  movaps 0x10+B_OFFSET_25(B), B2
  movaps 0x20+B_OFFSET_25(B), B3
  movaps 0x30+B_OFFSET_25(B), B4
  movaps 0x0+A_OFFSET_62(A), A11
  movaps 0x10+A_OFFSET_62(A), A12
  movaps 0x20+A_OFFSET_62(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_62(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_62(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_62(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_62(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_62(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_62(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_62(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_62(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_62(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_62(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_62(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_62(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_62(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,5) to already existing.
  addps 0x0+C_OFFSET_65(C), C1
  addps 0x10+C_OFFSET_65(C), C2
  addps 0x20+C_OFFSET_65(C), C3
  addps 0x30+C_OFFSET_65(C), C4

  # Write out C(6,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_65(C)
  movaps C2, 0x10+C_OFFSET_65(C)
  movaps C3, 0x20+C_OFFSET_65(C)
  movaps C4, 0x30+C_OFFSET_65(C)

  .align 16
block_391:

  # Check norm of product A(6,1)*B(1,6).
  movss 0xb8(multiply_stream, base_pointer), B1
  mulss 0x12c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_392

  # Reset C(6,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,6) = A(6,1)*B(1,6).
  movaps 0x0+B_OFFSET_16(B), B1
  movaps 0x10+B_OFFSET_16(B), B2
  movaps 0x20+B_OFFSET_16(B), B3
  movaps 0x30+B_OFFSET_16(B), B4
  movaps 0x0+A_OFFSET_61(A), A11
  movaps 0x10+A_OFFSET_61(A), A12
  movaps 0x20+A_OFFSET_61(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_61(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_61(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_61(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_61(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_61(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_61(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_61(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_61(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_61(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_61(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_61(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_61(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_61(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,6) to already existing.
  addps 0x0+C_OFFSET_66(C), C1
  addps 0x10+C_OFFSET_66(C), C2
  addps 0x20+C_OFFSET_66(C), C3
  addps 0x30+C_OFFSET_66(C), C4

  # Write out C(6,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_66(C)
  movaps C2, 0x10+C_OFFSET_66(C)
  movaps C3, 0x20+C_OFFSET_66(C)
  movaps C4, 0x30+C_OFFSET_66(C)

  .align 16
block_392:

  # Check norm of product A(6,2)*B(2,6).
  movss 0xbc(multiply_stream, base_pointer), B1
  mulss 0x14c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_393

  # Reset C(6,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,6) = A(6,2)*B(2,6).
  movaps 0x0+B_OFFSET_26(B), B1
  movaps 0x10+B_OFFSET_26(B), B2
  movaps 0x20+B_OFFSET_26(B), B3
  movaps 0x30+B_OFFSET_26(B), B4
  movaps 0x0+A_OFFSET_62(A), A11
  movaps 0x10+A_OFFSET_62(A), A12
  movaps 0x20+A_OFFSET_62(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_62(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_62(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_62(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_62(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_62(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_62(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_62(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_62(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_62(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_62(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_62(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_62(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_62(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,6) to already existing.
  addps 0x0+C_OFFSET_66(C), C1
  addps 0x10+C_OFFSET_66(C), C2
  addps 0x20+C_OFFSET_66(C), C3
  addps 0x30+C_OFFSET_66(C), C4

  # Write out C(6,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_66(C)
  movaps C2, 0x10+C_OFFSET_66(C)
  movaps C3, 0x20+C_OFFSET_66(C)
  movaps C4, 0x30+C_OFFSET_66(C)

  .align 16
block_393:

  # Check norm of product A(5,3)*B(3,5).
  movss 0xa0(multiply_stream, base_pointer), B1
  mulss 0x168(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_394

  # Reset C(5,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,5) = A(5,3)*B(3,5).
  movaps 0x0+B_OFFSET_35(B), B1
  movaps 0x10+B_OFFSET_35(B), B2
  movaps 0x20+B_OFFSET_35(B), B3
  movaps 0x30+B_OFFSET_35(B), B4
  movaps 0x0+A_OFFSET_53(A), A11
  movaps 0x10+A_OFFSET_53(A), A12
  movaps 0x20+A_OFFSET_53(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_53(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_53(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_53(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_53(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_53(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_53(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_53(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_53(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_53(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_53(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_53(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_53(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_53(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,5) to already existing.
  addps 0x0+C_OFFSET_55(C), C1
  addps 0x10+C_OFFSET_55(C), C2
  addps 0x20+C_OFFSET_55(C), C3
  addps 0x30+C_OFFSET_55(C), C4

  # Write out C(5,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_55(C)
  movaps C2, 0x10+C_OFFSET_55(C)
  movaps C3, 0x20+C_OFFSET_55(C)
  movaps C4, 0x30+C_OFFSET_55(C)

  .align 16
block_394:

  # Check norm of product A(5,4)*B(4,5).
  movss 0xa4(multiply_stream, base_pointer), B1
  mulss 0x188(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_395

  # Reset C(5,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,5) = A(5,4)*B(4,5).
  movaps 0x0+B_OFFSET_45(B), B1
  movaps 0x10+B_OFFSET_45(B), B2
  movaps 0x20+B_OFFSET_45(B), B3
  movaps 0x30+B_OFFSET_45(B), B4
  movaps 0x0+A_OFFSET_54(A), A11
  movaps 0x10+A_OFFSET_54(A), A12
  movaps 0x20+A_OFFSET_54(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_54(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_54(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_54(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_54(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_54(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_54(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_54(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_54(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_54(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_54(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_54(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_54(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_54(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,5) to already existing.
  addps 0x0+C_OFFSET_55(C), C1
  addps 0x10+C_OFFSET_55(C), C2
  addps 0x20+C_OFFSET_55(C), C3
  addps 0x30+C_OFFSET_55(C), C4

  # Write out C(5,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_55(C)
  movaps C2, 0x10+C_OFFSET_55(C)
  movaps C3, 0x20+C_OFFSET_55(C)
  movaps C4, 0x30+C_OFFSET_55(C)

  .align 16
block_395:

  # Check norm of product A(5,3)*B(3,6).
  movss 0xa0(multiply_stream, base_pointer), B1
  mulss 0x16c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_396

  # Reset C(5,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,6) = A(5,3)*B(3,6).
  movaps 0x0+B_OFFSET_36(B), B1
  movaps 0x10+B_OFFSET_36(B), B2
  movaps 0x20+B_OFFSET_36(B), B3
  movaps 0x30+B_OFFSET_36(B), B4
  movaps 0x0+A_OFFSET_53(A), A11
  movaps 0x10+A_OFFSET_53(A), A12
  movaps 0x20+A_OFFSET_53(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_53(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_53(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_53(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_53(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_53(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_53(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_53(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_53(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_53(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_53(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_53(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_53(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_53(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,6) to already existing.
  addps 0x0+C_OFFSET_56(C), C1
  addps 0x10+C_OFFSET_56(C), C2
  addps 0x20+C_OFFSET_56(C), C3
  addps 0x30+C_OFFSET_56(C), C4

  # Write out C(5,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_56(C)
  movaps C2, 0x10+C_OFFSET_56(C)
  movaps C3, 0x20+C_OFFSET_56(C)
  movaps C4, 0x30+C_OFFSET_56(C)

  .align 16
block_396:

  # Check norm of product A(5,4)*B(4,6).
  movss 0xa4(multiply_stream, base_pointer), B1
  mulss 0x18c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_397

  # Reset C(5,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,6) = A(5,4)*B(4,6).
  movaps 0x0+B_OFFSET_46(B), B1
  movaps 0x10+B_OFFSET_46(B), B2
  movaps 0x20+B_OFFSET_46(B), B3
  movaps 0x30+B_OFFSET_46(B), B4
  movaps 0x0+A_OFFSET_54(A), A11
  movaps 0x10+A_OFFSET_54(A), A12
  movaps 0x20+A_OFFSET_54(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_54(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_54(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_54(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_54(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_54(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_54(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_54(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_54(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_54(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_54(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_54(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_54(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_54(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,6) to already existing.
  addps 0x0+C_OFFSET_56(C), C1
  addps 0x10+C_OFFSET_56(C), C2
  addps 0x20+C_OFFSET_56(C), C3
  addps 0x30+C_OFFSET_56(C), C4

  # Write out C(5,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_56(C)
  movaps C2, 0x10+C_OFFSET_56(C)
  movaps C3, 0x20+C_OFFSET_56(C)
  movaps C4, 0x30+C_OFFSET_56(C)

  .align 16
block_397:

  # Check norm of product A(6,3)*B(3,5).
  movss 0xc0(multiply_stream, base_pointer), B1
  mulss 0x168(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_398

  # Reset C(6,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,5) = A(6,3)*B(3,5).
  movaps 0x0+B_OFFSET_35(B), B1
  movaps 0x10+B_OFFSET_35(B), B2
  movaps 0x20+B_OFFSET_35(B), B3
  movaps 0x30+B_OFFSET_35(B), B4
  movaps 0x0+A_OFFSET_63(A), A11
  movaps 0x10+A_OFFSET_63(A), A12
  movaps 0x20+A_OFFSET_63(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_63(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_63(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_63(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_63(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_63(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_63(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_63(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_63(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_63(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_63(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_63(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_63(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_63(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,5) to already existing.
  addps 0x0+C_OFFSET_65(C), C1
  addps 0x10+C_OFFSET_65(C), C2
  addps 0x20+C_OFFSET_65(C), C3
  addps 0x30+C_OFFSET_65(C), C4

  # Write out C(6,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_65(C)
  movaps C2, 0x10+C_OFFSET_65(C)
  movaps C3, 0x20+C_OFFSET_65(C)
  movaps C4, 0x30+C_OFFSET_65(C)

  .align 16
block_398:

  # Check norm of product A(6,4)*B(4,5).
  movss 0xc4(multiply_stream, base_pointer), B1
  mulss 0x188(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_399

  # Reset C(6,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,5) = A(6,4)*B(4,5).
  movaps 0x0+B_OFFSET_45(B), B1
  movaps 0x10+B_OFFSET_45(B), B2
  movaps 0x20+B_OFFSET_45(B), B3
  movaps 0x30+B_OFFSET_45(B), B4
  movaps 0x0+A_OFFSET_64(A), A11
  movaps 0x10+A_OFFSET_64(A), A12
  movaps 0x20+A_OFFSET_64(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_64(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_64(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_64(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_64(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_64(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_64(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_64(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_64(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_64(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_64(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_64(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_64(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_64(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,5) to already existing.
  addps 0x0+C_OFFSET_65(C), C1
  addps 0x10+C_OFFSET_65(C), C2
  addps 0x20+C_OFFSET_65(C), C3
  addps 0x30+C_OFFSET_65(C), C4

  # Write out C(6,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_65(C)
  movaps C2, 0x10+C_OFFSET_65(C)
  movaps C3, 0x20+C_OFFSET_65(C)
  movaps C4, 0x30+C_OFFSET_65(C)

  .align 16
block_399:

  # Check norm of product A(6,3)*B(3,6).
  movss 0xc0(multiply_stream, base_pointer), B1
  mulss 0x16c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_400

  # Reset C(6,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,6) = A(6,3)*B(3,6).
  movaps 0x0+B_OFFSET_36(B), B1
  movaps 0x10+B_OFFSET_36(B), B2
  movaps 0x20+B_OFFSET_36(B), B3
  movaps 0x30+B_OFFSET_36(B), B4
  movaps 0x0+A_OFFSET_63(A), A11
  movaps 0x10+A_OFFSET_63(A), A12
  movaps 0x20+A_OFFSET_63(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_63(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_63(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_63(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_63(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_63(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_63(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_63(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_63(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_63(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_63(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_63(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_63(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_63(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,6) to already existing.
  addps 0x0+C_OFFSET_66(C), C1
  addps 0x10+C_OFFSET_66(C), C2
  addps 0x20+C_OFFSET_66(C), C3
  addps 0x30+C_OFFSET_66(C), C4

  # Write out C(6,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_66(C)
  movaps C2, 0x10+C_OFFSET_66(C)
  movaps C3, 0x20+C_OFFSET_66(C)
  movaps C4, 0x30+C_OFFSET_66(C)

  .align 16
block_400:

  # Check norm of product A(6,4)*B(4,6).
  movss 0xc4(multiply_stream, base_pointer), B1
  mulss 0x18c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_401

  # Reset C(6,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,6) = A(6,4)*B(4,6).
  movaps 0x0+B_OFFSET_46(B), B1
  movaps 0x10+B_OFFSET_46(B), B2
  movaps 0x20+B_OFFSET_46(B), B3
  movaps 0x30+B_OFFSET_46(B), B4
  movaps 0x0+A_OFFSET_64(A), A11
  movaps 0x10+A_OFFSET_64(A), A12
  movaps 0x20+A_OFFSET_64(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_64(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_64(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_64(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_64(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_64(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_64(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_64(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_64(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_64(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_64(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_64(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_64(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_64(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,6) to already existing.
  addps 0x0+C_OFFSET_66(C), C1
  addps 0x10+C_OFFSET_66(C), C2
  addps 0x20+C_OFFSET_66(C), C3
  addps 0x30+C_OFFSET_66(C), C4

  # Write out C(6,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_66(C)
  movaps C2, 0x10+C_OFFSET_66(C)
  movaps C3, 0x20+C_OFFSET_66(C)
  movaps C4, 0x30+C_OFFSET_66(C)

  .align 16
block_401:

  # Check norm of product A(5,1)*B(1,7).
  movss 0x98(multiply_stream, base_pointer), B1
  mulss 0x130(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_402

  # Reset C(5,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,7) = A(5,1)*B(1,7).
  movaps 0x0+B_OFFSET_17(B), B1
  movaps 0x10+B_OFFSET_17(B), B2
  movaps 0x20+B_OFFSET_17(B), B3
  movaps 0x30+B_OFFSET_17(B), B4
  movaps 0x0+A_OFFSET_51(A), A11
  movaps 0x10+A_OFFSET_51(A), A12
  movaps 0x20+A_OFFSET_51(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_51(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_51(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_51(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_51(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_51(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_51(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_51(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_51(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_51(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_51(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_51(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_51(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_51(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,7) to already existing.
  addps 0x0+C_OFFSET_57(C), C1
  addps 0x10+C_OFFSET_57(C), C2
  addps 0x20+C_OFFSET_57(C), C3
  addps 0x30+C_OFFSET_57(C), C4

  # Write out C(5,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_57(C)
  movaps C2, 0x10+C_OFFSET_57(C)
  movaps C3, 0x20+C_OFFSET_57(C)
  movaps C4, 0x30+C_OFFSET_57(C)

  .align 16
block_402:

  # Check norm of product A(5,2)*B(2,7).
  movss 0x9c(multiply_stream, base_pointer), B1
  mulss 0x150(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_403

  # Reset C(5,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,7) = A(5,2)*B(2,7).
  movaps 0x0+B_OFFSET_27(B), B1
  movaps 0x10+B_OFFSET_27(B), B2
  movaps 0x20+B_OFFSET_27(B), B3
  movaps 0x30+B_OFFSET_27(B), B4
  movaps 0x0+A_OFFSET_52(A), A11
  movaps 0x10+A_OFFSET_52(A), A12
  movaps 0x20+A_OFFSET_52(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_52(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_52(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_52(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_52(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_52(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_52(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_52(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_52(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_52(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_52(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_52(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_52(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_52(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,7) to already existing.
  addps 0x0+C_OFFSET_57(C), C1
  addps 0x10+C_OFFSET_57(C), C2
  addps 0x20+C_OFFSET_57(C), C3
  addps 0x30+C_OFFSET_57(C), C4

  # Write out C(5,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_57(C)
  movaps C2, 0x10+C_OFFSET_57(C)
  movaps C3, 0x20+C_OFFSET_57(C)
  movaps C4, 0x30+C_OFFSET_57(C)

  .align 16
block_403:

  # Check norm of product A(5,1)*B(1,8).
  movss 0x98(multiply_stream, base_pointer), B1
  mulss 0x134(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_404

  # Reset C(5,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,8) = A(5,1)*B(1,8).
  movaps 0x0+B_OFFSET_18(B), B1
  movaps 0x10+B_OFFSET_18(B), B2
  movaps 0x20+B_OFFSET_18(B), B3
  movaps 0x30+B_OFFSET_18(B), B4
  movaps 0x0+A_OFFSET_51(A), A11
  movaps 0x10+A_OFFSET_51(A), A12
  movaps 0x20+A_OFFSET_51(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_51(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_51(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_51(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_51(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_51(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_51(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_51(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_51(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_51(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_51(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_51(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_51(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_51(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,8) to already existing.
  addps 0x0+C_OFFSET_58(C), C1
  addps 0x10+C_OFFSET_58(C), C2
  addps 0x20+C_OFFSET_58(C), C3
  addps 0x30+C_OFFSET_58(C), C4

  # Write out C(5,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_58(C)
  movaps C2, 0x10+C_OFFSET_58(C)
  movaps C3, 0x20+C_OFFSET_58(C)
  movaps C4, 0x30+C_OFFSET_58(C)

  .align 16
block_404:

  # Check norm of product A(5,2)*B(2,8).
  movss 0x9c(multiply_stream, base_pointer), B1
  mulss 0x154(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_405

  # Reset C(5,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,8) = A(5,2)*B(2,8).
  movaps 0x0+B_OFFSET_28(B), B1
  movaps 0x10+B_OFFSET_28(B), B2
  movaps 0x20+B_OFFSET_28(B), B3
  movaps 0x30+B_OFFSET_28(B), B4
  movaps 0x0+A_OFFSET_52(A), A11
  movaps 0x10+A_OFFSET_52(A), A12
  movaps 0x20+A_OFFSET_52(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_52(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_52(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_52(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_52(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_52(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_52(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_52(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_52(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_52(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_52(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_52(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_52(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_52(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,8) to already existing.
  addps 0x0+C_OFFSET_58(C), C1
  addps 0x10+C_OFFSET_58(C), C2
  addps 0x20+C_OFFSET_58(C), C3
  addps 0x30+C_OFFSET_58(C), C4

  # Write out C(5,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_58(C)
  movaps C2, 0x10+C_OFFSET_58(C)
  movaps C3, 0x20+C_OFFSET_58(C)
  movaps C4, 0x30+C_OFFSET_58(C)

  .align 16
block_405:

  # Check norm of product A(6,1)*B(1,7).
  movss 0xb8(multiply_stream, base_pointer), B1
  mulss 0x130(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_406

  # Reset C(6,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,7) = A(6,1)*B(1,7).
  movaps 0x0+B_OFFSET_17(B), B1
  movaps 0x10+B_OFFSET_17(B), B2
  movaps 0x20+B_OFFSET_17(B), B3
  movaps 0x30+B_OFFSET_17(B), B4
  movaps 0x0+A_OFFSET_61(A), A11
  movaps 0x10+A_OFFSET_61(A), A12
  movaps 0x20+A_OFFSET_61(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_61(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_61(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_61(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_61(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_61(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_61(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_61(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_61(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_61(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_61(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_61(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_61(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_61(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,7) to already existing.
  addps 0x0+C_OFFSET_67(C), C1
  addps 0x10+C_OFFSET_67(C), C2
  addps 0x20+C_OFFSET_67(C), C3
  addps 0x30+C_OFFSET_67(C), C4

  # Write out C(6,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_67(C)
  movaps C2, 0x10+C_OFFSET_67(C)
  movaps C3, 0x20+C_OFFSET_67(C)
  movaps C4, 0x30+C_OFFSET_67(C)

  .align 16
block_406:

  # Check norm of product A(6,2)*B(2,7).
  movss 0xbc(multiply_stream, base_pointer), B1
  mulss 0x150(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_407

  # Reset C(6,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,7) = A(6,2)*B(2,7).
  movaps 0x0+B_OFFSET_27(B), B1
  movaps 0x10+B_OFFSET_27(B), B2
  movaps 0x20+B_OFFSET_27(B), B3
  movaps 0x30+B_OFFSET_27(B), B4
  movaps 0x0+A_OFFSET_62(A), A11
  movaps 0x10+A_OFFSET_62(A), A12
  movaps 0x20+A_OFFSET_62(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_62(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_62(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_62(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_62(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_62(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_62(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_62(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_62(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_62(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_62(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_62(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_62(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_62(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,7) to already existing.
  addps 0x0+C_OFFSET_67(C), C1
  addps 0x10+C_OFFSET_67(C), C2
  addps 0x20+C_OFFSET_67(C), C3
  addps 0x30+C_OFFSET_67(C), C4

  # Write out C(6,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_67(C)
  movaps C2, 0x10+C_OFFSET_67(C)
  movaps C3, 0x20+C_OFFSET_67(C)
  movaps C4, 0x30+C_OFFSET_67(C)

  .align 16
block_407:

  # Check norm of product A(6,1)*B(1,8).
  movss 0xb8(multiply_stream, base_pointer), B1
  mulss 0x134(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_408

  # Reset C(6,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,8) = A(6,1)*B(1,8).
  movaps 0x0+B_OFFSET_18(B), B1
  movaps 0x10+B_OFFSET_18(B), B2
  movaps 0x20+B_OFFSET_18(B), B3
  movaps 0x30+B_OFFSET_18(B), B4
  movaps 0x0+A_OFFSET_61(A), A11
  movaps 0x10+A_OFFSET_61(A), A12
  movaps 0x20+A_OFFSET_61(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_61(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_61(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_61(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_61(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_61(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_61(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_61(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_61(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_61(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_61(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_61(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_61(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_61(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,8) to already existing.
  addps 0x0+C_OFFSET_68(C), C1
  addps 0x10+C_OFFSET_68(C), C2
  addps 0x20+C_OFFSET_68(C), C3
  addps 0x30+C_OFFSET_68(C), C4

  # Write out C(6,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_68(C)
  movaps C2, 0x10+C_OFFSET_68(C)
  movaps C3, 0x20+C_OFFSET_68(C)
  movaps C4, 0x30+C_OFFSET_68(C)

  .align 16
block_408:

  # Check norm of product A(6,2)*B(2,8).
  movss 0xbc(multiply_stream, base_pointer), B1
  mulss 0x154(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_409

  # Reset C(6,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,8) = A(6,2)*B(2,8).
  movaps 0x0+B_OFFSET_28(B), B1
  movaps 0x10+B_OFFSET_28(B), B2
  movaps 0x20+B_OFFSET_28(B), B3
  movaps 0x30+B_OFFSET_28(B), B4
  movaps 0x0+A_OFFSET_62(A), A11
  movaps 0x10+A_OFFSET_62(A), A12
  movaps 0x20+A_OFFSET_62(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_62(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_62(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_62(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_62(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_62(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_62(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_62(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_62(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_62(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_62(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_62(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_62(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_62(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,8) to already existing.
  addps 0x0+C_OFFSET_68(C), C1
  addps 0x10+C_OFFSET_68(C), C2
  addps 0x20+C_OFFSET_68(C), C3
  addps 0x30+C_OFFSET_68(C), C4

  # Write out C(6,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_68(C)
  movaps C2, 0x10+C_OFFSET_68(C)
  movaps C3, 0x20+C_OFFSET_68(C)
  movaps C4, 0x30+C_OFFSET_68(C)

  .align 16
block_409:

  # Check norm of product A(5,3)*B(3,7).
  movss 0xa0(multiply_stream, base_pointer), B1
  mulss 0x170(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_410

  # Reset C(5,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,7) = A(5,3)*B(3,7).
  movaps 0x0+B_OFFSET_37(B), B1
  movaps 0x10+B_OFFSET_37(B), B2
  movaps 0x20+B_OFFSET_37(B), B3
  movaps 0x30+B_OFFSET_37(B), B4
  movaps 0x0+A_OFFSET_53(A), A11
  movaps 0x10+A_OFFSET_53(A), A12
  movaps 0x20+A_OFFSET_53(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_53(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_53(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_53(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_53(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_53(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_53(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_53(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_53(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_53(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_53(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_53(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_53(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_53(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,7) to already existing.
  addps 0x0+C_OFFSET_57(C), C1
  addps 0x10+C_OFFSET_57(C), C2
  addps 0x20+C_OFFSET_57(C), C3
  addps 0x30+C_OFFSET_57(C), C4

  # Write out C(5,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_57(C)
  movaps C2, 0x10+C_OFFSET_57(C)
  movaps C3, 0x20+C_OFFSET_57(C)
  movaps C4, 0x30+C_OFFSET_57(C)

  .align 16
block_410:

  # Check norm of product A(5,4)*B(4,7).
  movss 0xa4(multiply_stream, base_pointer), B1
  mulss 0x190(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_411

  # Reset C(5,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,7) = A(5,4)*B(4,7).
  movaps 0x0+B_OFFSET_47(B), B1
  movaps 0x10+B_OFFSET_47(B), B2
  movaps 0x20+B_OFFSET_47(B), B3
  movaps 0x30+B_OFFSET_47(B), B4
  movaps 0x0+A_OFFSET_54(A), A11
  movaps 0x10+A_OFFSET_54(A), A12
  movaps 0x20+A_OFFSET_54(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_54(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_54(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_54(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_54(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_54(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_54(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_54(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_54(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_54(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_54(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_54(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_54(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_54(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,7) to already existing.
  addps 0x0+C_OFFSET_57(C), C1
  addps 0x10+C_OFFSET_57(C), C2
  addps 0x20+C_OFFSET_57(C), C3
  addps 0x30+C_OFFSET_57(C), C4

  # Write out C(5,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_57(C)
  movaps C2, 0x10+C_OFFSET_57(C)
  movaps C3, 0x20+C_OFFSET_57(C)
  movaps C4, 0x30+C_OFFSET_57(C)

  .align 16
block_411:

  # Check norm of product A(5,3)*B(3,8).
  movss 0xa0(multiply_stream, base_pointer), B1
  mulss 0x174(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_412

  # Reset C(5,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,8) = A(5,3)*B(3,8).
  movaps 0x0+B_OFFSET_38(B), B1
  movaps 0x10+B_OFFSET_38(B), B2
  movaps 0x20+B_OFFSET_38(B), B3
  movaps 0x30+B_OFFSET_38(B), B4
  movaps 0x0+A_OFFSET_53(A), A11
  movaps 0x10+A_OFFSET_53(A), A12
  movaps 0x20+A_OFFSET_53(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_53(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_53(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_53(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_53(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_53(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_53(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_53(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_53(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_53(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_53(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_53(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_53(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_53(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,8) to already existing.
  addps 0x0+C_OFFSET_58(C), C1
  addps 0x10+C_OFFSET_58(C), C2
  addps 0x20+C_OFFSET_58(C), C3
  addps 0x30+C_OFFSET_58(C), C4

  # Write out C(5,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_58(C)
  movaps C2, 0x10+C_OFFSET_58(C)
  movaps C3, 0x20+C_OFFSET_58(C)
  movaps C4, 0x30+C_OFFSET_58(C)

  .align 16
block_412:

  # Check norm of product A(5,4)*B(4,8).
  movss 0xa4(multiply_stream, base_pointer), B1
  mulss 0x194(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_413

  # Reset C(5,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,8) = A(5,4)*B(4,8).
  movaps 0x0+B_OFFSET_48(B), B1
  movaps 0x10+B_OFFSET_48(B), B2
  movaps 0x20+B_OFFSET_48(B), B3
  movaps 0x30+B_OFFSET_48(B), B4
  movaps 0x0+A_OFFSET_54(A), A11
  movaps 0x10+A_OFFSET_54(A), A12
  movaps 0x20+A_OFFSET_54(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_54(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_54(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_54(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_54(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_54(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_54(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_54(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_54(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_54(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_54(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_54(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_54(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_54(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,8) to already existing.
  addps 0x0+C_OFFSET_58(C), C1
  addps 0x10+C_OFFSET_58(C), C2
  addps 0x20+C_OFFSET_58(C), C3
  addps 0x30+C_OFFSET_58(C), C4

  # Write out C(5,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_58(C)
  movaps C2, 0x10+C_OFFSET_58(C)
  movaps C3, 0x20+C_OFFSET_58(C)
  movaps C4, 0x30+C_OFFSET_58(C)

  .align 16
block_413:

  # Check norm of product A(6,3)*B(3,7).
  movss 0xc0(multiply_stream, base_pointer), B1
  mulss 0x170(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_414

  # Reset C(6,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,7) = A(6,3)*B(3,7).
  movaps 0x0+B_OFFSET_37(B), B1
  movaps 0x10+B_OFFSET_37(B), B2
  movaps 0x20+B_OFFSET_37(B), B3
  movaps 0x30+B_OFFSET_37(B), B4
  movaps 0x0+A_OFFSET_63(A), A11
  movaps 0x10+A_OFFSET_63(A), A12
  movaps 0x20+A_OFFSET_63(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_63(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_63(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_63(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_63(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_63(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_63(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_63(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_63(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_63(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_63(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_63(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_63(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_63(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,7) to already existing.
  addps 0x0+C_OFFSET_67(C), C1
  addps 0x10+C_OFFSET_67(C), C2
  addps 0x20+C_OFFSET_67(C), C3
  addps 0x30+C_OFFSET_67(C), C4

  # Write out C(6,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_67(C)
  movaps C2, 0x10+C_OFFSET_67(C)
  movaps C3, 0x20+C_OFFSET_67(C)
  movaps C4, 0x30+C_OFFSET_67(C)

  .align 16
block_414:

  # Check norm of product A(6,4)*B(4,7).
  movss 0xc4(multiply_stream, base_pointer), B1
  mulss 0x190(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_415

  # Reset C(6,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,7) = A(6,4)*B(4,7).
  movaps 0x0+B_OFFSET_47(B), B1
  movaps 0x10+B_OFFSET_47(B), B2
  movaps 0x20+B_OFFSET_47(B), B3
  movaps 0x30+B_OFFSET_47(B), B4
  movaps 0x0+A_OFFSET_64(A), A11
  movaps 0x10+A_OFFSET_64(A), A12
  movaps 0x20+A_OFFSET_64(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_64(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_64(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_64(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_64(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_64(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_64(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_64(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_64(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_64(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_64(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_64(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_64(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_64(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,7) to already existing.
  addps 0x0+C_OFFSET_67(C), C1
  addps 0x10+C_OFFSET_67(C), C2
  addps 0x20+C_OFFSET_67(C), C3
  addps 0x30+C_OFFSET_67(C), C4

  # Write out C(6,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_67(C)
  movaps C2, 0x10+C_OFFSET_67(C)
  movaps C3, 0x20+C_OFFSET_67(C)
  movaps C4, 0x30+C_OFFSET_67(C)

  .align 16
block_415:

  # Check norm of product A(6,3)*B(3,8).
  movss 0xc0(multiply_stream, base_pointer), B1
  mulss 0x174(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_416

  # Reset C(6,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,8) = A(6,3)*B(3,8).
  movaps 0x0+B_OFFSET_38(B), B1
  movaps 0x10+B_OFFSET_38(B), B2
  movaps 0x20+B_OFFSET_38(B), B3
  movaps 0x30+B_OFFSET_38(B), B4
  movaps 0x0+A_OFFSET_63(A), A11
  movaps 0x10+A_OFFSET_63(A), A12
  movaps 0x20+A_OFFSET_63(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_63(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_63(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_63(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_63(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_63(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_63(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_63(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_63(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_63(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_63(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_63(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_63(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_63(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,8) to already existing.
  addps 0x0+C_OFFSET_68(C), C1
  addps 0x10+C_OFFSET_68(C), C2
  addps 0x20+C_OFFSET_68(C), C3
  addps 0x30+C_OFFSET_68(C), C4

  # Write out C(6,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_68(C)
  movaps C2, 0x10+C_OFFSET_68(C)
  movaps C3, 0x20+C_OFFSET_68(C)
  movaps C4, 0x30+C_OFFSET_68(C)

  .align 16
block_416:

  # Check norm of product A(6,4)*B(4,8).
  movss 0xc4(multiply_stream, base_pointer), B1
  mulss 0x194(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_417

  # Reset C(6,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,8) = A(6,4)*B(4,8).
  movaps 0x0+B_OFFSET_48(B), B1
  movaps 0x10+B_OFFSET_48(B), B2
  movaps 0x20+B_OFFSET_48(B), B3
  movaps 0x30+B_OFFSET_48(B), B4
  movaps 0x0+A_OFFSET_64(A), A11
  movaps 0x10+A_OFFSET_64(A), A12
  movaps 0x20+A_OFFSET_64(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_64(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_64(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_64(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_64(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_64(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_64(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_64(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_64(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_64(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_64(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_64(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_64(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_64(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,8) to already existing.
  addps 0x0+C_OFFSET_68(C), C1
  addps 0x10+C_OFFSET_68(C), C2
  addps 0x20+C_OFFSET_68(C), C3
  addps 0x30+C_OFFSET_68(C), C4

  # Write out C(6,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_68(C)
  movaps C2, 0x10+C_OFFSET_68(C)
  movaps C3, 0x20+C_OFFSET_68(C)
  movaps C4, 0x30+C_OFFSET_68(C)

  .align 16
block_417:

  # Check norm of product A(7,1)*B(1,5).
  movss 0xd8(multiply_stream, base_pointer), B1
  mulss 0x128(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_418

  # Reset C(7,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,5) = A(7,1)*B(1,5).
  movaps 0x0+B_OFFSET_15(B), B1
  movaps 0x10+B_OFFSET_15(B), B2
  movaps 0x20+B_OFFSET_15(B), B3
  movaps 0x30+B_OFFSET_15(B), B4
  movaps 0x0+A_OFFSET_71(A), A11
  movaps 0x10+A_OFFSET_71(A), A12
  movaps 0x20+A_OFFSET_71(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_71(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_71(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_71(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_71(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_71(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_71(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_71(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_71(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_71(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_71(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_71(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_71(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_71(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,5) to already existing.
  addps 0x0+C_OFFSET_75(C), C1
  addps 0x10+C_OFFSET_75(C), C2
  addps 0x20+C_OFFSET_75(C), C3
  addps 0x30+C_OFFSET_75(C), C4

  # Write out C(7,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_75(C)
  movaps C2, 0x10+C_OFFSET_75(C)
  movaps C3, 0x20+C_OFFSET_75(C)
  movaps C4, 0x30+C_OFFSET_75(C)

  .align 16
block_418:

  # Check norm of product A(7,2)*B(2,5).
  movss 0xdc(multiply_stream, base_pointer), B1
  mulss 0x148(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_419

  # Reset C(7,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,5) = A(7,2)*B(2,5).
  movaps 0x0+B_OFFSET_25(B), B1
  movaps 0x10+B_OFFSET_25(B), B2
  movaps 0x20+B_OFFSET_25(B), B3
  movaps 0x30+B_OFFSET_25(B), B4
  movaps 0x0+A_OFFSET_72(A), A11
  movaps 0x10+A_OFFSET_72(A), A12
  movaps 0x20+A_OFFSET_72(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_72(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_72(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_72(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_72(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_72(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_72(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_72(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_72(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_72(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_72(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_72(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_72(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_72(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,5) to already existing.
  addps 0x0+C_OFFSET_75(C), C1
  addps 0x10+C_OFFSET_75(C), C2
  addps 0x20+C_OFFSET_75(C), C3
  addps 0x30+C_OFFSET_75(C), C4

  # Write out C(7,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_75(C)
  movaps C2, 0x10+C_OFFSET_75(C)
  movaps C3, 0x20+C_OFFSET_75(C)
  movaps C4, 0x30+C_OFFSET_75(C)

  .align 16
block_419:

  # Check norm of product A(7,1)*B(1,6).
  movss 0xd8(multiply_stream, base_pointer), B1
  mulss 0x12c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_420

  # Reset C(7,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,6) = A(7,1)*B(1,6).
  movaps 0x0+B_OFFSET_16(B), B1
  movaps 0x10+B_OFFSET_16(B), B2
  movaps 0x20+B_OFFSET_16(B), B3
  movaps 0x30+B_OFFSET_16(B), B4
  movaps 0x0+A_OFFSET_71(A), A11
  movaps 0x10+A_OFFSET_71(A), A12
  movaps 0x20+A_OFFSET_71(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_71(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_71(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_71(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_71(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_71(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_71(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_71(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_71(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_71(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_71(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_71(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_71(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_71(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,6) to already existing.
  addps 0x0+C_OFFSET_76(C), C1
  addps 0x10+C_OFFSET_76(C), C2
  addps 0x20+C_OFFSET_76(C), C3
  addps 0x30+C_OFFSET_76(C), C4

  # Write out C(7,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_76(C)
  movaps C2, 0x10+C_OFFSET_76(C)
  movaps C3, 0x20+C_OFFSET_76(C)
  movaps C4, 0x30+C_OFFSET_76(C)

  .align 16
block_420:

  # Check norm of product A(7,2)*B(2,6).
  movss 0xdc(multiply_stream, base_pointer), B1
  mulss 0x14c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_421

  # Reset C(7,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,6) = A(7,2)*B(2,6).
  movaps 0x0+B_OFFSET_26(B), B1
  movaps 0x10+B_OFFSET_26(B), B2
  movaps 0x20+B_OFFSET_26(B), B3
  movaps 0x30+B_OFFSET_26(B), B4
  movaps 0x0+A_OFFSET_72(A), A11
  movaps 0x10+A_OFFSET_72(A), A12
  movaps 0x20+A_OFFSET_72(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_72(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_72(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_72(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_72(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_72(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_72(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_72(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_72(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_72(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_72(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_72(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_72(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_72(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,6) to already existing.
  addps 0x0+C_OFFSET_76(C), C1
  addps 0x10+C_OFFSET_76(C), C2
  addps 0x20+C_OFFSET_76(C), C3
  addps 0x30+C_OFFSET_76(C), C4

  # Write out C(7,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_76(C)
  movaps C2, 0x10+C_OFFSET_76(C)
  movaps C3, 0x20+C_OFFSET_76(C)
  movaps C4, 0x30+C_OFFSET_76(C)

  .align 16
block_421:

  # Check norm of product A(8,1)*B(1,5).
  movss 0xf8(multiply_stream, base_pointer), B1
  mulss 0x128(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_422

  # Reset C(8,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,5) = A(8,1)*B(1,5).
  movaps 0x0+B_OFFSET_15(B), B1
  movaps 0x10+B_OFFSET_15(B), B2
  movaps 0x20+B_OFFSET_15(B), B3
  movaps 0x30+B_OFFSET_15(B), B4
  movaps 0x0+A_OFFSET_81(A), A11
  movaps 0x10+A_OFFSET_81(A), A12
  movaps 0x20+A_OFFSET_81(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_81(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_81(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_81(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_81(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_81(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_81(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_81(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_81(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_81(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_81(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_81(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_81(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_81(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,5) to already existing.
  addps 0x0+C_OFFSET_85(C), C1
  addps 0x10+C_OFFSET_85(C), C2
  addps 0x20+C_OFFSET_85(C), C3
  addps 0x30+C_OFFSET_85(C), C4

  # Write out C(8,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_85(C)
  movaps C2, 0x10+C_OFFSET_85(C)
  movaps C3, 0x20+C_OFFSET_85(C)
  movaps C4, 0x30+C_OFFSET_85(C)

  .align 16
block_422:

  # Check norm of product A(8,2)*B(2,5).
  movss 0xfc(multiply_stream, base_pointer), B1
  mulss 0x148(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_423

  # Reset C(8,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,5) = A(8,2)*B(2,5).
  movaps 0x0+B_OFFSET_25(B), B1
  movaps 0x10+B_OFFSET_25(B), B2
  movaps 0x20+B_OFFSET_25(B), B3
  movaps 0x30+B_OFFSET_25(B), B4
  movaps 0x0+A_OFFSET_82(A), A11
  movaps 0x10+A_OFFSET_82(A), A12
  movaps 0x20+A_OFFSET_82(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_82(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_82(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_82(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_82(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_82(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_82(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_82(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_82(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_82(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_82(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_82(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_82(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_82(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,5) to already existing.
  addps 0x0+C_OFFSET_85(C), C1
  addps 0x10+C_OFFSET_85(C), C2
  addps 0x20+C_OFFSET_85(C), C3
  addps 0x30+C_OFFSET_85(C), C4

  # Write out C(8,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_85(C)
  movaps C2, 0x10+C_OFFSET_85(C)
  movaps C3, 0x20+C_OFFSET_85(C)
  movaps C4, 0x30+C_OFFSET_85(C)

  .align 16
block_423:

  # Check norm of product A(8,1)*B(1,6).
  movss 0xf8(multiply_stream, base_pointer), B1
  mulss 0x12c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_424

  # Reset C(8,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,6) = A(8,1)*B(1,6).
  movaps 0x0+B_OFFSET_16(B), B1
  movaps 0x10+B_OFFSET_16(B), B2
  movaps 0x20+B_OFFSET_16(B), B3
  movaps 0x30+B_OFFSET_16(B), B4
  movaps 0x0+A_OFFSET_81(A), A11
  movaps 0x10+A_OFFSET_81(A), A12
  movaps 0x20+A_OFFSET_81(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_81(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_81(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_81(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_81(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_81(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_81(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_81(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_81(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_81(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_81(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_81(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_81(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_81(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,6) to already existing.
  addps 0x0+C_OFFSET_86(C), C1
  addps 0x10+C_OFFSET_86(C), C2
  addps 0x20+C_OFFSET_86(C), C3
  addps 0x30+C_OFFSET_86(C), C4

  # Write out C(8,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_86(C)
  movaps C2, 0x10+C_OFFSET_86(C)
  movaps C3, 0x20+C_OFFSET_86(C)
  movaps C4, 0x30+C_OFFSET_86(C)

  .align 16
block_424:

  # Check norm of product A(8,2)*B(2,6).
  movss 0xfc(multiply_stream, base_pointer), B1
  mulss 0x14c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_425

  # Reset C(8,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,6) = A(8,2)*B(2,6).
  movaps 0x0+B_OFFSET_26(B), B1
  movaps 0x10+B_OFFSET_26(B), B2
  movaps 0x20+B_OFFSET_26(B), B3
  movaps 0x30+B_OFFSET_26(B), B4
  movaps 0x0+A_OFFSET_82(A), A11
  movaps 0x10+A_OFFSET_82(A), A12
  movaps 0x20+A_OFFSET_82(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_82(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_82(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_82(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_82(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_82(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_82(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_82(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_82(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_82(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_82(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_82(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_82(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_82(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,6) to already existing.
  addps 0x0+C_OFFSET_86(C), C1
  addps 0x10+C_OFFSET_86(C), C2
  addps 0x20+C_OFFSET_86(C), C3
  addps 0x30+C_OFFSET_86(C), C4

  # Write out C(8,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_86(C)
  movaps C2, 0x10+C_OFFSET_86(C)
  movaps C3, 0x20+C_OFFSET_86(C)
  movaps C4, 0x30+C_OFFSET_86(C)

  .align 16
block_425:

  # Check norm of product A(7,3)*B(3,5).
  movss 0xe0(multiply_stream, base_pointer), B1
  mulss 0x168(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_426

  # Reset C(7,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,5) = A(7,3)*B(3,5).
  movaps 0x0+B_OFFSET_35(B), B1
  movaps 0x10+B_OFFSET_35(B), B2
  movaps 0x20+B_OFFSET_35(B), B3
  movaps 0x30+B_OFFSET_35(B), B4
  movaps 0x0+A_OFFSET_73(A), A11
  movaps 0x10+A_OFFSET_73(A), A12
  movaps 0x20+A_OFFSET_73(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_73(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_73(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_73(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_73(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_73(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_73(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_73(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_73(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_73(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_73(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_73(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_73(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_73(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,5) to already existing.
  addps 0x0+C_OFFSET_75(C), C1
  addps 0x10+C_OFFSET_75(C), C2
  addps 0x20+C_OFFSET_75(C), C3
  addps 0x30+C_OFFSET_75(C), C4

  # Write out C(7,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_75(C)
  movaps C2, 0x10+C_OFFSET_75(C)
  movaps C3, 0x20+C_OFFSET_75(C)
  movaps C4, 0x30+C_OFFSET_75(C)

  .align 16
block_426:

  # Check norm of product A(7,4)*B(4,5).
  movss 0xe4(multiply_stream, base_pointer), B1
  mulss 0x188(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_427

  # Reset C(7,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,5) = A(7,4)*B(4,5).
  movaps 0x0+B_OFFSET_45(B), B1
  movaps 0x10+B_OFFSET_45(B), B2
  movaps 0x20+B_OFFSET_45(B), B3
  movaps 0x30+B_OFFSET_45(B), B4
  movaps 0x0+A_OFFSET_74(A), A11
  movaps 0x10+A_OFFSET_74(A), A12
  movaps 0x20+A_OFFSET_74(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_74(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_74(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_74(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_74(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_74(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_74(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_74(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_74(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_74(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_74(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_74(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_74(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_74(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,5) to already existing.
  addps 0x0+C_OFFSET_75(C), C1
  addps 0x10+C_OFFSET_75(C), C2
  addps 0x20+C_OFFSET_75(C), C3
  addps 0x30+C_OFFSET_75(C), C4

  # Write out C(7,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_75(C)
  movaps C2, 0x10+C_OFFSET_75(C)
  movaps C3, 0x20+C_OFFSET_75(C)
  movaps C4, 0x30+C_OFFSET_75(C)

  .align 16
block_427:

  # Check norm of product A(7,3)*B(3,6).
  movss 0xe0(multiply_stream, base_pointer), B1
  mulss 0x16c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_428

  # Reset C(7,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,6) = A(7,3)*B(3,6).
  movaps 0x0+B_OFFSET_36(B), B1
  movaps 0x10+B_OFFSET_36(B), B2
  movaps 0x20+B_OFFSET_36(B), B3
  movaps 0x30+B_OFFSET_36(B), B4
  movaps 0x0+A_OFFSET_73(A), A11
  movaps 0x10+A_OFFSET_73(A), A12
  movaps 0x20+A_OFFSET_73(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_73(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_73(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_73(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_73(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_73(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_73(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_73(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_73(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_73(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_73(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_73(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_73(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_73(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,6) to already existing.
  addps 0x0+C_OFFSET_76(C), C1
  addps 0x10+C_OFFSET_76(C), C2
  addps 0x20+C_OFFSET_76(C), C3
  addps 0x30+C_OFFSET_76(C), C4

  # Write out C(7,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_76(C)
  movaps C2, 0x10+C_OFFSET_76(C)
  movaps C3, 0x20+C_OFFSET_76(C)
  movaps C4, 0x30+C_OFFSET_76(C)

  .align 16
block_428:

  # Check norm of product A(7,4)*B(4,6).
  movss 0xe4(multiply_stream, base_pointer), B1
  mulss 0x18c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_429

  # Reset C(7,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,6) = A(7,4)*B(4,6).
  movaps 0x0+B_OFFSET_46(B), B1
  movaps 0x10+B_OFFSET_46(B), B2
  movaps 0x20+B_OFFSET_46(B), B3
  movaps 0x30+B_OFFSET_46(B), B4
  movaps 0x0+A_OFFSET_74(A), A11
  movaps 0x10+A_OFFSET_74(A), A12
  movaps 0x20+A_OFFSET_74(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_74(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_74(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_74(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_74(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_74(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_74(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_74(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_74(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_74(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_74(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_74(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_74(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_74(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,6) to already existing.
  addps 0x0+C_OFFSET_76(C), C1
  addps 0x10+C_OFFSET_76(C), C2
  addps 0x20+C_OFFSET_76(C), C3
  addps 0x30+C_OFFSET_76(C), C4

  # Write out C(7,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_76(C)
  movaps C2, 0x10+C_OFFSET_76(C)
  movaps C3, 0x20+C_OFFSET_76(C)
  movaps C4, 0x30+C_OFFSET_76(C)

  .align 16
block_429:

  # Check norm of product A(8,3)*B(3,5).
  movss 0x100(multiply_stream, base_pointer), B1
  mulss 0x168(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_430

  # Reset C(8,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,5) = A(8,3)*B(3,5).
  movaps 0x0+B_OFFSET_35(B), B1
  movaps 0x10+B_OFFSET_35(B), B2
  movaps 0x20+B_OFFSET_35(B), B3
  movaps 0x30+B_OFFSET_35(B), B4
  movaps 0x0+A_OFFSET_83(A), A11
  movaps 0x10+A_OFFSET_83(A), A12
  movaps 0x20+A_OFFSET_83(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_83(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_83(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_83(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_83(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_83(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_83(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_83(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_83(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_83(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_83(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_83(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_83(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_83(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,5) to already existing.
  addps 0x0+C_OFFSET_85(C), C1
  addps 0x10+C_OFFSET_85(C), C2
  addps 0x20+C_OFFSET_85(C), C3
  addps 0x30+C_OFFSET_85(C), C4

  # Write out C(8,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_85(C)
  movaps C2, 0x10+C_OFFSET_85(C)
  movaps C3, 0x20+C_OFFSET_85(C)
  movaps C4, 0x30+C_OFFSET_85(C)

  .align 16
block_430:

  # Check norm of product A(8,4)*B(4,5).
  movss 0x104(multiply_stream, base_pointer), B1
  mulss 0x188(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_431

  # Reset C(8,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,5) = A(8,4)*B(4,5).
  movaps 0x0+B_OFFSET_45(B), B1
  movaps 0x10+B_OFFSET_45(B), B2
  movaps 0x20+B_OFFSET_45(B), B3
  movaps 0x30+B_OFFSET_45(B), B4
  movaps 0x0+A_OFFSET_84(A), A11
  movaps 0x10+A_OFFSET_84(A), A12
  movaps 0x20+A_OFFSET_84(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_84(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_84(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_84(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_84(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_84(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_84(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_84(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_84(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_84(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_84(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_84(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_84(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_84(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,5) to already existing.
  addps 0x0+C_OFFSET_85(C), C1
  addps 0x10+C_OFFSET_85(C), C2
  addps 0x20+C_OFFSET_85(C), C3
  addps 0x30+C_OFFSET_85(C), C4

  # Write out C(8,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_85(C)
  movaps C2, 0x10+C_OFFSET_85(C)
  movaps C3, 0x20+C_OFFSET_85(C)
  movaps C4, 0x30+C_OFFSET_85(C)

  .align 16
block_431:

  # Check norm of product A(8,3)*B(3,6).
  movss 0x100(multiply_stream, base_pointer), B1
  mulss 0x16c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_432

  # Reset C(8,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,6) = A(8,3)*B(3,6).
  movaps 0x0+B_OFFSET_36(B), B1
  movaps 0x10+B_OFFSET_36(B), B2
  movaps 0x20+B_OFFSET_36(B), B3
  movaps 0x30+B_OFFSET_36(B), B4
  movaps 0x0+A_OFFSET_83(A), A11
  movaps 0x10+A_OFFSET_83(A), A12
  movaps 0x20+A_OFFSET_83(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_83(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_83(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_83(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_83(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_83(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_83(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_83(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_83(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_83(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_83(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_83(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_83(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_83(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,6) to already existing.
  addps 0x0+C_OFFSET_86(C), C1
  addps 0x10+C_OFFSET_86(C), C2
  addps 0x20+C_OFFSET_86(C), C3
  addps 0x30+C_OFFSET_86(C), C4

  # Write out C(8,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_86(C)
  movaps C2, 0x10+C_OFFSET_86(C)
  movaps C3, 0x20+C_OFFSET_86(C)
  movaps C4, 0x30+C_OFFSET_86(C)

  .align 16
block_432:

  # Check norm of product A(8,4)*B(4,6).
  movss 0x104(multiply_stream, base_pointer), B1
  mulss 0x18c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_433

  # Reset C(8,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,6) = A(8,4)*B(4,6).
  movaps 0x0+B_OFFSET_46(B), B1
  movaps 0x10+B_OFFSET_46(B), B2
  movaps 0x20+B_OFFSET_46(B), B3
  movaps 0x30+B_OFFSET_46(B), B4
  movaps 0x0+A_OFFSET_84(A), A11
  movaps 0x10+A_OFFSET_84(A), A12
  movaps 0x20+A_OFFSET_84(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_84(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_84(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_84(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_84(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_84(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_84(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_84(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_84(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_84(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_84(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_84(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_84(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_84(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,6) to already existing.
  addps 0x0+C_OFFSET_86(C), C1
  addps 0x10+C_OFFSET_86(C), C2
  addps 0x20+C_OFFSET_86(C), C3
  addps 0x30+C_OFFSET_86(C), C4

  # Write out C(8,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_86(C)
  movaps C2, 0x10+C_OFFSET_86(C)
  movaps C3, 0x20+C_OFFSET_86(C)
  movaps C4, 0x30+C_OFFSET_86(C)

  .align 16
block_433:

  # Check norm of product A(7,1)*B(1,7).
  movss 0xd8(multiply_stream, base_pointer), B1
  mulss 0x130(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_434

  # Reset C(7,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,7) = A(7,1)*B(1,7).
  movaps 0x0+B_OFFSET_17(B), B1
  movaps 0x10+B_OFFSET_17(B), B2
  movaps 0x20+B_OFFSET_17(B), B3
  movaps 0x30+B_OFFSET_17(B), B4
  movaps 0x0+A_OFFSET_71(A), A11
  movaps 0x10+A_OFFSET_71(A), A12
  movaps 0x20+A_OFFSET_71(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_71(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_71(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_71(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_71(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_71(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_71(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_71(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_71(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_71(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_71(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_71(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_71(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_71(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,7) to already existing.
  addps 0x0+C_OFFSET_77(C), C1
  addps 0x10+C_OFFSET_77(C), C2
  addps 0x20+C_OFFSET_77(C), C3
  addps 0x30+C_OFFSET_77(C), C4

  # Write out C(7,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_77(C)
  movaps C2, 0x10+C_OFFSET_77(C)
  movaps C3, 0x20+C_OFFSET_77(C)
  movaps C4, 0x30+C_OFFSET_77(C)

  .align 16
block_434:

  # Check norm of product A(7,2)*B(2,7).
  movss 0xdc(multiply_stream, base_pointer), B1
  mulss 0x150(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_435

  # Reset C(7,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,7) = A(7,2)*B(2,7).
  movaps 0x0+B_OFFSET_27(B), B1
  movaps 0x10+B_OFFSET_27(B), B2
  movaps 0x20+B_OFFSET_27(B), B3
  movaps 0x30+B_OFFSET_27(B), B4
  movaps 0x0+A_OFFSET_72(A), A11
  movaps 0x10+A_OFFSET_72(A), A12
  movaps 0x20+A_OFFSET_72(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_72(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_72(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_72(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_72(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_72(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_72(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_72(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_72(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_72(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_72(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_72(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_72(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_72(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,7) to already existing.
  addps 0x0+C_OFFSET_77(C), C1
  addps 0x10+C_OFFSET_77(C), C2
  addps 0x20+C_OFFSET_77(C), C3
  addps 0x30+C_OFFSET_77(C), C4

  # Write out C(7,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_77(C)
  movaps C2, 0x10+C_OFFSET_77(C)
  movaps C3, 0x20+C_OFFSET_77(C)
  movaps C4, 0x30+C_OFFSET_77(C)

  .align 16
block_435:

  # Check norm of product A(7,1)*B(1,8).
  movss 0xd8(multiply_stream, base_pointer), B1
  mulss 0x134(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_436

  # Reset C(7,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,8) = A(7,1)*B(1,8).
  movaps 0x0+B_OFFSET_18(B), B1
  movaps 0x10+B_OFFSET_18(B), B2
  movaps 0x20+B_OFFSET_18(B), B3
  movaps 0x30+B_OFFSET_18(B), B4
  movaps 0x0+A_OFFSET_71(A), A11
  movaps 0x10+A_OFFSET_71(A), A12
  movaps 0x20+A_OFFSET_71(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_71(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_71(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_71(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_71(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_71(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_71(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_71(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_71(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_71(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_71(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_71(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_71(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_71(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,8) to already existing.
  addps 0x0+C_OFFSET_78(C), C1
  addps 0x10+C_OFFSET_78(C), C2
  addps 0x20+C_OFFSET_78(C), C3
  addps 0x30+C_OFFSET_78(C), C4

  # Write out C(7,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_78(C)
  movaps C2, 0x10+C_OFFSET_78(C)
  movaps C3, 0x20+C_OFFSET_78(C)
  movaps C4, 0x30+C_OFFSET_78(C)

  .align 16
block_436:

  # Check norm of product A(7,2)*B(2,8).
  movss 0xdc(multiply_stream, base_pointer), B1
  mulss 0x154(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_437

  # Reset C(7,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,8) = A(7,2)*B(2,8).
  movaps 0x0+B_OFFSET_28(B), B1
  movaps 0x10+B_OFFSET_28(B), B2
  movaps 0x20+B_OFFSET_28(B), B3
  movaps 0x30+B_OFFSET_28(B), B4
  movaps 0x0+A_OFFSET_72(A), A11
  movaps 0x10+A_OFFSET_72(A), A12
  movaps 0x20+A_OFFSET_72(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_72(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_72(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_72(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_72(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_72(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_72(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_72(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_72(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_72(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_72(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_72(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_72(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_72(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,8) to already existing.
  addps 0x0+C_OFFSET_78(C), C1
  addps 0x10+C_OFFSET_78(C), C2
  addps 0x20+C_OFFSET_78(C), C3
  addps 0x30+C_OFFSET_78(C), C4

  # Write out C(7,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_78(C)
  movaps C2, 0x10+C_OFFSET_78(C)
  movaps C3, 0x20+C_OFFSET_78(C)
  movaps C4, 0x30+C_OFFSET_78(C)

  .align 16
block_437:

  # Check norm of product A(8,1)*B(1,7).
  movss 0xf8(multiply_stream, base_pointer), B1
  mulss 0x130(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_438

  # Reset C(8,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,7) = A(8,1)*B(1,7).
  movaps 0x0+B_OFFSET_17(B), B1
  movaps 0x10+B_OFFSET_17(B), B2
  movaps 0x20+B_OFFSET_17(B), B3
  movaps 0x30+B_OFFSET_17(B), B4
  movaps 0x0+A_OFFSET_81(A), A11
  movaps 0x10+A_OFFSET_81(A), A12
  movaps 0x20+A_OFFSET_81(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_81(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_81(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_81(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_81(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_81(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_81(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_81(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_81(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_81(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_81(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_81(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_81(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_81(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,7) to already existing.
  addps 0x0+C_OFFSET_87(C), C1
  addps 0x10+C_OFFSET_87(C), C2
  addps 0x20+C_OFFSET_87(C), C3
  addps 0x30+C_OFFSET_87(C), C4

  # Write out C(8,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_87(C)
  movaps C2, 0x10+C_OFFSET_87(C)
  movaps C3, 0x20+C_OFFSET_87(C)
  movaps C4, 0x30+C_OFFSET_87(C)

  .align 16
block_438:

  # Check norm of product A(8,2)*B(2,7).
  movss 0xfc(multiply_stream, base_pointer), B1
  mulss 0x150(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_439

  # Reset C(8,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,7) = A(8,2)*B(2,7).
  movaps 0x0+B_OFFSET_27(B), B1
  movaps 0x10+B_OFFSET_27(B), B2
  movaps 0x20+B_OFFSET_27(B), B3
  movaps 0x30+B_OFFSET_27(B), B4
  movaps 0x0+A_OFFSET_82(A), A11
  movaps 0x10+A_OFFSET_82(A), A12
  movaps 0x20+A_OFFSET_82(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_82(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_82(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_82(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_82(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_82(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_82(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_82(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_82(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_82(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_82(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_82(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_82(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_82(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,7) to already existing.
  addps 0x0+C_OFFSET_87(C), C1
  addps 0x10+C_OFFSET_87(C), C2
  addps 0x20+C_OFFSET_87(C), C3
  addps 0x30+C_OFFSET_87(C), C4

  # Write out C(8,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_87(C)
  movaps C2, 0x10+C_OFFSET_87(C)
  movaps C3, 0x20+C_OFFSET_87(C)
  movaps C4, 0x30+C_OFFSET_87(C)

  .align 16
block_439:

  # Check norm of product A(8,1)*B(1,8).
  movss 0xf8(multiply_stream, base_pointer), B1
  mulss 0x134(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_440

  # Reset C(8,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,8) = A(8,1)*B(1,8).
  movaps 0x0+B_OFFSET_18(B), B1
  movaps 0x10+B_OFFSET_18(B), B2
  movaps 0x20+B_OFFSET_18(B), B3
  movaps 0x30+B_OFFSET_18(B), B4
  movaps 0x0+A_OFFSET_81(A), A11
  movaps 0x10+A_OFFSET_81(A), A12
  movaps 0x20+A_OFFSET_81(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_81(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_81(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_81(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_81(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_81(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_81(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_81(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_81(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_81(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_81(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_81(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_81(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_81(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,8) to already existing.
  addps 0x0+C_OFFSET_88(C), C1
  addps 0x10+C_OFFSET_88(C), C2
  addps 0x20+C_OFFSET_88(C), C3
  addps 0x30+C_OFFSET_88(C), C4

  # Write out C(8,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_88(C)
  movaps C2, 0x10+C_OFFSET_88(C)
  movaps C3, 0x20+C_OFFSET_88(C)
  movaps C4, 0x30+C_OFFSET_88(C)

  .align 16
block_440:

  # Check norm of product A(8,2)*B(2,8).
  movss 0xfc(multiply_stream, base_pointer), B1
  mulss 0x154(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_441

  # Reset C(8,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,8) = A(8,2)*B(2,8).
  movaps 0x0+B_OFFSET_28(B), B1
  movaps 0x10+B_OFFSET_28(B), B2
  movaps 0x20+B_OFFSET_28(B), B3
  movaps 0x30+B_OFFSET_28(B), B4
  movaps 0x0+A_OFFSET_82(A), A11
  movaps 0x10+A_OFFSET_82(A), A12
  movaps 0x20+A_OFFSET_82(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_82(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_82(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_82(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_82(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_82(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_82(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_82(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_82(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_82(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_82(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_82(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_82(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_82(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,8) to already existing.
  addps 0x0+C_OFFSET_88(C), C1
  addps 0x10+C_OFFSET_88(C), C2
  addps 0x20+C_OFFSET_88(C), C3
  addps 0x30+C_OFFSET_88(C), C4

  # Write out C(8,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_88(C)
  movaps C2, 0x10+C_OFFSET_88(C)
  movaps C3, 0x20+C_OFFSET_88(C)
  movaps C4, 0x30+C_OFFSET_88(C)

  .align 16
block_441:

  # Check norm of product A(7,3)*B(3,7).
  movss 0xe0(multiply_stream, base_pointer), B1
  mulss 0x170(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_442

  # Reset C(7,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,7) = A(7,3)*B(3,7).
  movaps 0x0+B_OFFSET_37(B), B1
  movaps 0x10+B_OFFSET_37(B), B2
  movaps 0x20+B_OFFSET_37(B), B3
  movaps 0x30+B_OFFSET_37(B), B4
  movaps 0x0+A_OFFSET_73(A), A11
  movaps 0x10+A_OFFSET_73(A), A12
  movaps 0x20+A_OFFSET_73(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_73(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_73(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_73(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_73(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_73(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_73(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_73(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_73(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_73(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_73(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_73(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_73(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_73(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,7) to already existing.
  addps 0x0+C_OFFSET_77(C), C1
  addps 0x10+C_OFFSET_77(C), C2
  addps 0x20+C_OFFSET_77(C), C3
  addps 0x30+C_OFFSET_77(C), C4

  # Write out C(7,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_77(C)
  movaps C2, 0x10+C_OFFSET_77(C)
  movaps C3, 0x20+C_OFFSET_77(C)
  movaps C4, 0x30+C_OFFSET_77(C)

  .align 16
block_442:

  # Check norm of product A(7,4)*B(4,7).
  movss 0xe4(multiply_stream, base_pointer), B1
  mulss 0x190(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_443

  # Reset C(7,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,7) = A(7,4)*B(4,7).
  movaps 0x0+B_OFFSET_47(B), B1
  movaps 0x10+B_OFFSET_47(B), B2
  movaps 0x20+B_OFFSET_47(B), B3
  movaps 0x30+B_OFFSET_47(B), B4
  movaps 0x0+A_OFFSET_74(A), A11
  movaps 0x10+A_OFFSET_74(A), A12
  movaps 0x20+A_OFFSET_74(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_74(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_74(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_74(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_74(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_74(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_74(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_74(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_74(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_74(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_74(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_74(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_74(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_74(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,7) to already existing.
  addps 0x0+C_OFFSET_77(C), C1
  addps 0x10+C_OFFSET_77(C), C2
  addps 0x20+C_OFFSET_77(C), C3
  addps 0x30+C_OFFSET_77(C), C4

  # Write out C(7,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_77(C)
  movaps C2, 0x10+C_OFFSET_77(C)
  movaps C3, 0x20+C_OFFSET_77(C)
  movaps C4, 0x30+C_OFFSET_77(C)

  .align 16
block_443:

  # Check norm of product A(7,3)*B(3,8).
  movss 0xe0(multiply_stream, base_pointer), B1
  mulss 0x174(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_444

  # Reset C(7,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,8) = A(7,3)*B(3,8).
  movaps 0x0+B_OFFSET_38(B), B1
  movaps 0x10+B_OFFSET_38(B), B2
  movaps 0x20+B_OFFSET_38(B), B3
  movaps 0x30+B_OFFSET_38(B), B4
  movaps 0x0+A_OFFSET_73(A), A11
  movaps 0x10+A_OFFSET_73(A), A12
  movaps 0x20+A_OFFSET_73(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_73(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_73(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_73(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_73(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_73(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_73(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_73(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_73(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_73(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_73(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_73(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_73(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_73(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,8) to already existing.
  addps 0x0+C_OFFSET_78(C), C1
  addps 0x10+C_OFFSET_78(C), C2
  addps 0x20+C_OFFSET_78(C), C3
  addps 0x30+C_OFFSET_78(C), C4

  # Write out C(7,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_78(C)
  movaps C2, 0x10+C_OFFSET_78(C)
  movaps C3, 0x20+C_OFFSET_78(C)
  movaps C4, 0x30+C_OFFSET_78(C)

  .align 16
block_444:

  # Check norm of product A(7,4)*B(4,8).
  movss 0xe4(multiply_stream, base_pointer), B1
  mulss 0x194(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_445

  # Reset C(7,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,8) = A(7,4)*B(4,8).
  movaps 0x0+B_OFFSET_48(B), B1
  movaps 0x10+B_OFFSET_48(B), B2
  movaps 0x20+B_OFFSET_48(B), B3
  movaps 0x30+B_OFFSET_48(B), B4
  movaps 0x0+A_OFFSET_74(A), A11
  movaps 0x10+A_OFFSET_74(A), A12
  movaps 0x20+A_OFFSET_74(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_74(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_74(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_74(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_74(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_74(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_74(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_74(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_74(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_74(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_74(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_74(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_74(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_74(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,8) to already existing.
  addps 0x0+C_OFFSET_78(C), C1
  addps 0x10+C_OFFSET_78(C), C2
  addps 0x20+C_OFFSET_78(C), C3
  addps 0x30+C_OFFSET_78(C), C4

  # Write out C(7,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_78(C)
  movaps C2, 0x10+C_OFFSET_78(C)
  movaps C3, 0x20+C_OFFSET_78(C)
  movaps C4, 0x30+C_OFFSET_78(C)

  .align 16
block_445:

  # Check norm of product A(8,3)*B(3,7).
  movss 0x100(multiply_stream, base_pointer), B1
  mulss 0x170(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_446

  # Reset C(8,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,7) = A(8,3)*B(3,7).
  movaps 0x0+B_OFFSET_37(B), B1
  movaps 0x10+B_OFFSET_37(B), B2
  movaps 0x20+B_OFFSET_37(B), B3
  movaps 0x30+B_OFFSET_37(B), B4
  movaps 0x0+A_OFFSET_83(A), A11
  movaps 0x10+A_OFFSET_83(A), A12
  movaps 0x20+A_OFFSET_83(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_83(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_83(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_83(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_83(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_83(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_83(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_83(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_83(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_83(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_83(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_83(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_83(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_83(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,7) to already existing.
  addps 0x0+C_OFFSET_87(C), C1
  addps 0x10+C_OFFSET_87(C), C2
  addps 0x20+C_OFFSET_87(C), C3
  addps 0x30+C_OFFSET_87(C), C4

  # Write out C(8,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_87(C)
  movaps C2, 0x10+C_OFFSET_87(C)
  movaps C3, 0x20+C_OFFSET_87(C)
  movaps C4, 0x30+C_OFFSET_87(C)

  .align 16
block_446:

  # Check norm of product A(8,4)*B(4,7).
  movss 0x104(multiply_stream, base_pointer), B1
  mulss 0x190(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_447

  # Reset C(8,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,7) = A(8,4)*B(4,7).
  movaps 0x0+B_OFFSET_47(B), B1
  movaps 0x10+B_OFFSET_47(B), B2
  movaps 0x20+B_OFFSET_47(B), B3
  movaps 0x30+B_OFFSET_47(B), B4
  movaps 0x0+A_OFFSET_84(A), A11
  movaps 0x10+A_OFFSET_84(A), A12
  movaps 0x20+A_OFFSET_84(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_84(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_84(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_84(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_84(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_84(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_84(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_84(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_84(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_84(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_84(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_84(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_84(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_84(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,7) to already existing.
  addps 0x0+C_OFFSET_87(C), C1
  addps 0x10+C_OFFSET_87(C), C2
  addps 0x20+C_OFFSET_87(C), C3
  addps 0x30+C_OFFSET_87(C), C4

  # Write out C(8,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_87(C)
  movaps C2, 0x10+C_OFFSET_87(C)
  movaps C3, 0x20+C_OFFSET_87(C)
  movaps C4, 0x30+C_OFFSET_87(C)

  .align 16
block_447:

  # Check norm of product A(8,3)*B(3,8).
  movss 0x100(multiply_stream, base_pointer), B1
  mulss 0x174(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_448

  # Reset C(8,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,8) = A(8,3)*B(3,8).
  movaps 0x0+B_OFFSET_38(B), B1
  movaps 0x10+B_OFFSET_38(B), B2
  movaps 0x20+B_OFFSET_38(B), B3
  movaps 0x30+B_OFFSET_38(B), B4
  movaps 0x0+A_OFFSET_83(A), A11
  movaps 0x10+A_OFFSET_83(A), A12
  movaps 0x20+A_OFFSET_83(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_83(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_83(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_83(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_83(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_83(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_83(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_83(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_83(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_83(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_83(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_83(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_83(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_83(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,8) to already existing.
  addps 0x0+C_OFFSET_88(C), C1
  addps 0x10+C_OFFSET_88(C), C2
  addps 0x20+C_OFFSET_88(C), C3
  addps 0x30+C_OFFSET_88(C), C4

  # Write out C(8,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_88(C)
  movaps C2, 0x10+C_OFFSET_88(C)
  movaps C3, 0x20+C_OFFSET_88(C)
  movaps C4, 0x30+C_OFFSET_88(C)

  .align 16
block_448:

  # Check norm of product A(8,4)*B(4,8).
  movss 0x104(multiply_stream, base_pointer), B1
  mulss 0x194(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_449

  # Reset C(8,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,8) = A(8,4)*B(4,8).
  movaps 0x0+B_OFFSET_48(B), B1
  movaps 0x10+B_OFFSET_48(B), B2
  movaps 0x20+B_OFFSET_48(B), B3
  movaps 0x30+B_OFFSET_48(B), B4
  movaps 0x0+A_OFFSET_84(A), A11
  movaps 0x10+A_OFFSET_84(A), A12
  movaps 0x20+A_OFFSET_84(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_84(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_84(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_84(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_84(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_84(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_84(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_84(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_84(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_84(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_84(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_84(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_84(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_84(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,8) to already existing.
  addps 0x0+C_OFFSET_88(C), C1
  addps 0x10+C_OFFSET_88(C), C2
  addps 0x20+C_OFFSET_88(C), C3
  addps 0x30+C_OFFSET_88(C), C4

  # Write out C(8,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_88(C)
  movaps C2, 0x10+C_OFFSET_88(C)
  movaps C3, 0x20+C_OFFSET_88(C)
  movaps C4, 0x30+C_OFFSET_88(C)

  .align 16
block_449:

  # Check norm of product A(5,5)*B(5,5).
  movss 0xa8(multiply_stream, base_pointer), B1
  mulss 0x1a8(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_450

  # Reset C(5,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,5) = A(5,5)*B(5,5).
  movaps 0x0+B_OFFSET_55(B), B1
  movaps 0x10+B_OFFSET_55(B), B2
  movaps 0x20+B_OFFSET_55(B), B3
  movaps 0x30+B_OFFSET_55(B), B4
  movaps 0x0+A_OFFSET_55(A), A11
  movaps 0x10+A_OFFSET_55(A), A12
  movaps 0x20+A_OFFSET_55(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_55(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_55(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_55(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_55(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_55(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_55(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_55(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_55(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_55(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_55(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_55(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_55(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_55(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,5) to already existing.
  addps 0x0+C_OFFSET_55(C), C1
  addps 0x10+C_OFFSET_55(C), C2
  addps 0x20+C_OFFSET_55(C), C3
  addps 0x30+C_OFFSET_55(C), C4

  # Write out C(5,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_55(C)
  movaps C2, 0x10+C_OFFSET_55(C)
  movaps C3, 0x20+C_OFFSET_55(C)
  movaps C4, 0x30+C_OFFSET_55(C)

  .align 16
block_450:

  # Check norm of product A(5,6)*B(6,5).
  movss 0xac(multiply_stream, base_pointer), B1
  mulss 0x1c8(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_451

  # Reset C(5,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,5) = A(5,6)*B(6,5).
  movaps 0x0+B_OFFSET_65(B), B1
  movaps 0x10+B_OFFSET_65(B), B2
  movaps 0x20+B_OFFSET_65(B), B3
  movaps 0x30+B_OFFSET_65(B), B4
  movaps 0x0+A_OFFSET_56(A), A11
  movaps 0x10+A_OFFSET_56(A), A12
  movaps 0x20+A_OFFSET_56(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_56(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_56(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_56(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_56(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_56(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_56(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_56(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_56(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_56(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_56(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_56(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_56(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_56(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,5) to already existing.
  addps 0x0+C_OFFSET_55(C), C1
  addps 0x10+C_OFFSET_55(C), C2
  addps 0x20+C_OFFSET_55(C), C3
  addps 0x30+C_OFFSET_55(C), C4

  # Write out C(5,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_55(C)
  movaps C2, 0x10+C_OFFSET_55(C)
  movaps C3, 0x20+C_OFFSET_55(C)
  movaps C4, 0x30+C_OFFSET_55(C)

  .align 16
block_451:

  # Check norm of product A(5,5)*B(5,6).
  movss 0xa8(multiply_stream, base_pointer), B1
  mulss 0x1ac(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_452

  # Reset C(5,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,6) = A(5,5)*B(5,6).
  movaps 0x0+B_OFFSET_56(B), B1
  movaps 0x10+B_OFFSET_56(B), B2
  movaps 0x20+B_OFFSET_56(B), B3
  movaps 0x30+B_OFFSET_56(B), B4
  movaps 0x0+A_OFFSET_55(A), A11
  movaps 0x10+A_OFFSET_55(A), A12
  movaps 0x20+A_OFFSET_55(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_55(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_55(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_55(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_55(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_55(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_55(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_55(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_55(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_55(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_55(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_55(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_55(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_55(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,6) to already existing.
  addps 0x0+C_OFFSET_56(C), C1
  addps 0x10+C_OFFSET_56(C), C2
  addps 0x20+C_OFFSET_56(C), C3
  addps 0x30+C_OFFSET_56(C), C4

  # Write out C(5,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_56(C)
  movaps C2, 0x10+C_OFFSET_56(C)
  movaps C3, 0x20+C_OFFSET_56(C)
  movaps C4, 0x30+C_OFFSET_56(C)

  .align 16
block_452:

  # Check norm of product A(5,6)*B(6,6).
  movss 0xac(multiply_stream, base_pointer), B1
  mulss 0x1cc(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_453

  # Reset C(5,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,6) = A(5,6)*B(6,6).
  movaps 0x0+B_OFFSET_66(B), B1
  movaps 0x10+B_OFFSET_66(B), B2
  movaps 0x20+B_OFFSET_66(B), B3
  movaps 0x30+B_OFFSET_66(B), B4
  movaps 0x0+A_OFFSET_56(A), A11
  movaps 0x10+A_OFFSET_56(A), A12
  movaps 0x20+A_OFFSET_56(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_56(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_56(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_56(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_56(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_56(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_56(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_56(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_56(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_56(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_56(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_56(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_56(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_56(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,6) to already existing.
  addps 0x0+C_OFFSET_56(C), C1
  addps 0x10+C_OFFSET_56(C), C2
  addps 0x20+C_OFFSET_56(C), C3
  addps 0x30+C_OFFSET_56(C), C4

  # Write out C(5,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_56(C)
  movaps C2, 0x10+C_OFFSET_56(C)
  movaps C3, 0x20+C_OFFSET_56(C)
  movaps C4, 0x30+C_OFFSET_56(C)

  .align 16
block_453:

  # Check norm of product A(6,5)*B(5,5).
  movss 0xc8(multiply_stream, base_pointer), B1
  mulss 0x1a8(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_454

  # Reset C(6,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,5) = A(6,5)*B(5,5).
  movaps 0x0+B_OFFSET_55(B), B1
  movaps 0x10+B_OFFSET_55(B), B2
  movaps 0x20+B_OFFSET_55(B), B3
  movaps 0x30+B_OFFSET_55(B), B4
  movaps 0x0+A_OFFSET_65(A), A11
  movaps 0x10+A_OFFSET_65(A), A12
  movaps 0x20+A_OFFSET_65(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_65(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_65(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_65(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_65(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_65(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_65(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_65(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_65(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_65(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_65(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_65(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_65(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_65(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,5) to already existing.
  addps 0x0+C_OFFSET_65(C), C1
  addps 0x10+C_OFFSET_65(C), C2
  addps 0x20+C_OFFSET_65(C), C3
  addps 0x30+C_OFFSET_65(C), C4

  # Write out C(6,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_65(C)
  movaps C2, 0x10+C_OFFSET_65(C)
  movaps C3, 0x20+C_OFFSET_65(C)
  movaps C4, 0x30+C_OFFSET_65(C)

  .align 16
block_454:

  # Check norm of product A(6,6)*B(6,5).
  movss 0xcc(multiply_stream, base_pointer), B1
  mulss 0x1c8(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_455

  # Reset C(6,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,5) = A(6,6)*B(6,5).
  movaps 0x0+B_OFFSET_65(B), B1
  movaps 0x10+B_OFFSET_65(B), B2
  movaps 0x20+B_OFFSET_65(B), B3
  movaps 0x30+B_OFFSET_65(B), B4
  movaps 0x0+A_OFFSET_66(A), A11
  movaps 0x10+A_OFFSET_66(A), A12
  movaps 0x20+A_OFFSET_66(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_66(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_66(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_66(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_66(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_66(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_66(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_66(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_66(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_66(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_66(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_66(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_66(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_66(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,5) to already existing.
  addps 0x0+C_OFFSET_65(C), C1
  addps 0x10+C_OFFSET_65(C), C2
  addps 0x20+C_OFFSET_65(C), C3
  addps 0x30+C_OFFSET_65(C), C4

  # Write out C(6,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_65(C)
  movaps C2, 0x10+C_OFFSET_65(C)
  movaps C3, 0x20+C_OFFSET_65(C)
  movaps C4, 0x30+C_OFFSET_65(C)

  .align 16
block_455:

  # Check norm of product A(6,5)*B(5,6).
  movss 0xc8(multiply_stream, base_pointer), B1
  mulss 0x1ac(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_456

  # Reset C(6,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,6) = A(6,5)*B(5,6).
  movaps 0x0+B_OFFSET_56(B), B1
  movaps 0x10+B_OFFSET_56(B), B2
  movaps 0x20+B_OFFSET_56(B), B3
  movaps 0x30+B_OFFSET_56(B), B4
  movaps 0x0+A_OFFSET_65(A), A11
  movaps 0x10+A_OFFSET_65(A), A12
  movaps 0x20+A_OFFSET_65(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_65(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_65(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_65(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_65(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_65(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_65(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_65(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_65(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_65(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_65(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_65(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_65(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_65(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,6) to already existing.
  addps 0x0+C_OFFSET_66(C), C1
  addps 0x10+C_OFFSET_66(C), C2
  addps 0x20+C_OFFSET_66(C), C3
  addps 0x30+C_OFFSET_66(C), C4

  # Write out C(6,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_66(C)
  movaps C2, 0x10+C_OFFSET_66(C)
  movaps C3, 0x20+C_OFFSET_66(C)
  movaps C4, 0x30+C_OFFSET_66(C)

  .align 16
block_456:

  # Check norm of product A(6,6)*B(6,6).
  movss 0xcc(multiply_stream, base_pointer), B1
  mulss 0x1cc(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_457

  # Reset C(6,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,6) = A(6,6)*B(6,6).
  movaps 0x0+B_OFFSET_66(B), B1
  movaps 0x10+B_OFFSET_66(B), B2
  movaps 0x20+B_OFFSET_66(B), B3
  movaps 0x30+B_OFFSET_66(B), B4
  movaps 0x0+A_OFFSET_66(A), A11
  movaps 0x10+A_OFFSET_66(A), A12
  movaps 0x20+A_OFFSET_66(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_66(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_66(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_66(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_66(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_66(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_66(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_66(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_66(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_66(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_66(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_66(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_66(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_66(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,6) to already existing.
  addps 0x0+C_OFFSET_66(C), C1
  addps 0x10+C_OFFSET_66(C), C2
  addps 0x20+C_OFFSET_66(C), C3
  addps 0x30+C_OFFSET_66(C), C4

  # Write out C(6,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_66(C)
  movaps C2, 0x10+C_OFFSET_66(C)
  movaps C3, 0x20+C_OFFSET_66(C)
  movaps C4, 0x30+C_OFFSET_66(C)

  .align 16
block_457:

  # Check norm of product A(5,7)*B(7,5).
  movss 0xb0(multiply_stream, base_pointer), B1
  mulss 0x1e8(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_458

  # Reset C(5,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,5) = A(5,7)*B(7,5).
  movaps 0x0+B_OFFSET_75(B), B1
  movaps 0x10+B_OFFSET_75(B), B2
  movaps 0x20+B_OFFSET_75(B), B3
  movaps 0x30+B_OFFSET_75(B), B4
  movaps 0x0+A_OFFSET_57(A), A11
  movaps 0x10+A_OFFSET_57(A), A12
  movaps 0x20+A_OFFSET_57(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_57(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_57(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_57(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_57(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_57(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_57(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_57(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_57(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_57(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_57(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_57(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_57(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_57(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,5) to already existing.
  addps 0x0+C_OFFSET_55(C), C1
  addps 0x10+C_OFFSET_55(C), C2
  addps 0x20+C_OFFSET_55(C), C3
  addps 0x30+C_OFFSET_55(C), C4

  # Write out C(5,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_55(C)
  movaps C2, 0x10+C_OFFSET_55(C)
  movaps C3, 0x20+C_OFFSET_55(C)
  movaps C4, 0x30+C_OFFSET_55(C)

  .align 16
block_458:

  # Check norm of product A(5,8)*B(8,5).
  movss 0xb4(multiply_stream, base_pointer), B1
  mulss 0x208(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_459

  # Reset C(5,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,5) = A(5,8)*B(8,5).
  movaps 0x0+B_OFFSET_85(B), B1
  movaps 0x10+B_OFFSET_85(B), B2
  movaps 0x20+B_OFFSET_85(B), B3
  movaps 0x30+B_OFFSET_85(B), B4
  movaps 0x0+A_OFFSET_58(A), A11
  movaps 0x10+A_OFFSET_58(A), A12
  movaps 0x20+A_OFFSET_58(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_58(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_58(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_58(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_58(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_58(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_58(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_58(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_58(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_58(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_58(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_58(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_58(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_58(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,5) to already existing.
  addps 0x0+C_OFFSET_55(C), C1
  addps 0x10+C_OFFSET_55(C), C2
  addps 0x20+C_OFFSET_55(C), C3
  addps 0x30+C_OFFSET_55(C), C4

  # Write out C(5,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_55(C)
  movaps C2, 0x10+C_OFFSET_55(C)
  movaps C3, 0x20+C_OFFSET_55(C)
  movaps C4, 0x30+C_OFFSET_55(C)

  .align 16
block_459:

  # Check norm of product A(5,7)*B(7,6).
  movss 0xb0(multiply_stream, base_pointer), B1
  mulss 0x1ec(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_460

  # Reset C(5,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,6) = A(5,7)*B(7,6).
  movaps 0x0+B_OFFSET_76(B), B1
  movaps 0x10+B_OFFSET_76(B), B2
  movaps 0x20+B_OFFSET_76(B), B3
  movaps 0x30+B_OFFSET_76(B), B4
  movaps 0x0+A_OFFSET_57(A), A11
  movaps 0x10+A_OFFSET_57(A), A12
  movaps 0x20+A_OFFSET_57(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_57(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_57(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_57(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_57(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_57(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_57(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_57(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_57(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_57(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_57(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_57(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_57(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_57(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,6) to already existing.
  addps 0x0+C_OFFSET_56(C), C1
  addps 0x10+C_OFFSET_56(C), C2
  addps 0x20+C_OFFSET_56(C), C3
  addps 0x30+C_OFFSET_56(C), C4

  # Write out C(5,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_56(C)
  movaps C2, 0x10+C_OFFSET_56(C)
  movaps C3, 0x20+C_OFFSET_56(C)
  movaps C4, 0x30+C_OFFSET_56(C)

  .align 16
block_460:

  # Check norm of product A(5,8)*B(8,6).
  movss 0xb4(multiply_stream, base_pointer), B1
  mulss 0x20c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_461

  # Reset C(5,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,6) = A(5,8)*B(8,6).
  movaps 0x0+B_OFFSET_86(B), B1
  movaps 0x10+B_OFFSET_86(B), B2
  movaps 0x20+B_OFFSET_86(B), B3
  movaps 0x30+B_OFFSET_86(B), B4
  movaps 0x0+A_OFFSET_58(A), A11
  movaps 0x10+A_OFFSET_58(A), A12
  movaps 0x20+A_OFFSET_58(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_58(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_58(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_58(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_58(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_58(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_58(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_58(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_58(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_58(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_58(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_58(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_58(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_58(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,6) to already existing.
  addps 0x0+C_OFFSET_56(C), C1
  addps 0x10+C_OFFSET_56(C), C2
  addps 0x20+C_OFFSET_56(C), C3
  addps 0x30+C_OFFSET_56(C), C4

  # Write out C(5,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_56(C)
  movaps C2, 0x10+C_OFFSET_56(C)
  movaps C3, 0x20+C_OFFSET_56(C)
  movaps C4, 0x30+C_OFFSET_56(C)

  .align 16
block_461:

  # Check norm of product A(6,7)*B(7,5).
  movss 0xd0(multiply_stream, base_pointer), B1
  mulss 0x1e8(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_462

  # Reset C(6,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,5) = A(6,7)*B(7,5).
  movaps 0x0+B_OFFSET_75(B), B1
  movaps 0x10+B_OFFSET_75(B), B2
  movaps 0x20+B_OFFSET_75(B), B3
  movaps 0x30+B_OFFSET_75(B), B4
  movaps 0x0+A_OFFSET_67(A), A11
  movaps 0x10+A_OFFSET_67(A), A12
  movaps 0x20+A_OFFSET_67(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_67(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_67(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_67(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_67(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_67(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_67(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_67(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_67(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_67(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_67(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_67(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_67(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_67(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,5) to already existing.
  addps 0x0+C_OFFSET_65(C), C1
  addps 0x10+C_OFFSET_65(C), C2
  addps 0x20+C_OFFSET_65(C), C3
  addps 0x30+C_OFFSET_65(C), C4

  # Write out C(6,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_65(C)
  movaps C2, 0x10+C_OFFSET_65(C)
  movaps C3, 0x20+C_OFFSET_65(C)
  movaps C4, 0x30+C_OFFSET_65(C)

  .align 16
block_462:

  # Check norm of product A(6,8)*B(8,5).
  movss 0xd4(multiply_stream, base_pointer), B1
  mulss 0x208(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_463

  # Reset C(6,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,5) = A(6,8)*B(8,5).
  movaps 0x0+B_OFFSET_85(B), B1
  movaps 0x10+B_OFFSET_85(B), B2
  movaps 0x20+B_OFFSET_85(B), B3
  movaps 0x30+B_OFFSET_85(B), B4
  movaps 0x0+A_OFFSET_68(A), A11
  movaps 0x10+A_OFFSET_68(A), A12
  movaps 0x20+A_OFFSET_68(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_68(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_68(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_68(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_68(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_68(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_68(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_68(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_68(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_68(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_68(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_68(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_68(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_68(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,5) to already existing.
  addps 0x0+C_OFFSET_65(C), C1
  addps 0x10+C_OFFSET_65(C), C2
  addps 0x20+C_OFFSET_65(C), C3
  addps 0x30+C_OFFSET_65(C), C4

  # Write out C(6,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_65(C)
  movaps C2, 0x10+C_OFFSET_65(C)
  movaps C3, 0x20+C_OFFSET_65(C)
  movaps C4, 0x30+C_OFFSET_65(C)

  .align 16
block_463:

  # Check norm of product A(6,7)*B(7,6).
  movss 0xd0(multiply_stream, base_pointer), B1
  mulss 0x1ec(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_464

  # Reset C(6,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,6) = A(6,7)*B(7,6).
  movaps 0x0+B_OFFSET_76(B), B1
  movaps 0x10+B_OFFSET_76(B), B2
  movaps 0x20+B_OFFSET_76(B), B3
  movaps 0x30+B_OFFSET_76(B), B4
  movaps 0x0+A_OFFSET_67(A), A11
  movaps 0x10+A_OFFSET_67(A), A12
  movaps 0x20+A_OFFSET_67(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_67(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_67(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_67(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_67(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_67(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_67(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_67(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_67(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_67(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_67(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_67(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_67(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_67(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,6) to already existing.
  addps 0x0+C_OFFSET_66(C), C1
  addps 0x10+C_OFFSET_66(C), C2
  addps 0x20+C_OFFSET_66(C), C3
  addps 0x30+C_OFFSET_66(C), C4

  # Write out C(6,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_66(C)
  movaps C2, 0x10+C_OFFSET_66(C)
  movaps C3, 0x20+C_OFFSET_66(C)
  movaps C4, 0x30+C_OFFSET_66(C)

  .align 16
block_464:

  # Check norm of product A(6,8)*B(8,6).
  movss 0xd4(multiply_stream, base_pointer), B1
  mulss 0x20c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_465

  # Reset C(6,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,6) = A(6,8)*B(8,6).
  movaps 0x0+B_OFFSET_86(B), B1
  movaps 0x10+B_OFFSET_86(B), B2
  movaps 0x20+B_OFFSET_86(B), B3
  movaps 0x30+B_OFFSET_86(B), B4
  movaps 0x0+A_OFFSET_68(A), A11
  movaps 0x10+A_OFFSET_68(A), A12
  movaps 0x20+A_OFFSET_68(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_68(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_68(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_68(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_68(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_68(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_68(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_68(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_68(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_68(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_68(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_68(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_68(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_68(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,6) to already existing.
  addps 0x0+C_OFFSET_66(C), C1
  addps 0x10+C_OFFSET_66(C), C2
  addps 0x20+C_OFFSET_66(C), C3
  addps 0x30+C_OFFSET_66(C), C4

  # Write out C(6,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_66(C)
  movaps C2, 0x10+C_OFFSET_66(C)
  movaps C3, 0x20+C_OFFSET_66(C)
  movaps C4, 0x30+C_OFFSET_66(C)

  .align 16
block_465:

  # Check norm of product A(5,5)*B(5,7).
  movss 0xa8(multiply_stream, base_pointer), B1
  mulss 0x1b0(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_466

  # Reset C(5,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,7) = A(5,5)*B(5,7).
  movaps 0x0+B_OFFSET_57(B), B1
  movaps 0x10+B_OFFSET_57(B), B2
  movaps 0x20+B_OFFSET_57(B), B3
  movaps 0x30+B_OFFSET_57(B), B4
  movaps 0x0+A_OFFSET_55(A), A11
  movaps 0x10+A_OFFSET_55(A), A12
  movaps 0x20+A_OFFSET_55(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_55(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_55(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_55(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_55(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_55(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_55(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_55(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_55(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_55(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_55(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_55(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_55(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_55(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,7) to already existing.
  addps 0x0+C_OFFSET_57(C), C1
  addps 0x10+C_OFFSET_57(C), C2
  addps 0x20+C_OFFSET_57(C), C3
  addps 0x30+C_OFFSET_57(C), C4

  # Write out C(5,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_57(C)
  movaps C2, 0x10+C_OFFSET_57(C)
  movaps C3, 0x20+C_OFFSET_57(C)
  movaps C4, 0x30+C_OFFSET_57(C)

  .align 16
block_466:

  # Check norm of product A(5,6)*B(6,7).
  movss 0xac(multiply_stream, base_pointer), B1
  mulss 0x1d0(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_467

  # Reset C(5,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,7) = A(5,6)*B(6,7).
  movaps 0x0+B_OFFSET_67(B), B1
  movaps 0x10+B_OFFSET_67(B), B2
  movaps 0x20+B_OFFSET_67(B), B3
  movaps 0x30+B_OFFSET_67(B), B4
  movaps 0x0+A_OFFSET_56(A), A11
  movaps 0x10+A_OFFSET_56(A), A12
  movaps 0x20+A_OFFSET_56(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_56(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_56(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_56(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_56(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_56(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_56(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_56(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_56(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_56(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_56(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_56(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_56(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_56(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,7) to already existing.
  addps 0x0+C_OFFSET_57(C), C1
  addps 0x10+C_OFFSET_57(C), C2
  addps 0x20+C_OFFSET_57(C), C3
  addps 0x30+C_OFFSET_57(C), C4

  # Write out C(5,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_57(C)
  movaps C2, 0x10+C_OFFSET_57(C)
  movaps C3, 0x20+C_OFFSET_57(C)
  movaps C4, 0x30+C_OFFSET_57(C)

  .align 16
block_467:

  # Check norm of product A(5,5)*B(5,8).
  movss 0xa8(multiply_stream, base_pointer), B1
  mulss 0x1b4(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_468

  # Reset C(5,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,8) = A(5,5)*B(5,8).
  movaps 0x0+B_OFFSET_58(B), B1
  movaps 0x10+B_OFFSET_58(B), B2
  movaps 0x20+B_OFFSET_58(B), B3
  movaps 0x30+B_OFFSET_58(B), B4
  movaps 0x0+A_OFFSET_55(A), A11
  movaps 0x10+A_OFFSET_55(A), A12
  movaps 0x20+A_OFFSET_55(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_55(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_55(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_55(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_55(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_55(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_55(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_55(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_55(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_55(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_55(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_55(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_55(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_55(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,8) to already existing.
  addps 0x0+C_OFFSET_58(C), C1
  addps 0x10+C_OFFSET_58(C), C2
  addps 0x20+C_OFFSET_58(C), C3
  addps 0x30+C_OFFSET_58(C), C4

  # Write out C(5,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_58(C)
  movaps C2, 0x10+C_OFFSET_58(C)
  movaps C3, 0x20+C_OFFSET_58(C)
  movaps C4, 0x30+C_OFFSET_58(C)

  .align 16
block_468:

  # Check norm of product A(5,6)*B(6,8).
  movss 0xac(multiply_stream, base_pointer), B1
  mulss 0x1d4(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_469

  # Reset C(5,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,8) = A(5,6)*B(6,8).
  movaps 0x0+B_OFFSET_68(B), B1
  movaps 0x10+B_OFFSET_68(B), B2
  movaps 0x20+B_OFFSET_68(B), B3
  movaps 0x30+B_OFFSET_68(B), B4
  movaps 0x0+A_OFFSET_56(A), A11
  movaps 0x10+A_OFFSET_56(A), A12
  movaps 0x20+A_OFFSET_56(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_56(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_56(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_56(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_56(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_56(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_56(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_56(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_56(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_56(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_56(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_56(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_56(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_56(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,8) to already existing.
  addps 0x0+C_OFFSET_58(C), C1
  addps 0x10+C_OFFSET_58(C), C2
  addps 0x20+C_OFFSET_58(C), C3
  addps 0x30+C_OFFSET_58(C), C4

  # Write out C(5,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_58(C)
  movaps C2, 0x10+C_OFFSET_58(C)
  movaps C3, 0x20+C_OFFSET_58(C)
  movaps C4, 0x30+C_OFFSET_58(C)

  .align 16
block_469:

  # Check norm of product A(6,5)*B(5,7).
  movss 0xc8(multiply_stream, base_pointer), B1
  mulss 0x1b0(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_470

  # Reset C(6,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,7) = A(6,5)*B(5,7).
  movaps 0x0+B_OFFSET_57(B), B1
  movaps 0x10+B_OFFSET_57(B), B2
  movaps 0x20+B_OFFSET_57(B), B3
  movaps 0x30+B_OFFSET_57(B), B4
  movaps 0x0+A_OFFSET_65(A), A11
  movaps 0x10+A_OFFSET_65(A), A12
  movaps 0x20+A_OFFSET_65(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_65(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_65(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_65(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_65(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_65(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_65(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_65(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_65(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_65(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_65(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_65(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_65(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_65(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,7) to already existing.
  addps 0x0+C_OFFSET_67(C), C1
  addps 0x10+C_OFFSET_67(C), C2
  addps 0x20+C_OFFSET_67(C), C3
  addps 0x30+C_OFFSET_67(C), C4

  # Write out C(6,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_67(C)
  movaps C2, 0x10+C_OFFSET_67(C)
  movaps C3, 0x20+C_OFFSET_67(C)
  movaps C4, 0x30+C_OFFSET_67(C)

  .align 16
block_470:

  # Check norm of product A(6,6)*B(6,7).
  movss 0xcc(multiply_stream, base_pointer), B1
  mulss 0x1d0(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_471

  # Reset C(6,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,7) = A(6,6)*B(6,7).
  movaps 0x0+B_OFFSET_67(B), B1
  movaps 0x10+B_OFFSET_67(B), B2
  movaps 0x20+B_OFFSET_67(B), B3
  movaps 0x30+B_OFFSET_67(B), B4
  movaps 0x0+A_OFFSET_66(A), A11
  movaps 0x10+A_OFFSET_66(A), A12
  movaps 0x20+A_OFFSET_66(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_66(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_66(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_66(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_66(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_66(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_66(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_66(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_66(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_66(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_66(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_66(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_66(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_66(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,7) to already existing.
  addps 0x0+C_OFFSET_67(C), C1
  addps 0x10+C_OFFSET_67(C), C2
  addps 0x20+C_OFFSET_67(C), C3
  addps 0x30+C_OFFSET_67(C), C4

  # Write out C(6,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_67(C)
  movaps C2, 0x10+C_OFFSET_67(C)
  movaps C3, 0x20+C_OFFSET_67(C)
  movaps C4, 0x30+C_OFFSET_67(C)

  .align 16
block_471:

  # Check norm of product A(6,5)*B(5,8).
  movss 0xc8(multiply_stream, base_pointer), B1
  mulss 0x1b4(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_472

  # Reset C(6,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,8) = A(6,5)*B(5,8).
  movaps 0x0+B_OFFSET_58(B), B1
  movaps 0x10+B_OFFSET_58(B), B2
  movaps 0x20+B_OFFSET_58(B), B3
  movaps 0x30+B_OFFSET_58(B), B4
  movaps 0x0+A_OFFSET_65(A), A11
  movaps 0x10+A_OFFSET_65(A), A12
  movaps 0x20+A_OFFSET_65(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_65(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_65(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_65(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_65(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_65(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_65(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_65(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_65(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_65(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_65(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_65(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_65(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_65(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,8) to already existing.
  addps 0x0+C_OFFSET_68(C), C1
  addps 0x10+C_OFFSET_68(C), C2
  addps 0x20+C_OFFSET_68(C), C3
  addps 0x30+C_OFFSET_68(C), C4

  # Write out C(6,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_68(C)
  movaps C2, 0x10+C_OFFSET_68(C)
  movaps C3, 0x20+C_OFFSET_68(C)
  movaps C4, 0x30+C_OFFSET_68(C)

  .align 16
block_472:

  # Check norm of product A(6,6)*B(6,8).
  movss 0xcc(multiply_stream, base_pointer), B1
  mulss 0x1d4(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_473

  # Reset C(6,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,8) = A(6,6)*B(6,8).
  movaps 0x0+B_OFFSET_68(B), B1
  movaps 0x10+B_OFFSET_68(B), B2
  movaps 0x20+B_OFFSET_68(B), B3
  movaps 0x30+B_OFFSET_68(B), B4
  movaps 0x0+A_OFFSET_66(A), A11
  movaps 0x10+A_OFFSET_66(A), A12
  movaps 0x20+A_OFFSET_66(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_66(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_66(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_66(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_66(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_66(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_66(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_66(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_66(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_66(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_66(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_66(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_66(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_66(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,8) to already existing.
  addps 0x0+C_OFFSET_68(C), C1
  addps 0x10+C_OFFSET_68(C), C2
  addps 0x20+C_OFFSET_68(C), C3
  addps 0x30+C_OFFSET_68(C), C4

  # Write out C(6,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_68(C)
  movaps C2, 0x10+C_OFFSET_68(C)
  movaps C3, 0x20+C_OFFSET_68(C)
  movaps C4, 0x30+C_OFFSET_68(C)

  .align 16
block_473:

  # Check norm of product A(5,7)*B(7,7).
  movss 0xb0(multiply_stream, base_pointer), B1
  mulss 0x1f0(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_474

  # Reset C(5,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,7) = A(5,7)*B(7,7).
  movaps 0x0+B_OFFSET_77(B), B1
  movaps 0x10+B_OFFSET_77(B), B2
  movaps 0x20+B_OFFSET_77(B), B3
  movaps 0x30+B_OFFSET_77(B), B4
  movaps 0x0+A_OFFSET_57(A), A11
  movaps 0x10+A_OFFSET_57(A), A12
  movaps 0x20+A_OFFSET_57(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_57(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_57(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_57(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_57(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_57(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_57(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_57(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_57(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_57(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_57(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_57(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_57(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_57(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,7) to already existing.
  addps 0x0+C_OFFSET_57(C), C1
  addps 0x10+C_OFFSET_57(C), C2
  addps 0x20+C_OFFSET_57(C), C3
  addps 0x30+C_OFFSET_57(C), C4

  # Write out C(5,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_57(C)
  movaps C2, 0x10+C_OFFSET_57(C)
  movaps C3, 0x20+C_OFFSET_57(C)
  movaps C4, 0x30+C_OFFSET_57(C)

  .align 16
block_474:

  # Check norm of product A(5,8)*B(8,7).
  movss 0xb4(multiply_stream, base_pointer), B1
  mulss 0x210(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_475

  # Reset C(5,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,7) = A(5,8)*B(8,7).
  movaps 0x0+B_OFFSET_87(B), B1
  movaps 0x10+B_OFFSET_87(B), B2
  movaps 0x20+B_OFFSET_87(B), B3
  movaps 0x30+B_OFFSET_87(B), B4
  movaps 0x0+A_OFFSET_58(A), A11
  movaps 0x10+A_OFFSET_58(A), A12
  movaps 0x20+A_OFFSET_58(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_58(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_58(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_58(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_58(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_58(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_58(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_58(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_58(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_58(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_58(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_58(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_58(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_58(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,7) to already existing.
  addps 0x0+C_OFFSET_57(C), C1
  addps 0x10+C_OFFSET_57(C), C2
  addps 0x20+C_OFFSET_57(C), C3
  addps 0x30+C_OFFSET_57(C), C4

  # Write out C(5,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_57(C)
  movaps C2, 0x10+C_OFFSET_57(C)
  movaps C3, 0x20+C_OFFSET_57(C)
  movaps C4, 0x30+C_OFFSET_57(C)

  .align 16
block_475:

  # Check norm of product A(5,7)*B(7,8).
  movss 0xb0(multiply_stream, base_pointer), B1
  mulss 0x1f4(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_476

  # Reset C(5,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,8) = A(5,7)*B(7,8).
  movaps 0x0+B_OFFSET_78(B), B1
  movaps 0x10+B_OFFSET_78(B), B2
  movaps 0x20+B_OFFSET_78(B), B3
  movaps 0x30+B_OFFSET_78(B), B4
  movaps 0x0+A_OFFSET_57(A), A11
  movaps 0x10+A_OFFSET_57(A), A12
  movaps 0x20+A_OFFSET_57(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_57(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_57(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_57(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_57(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_57(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_57(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_57(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_57(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_57(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_57(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_57(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_57(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_57(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,8) to already existing.
  addps 0x0+C_OFFSET_58(C), C1
  addps 0x10+C_OFFSET_58(C), C2
  addps 0x20+C_OFFSET_58(C), C3
  addps 0x30+C_OFFSET_58(C), C4

  # Write out C(5,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_58(C)
  movaps C2, 0x10+C_OFFSET_58(C)
  movaps C3, 0x20+C_OFFSET_58(C)
  movaps C4, 0x30+C_OFFSET_58(C)

  .align 16
block_476:

  # Check norm of product A(5,8)*B(8,8).
  movss 0xb4(multiply_stream, base_pointer), B1
  mulss 0x214(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_477

  # Reset C(5,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(5,8) = A(5,8)*B(8,8).
  movaps 0x0+B_OFFSET_88(B), B1
  movaps 0x10+B_OFFSET_88(B), B2
  movaps 0x20+B_OFFSET_88(B), B3
  movaps 0x30+B_OFFSET_88(B), B4
  movaps 0x0+A_OFFSET_58(A), A11
  movaps 0x10+A_OFFSET_58(A), A12
  movaps 0x20+A_OFFSET_58(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_58(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_58(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_58(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_58(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_58(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_58(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_58(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_58(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_58(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_58(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_58(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_58(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_58(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(5,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(5,8) to already existing.
  addps 0x0+C_OFFSET_58(C), C1
  addps 0x10+C_OFFSET_58(C), C2
  addps 0x20+C_OFFSET_58(C), C3
  addps 0x30+C_OFFSET_58(C), C4

  # Write out C(5,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_58(C)
  movaps C2, 0x10+C_OFFSET_58(C)
  movaps C3, 0x20+C_OFFSET_58(C)
  movaps C4, 0x30+C_OFFSET_58(C)

  .align 16
block_477:

  # Check norm of product A(6,7)*B(7,7).
  movss 0xd0(multiply_stream, base_pointer), B1
  mulss 0x1f0(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_478

  # Reset C(6,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,7) = A(6,7)*B(7,7).
  movaps 0x0+B_OFFSET_77(B), B1
  movaps 0x10+B_OFFSET_77(B), B2
  movaps 0x20+B_OFFSET_77(B), B3
  movaps 0x30+B_OFFSET_77(B), B4
  movaps 0x0+A_OFFSET_67(A), A11
  movaps 0x10+A_OFFSET_67(A), A12
  movaps 0x20+A_OFFSET_67(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_67(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_67(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_67(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_67(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_67(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_67(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_67(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_67(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_67(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_67(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_67(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_67(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_67(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,7) to already existing.
  addps 0x0+C_OFFSET_67(C), C1
  addps 0x10+C_OFFSET_67(C), C2
  addps 0x20+C_OFFSET_67(C), C3
  addps 0x30+C_OFFSET_67(C), C4

  # Write out C(6,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_67(C)
  movaps C2, 0x10+C_OFFSET_67(C)
  movaps C3, 0x20+C_OFFSET_67(C)
  movaps C4, 0x30+C_OFFSET_67(C)

  .align 16
block_478:

  # Check norm of product A(6,8)*B(8,7).
  movss 0xd4(multiply_stream, base_pointer), B1
  mulss 0x210(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_479

  # Reset C(6,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,7) = A(6,8)*B(8,7).
  movaps 0x0+B_OFFSET_87(B), B1
  movaps 0x10+B_OFFSET_87(B), B2
  movaps 0x20+B_OFFSET_87(B), B3
  movaps 0x30+B_OFFSET_87(B), B4
  movaps 0x0+A_OFFSET_68(A), A11
  movaps 0x10+A_OFFSET_68(A), A12
  movaps 0x20+A_OFFSET_68(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_68(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_68(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_68(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_68(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_68(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_68(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_68(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_68(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_68(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_68(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_68(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_68(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_68(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,7) to already existing.
  addps 0x0+C_OFFSET_67(C), C1
  addps 0x10+C_OFFSET_67(C), C2
  addps 0x20+C_OFFSET_67(C), C3
  addps 0x30+C_OFFSET_67(C), C4

  # Write out C(6,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_67(C)
  movaps C2, 0x10+C_OFFSET_67(C)
  movaps C3, 0x20+C_OFFSET_67(C)
  movaps C4, 0x30+C_OFFSET_67(C)

  .align 16
block_479:

  # Check norm of product A(6,7)*B(7,8).
  movss 0xd0(multiply_stream, base_pointer), B1
  mulss 0x1f4(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_480

  # Reset C(6,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,8) = A(6,7)*B(7,8).
  movaps 0x0+B_OFFSET_78(B), B1
  movaps 0x10+B_OFFSET_78(B), B2
  movaps 0x20+B_OFFSET_78(B), B3
  movaps 0x30+B_OFFSET_78(B), B4
  movaps 0x0+A_OFFSET_67(A), A11
  movaps 0x10+A_OFFSET_67(A), A12
  movaps 0x20+A_OFFSET_67(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_67(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_67(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_67(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_67(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_67(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_67(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_67(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_67(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_67(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_67(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_67(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_67(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_67(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,8) to already existing.
  addps 0x0+C_OFFSET_68(C), C1
  addps 0x10+C_OFFSET_68(C), C2
  addps 0x20+C_OFFSET_68(C), C3
  addps 0x30+C_OFFSET_68(C), C4

  # Write out C(6,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_68(C)
  movaps C2, 0x10+C_OFFSET_68(C)
  movaps C3, 0x20+C_OFFSET_68(C)
  movaps C4, 0x30+C_OFFSET_68(C)

  .align 16
block_480:

  # Check norm of product A(6,8)*B(8,8).
  movss 0xd4(multiply_stream, base_pointer), B1
  mulss 0x214(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_481

  # Reset C(6,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(6,8) = A(6,8)*B(8,8).
  movaps 0x0+B_OFFSET_88(B), B1
  movaps 0x10+B_OFFSET_88(B), B2
  movaps 0x20+B_OFFSET_88(B), B3
  movaps 0x30+B_OFFSET_88(B), B4
  movaps 0x0+A_OFFSET_68(A), A11
  movaps 0x10+A_OFFSET_68(A), A12
  movaps 0x20+A_OFFSET_68(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_68(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_68(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_68(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_68(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_68(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_68(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_68(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_68(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_68(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_68(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_68(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_68(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_68(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(6,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(6,8) to already existing.
  addps 0x0+C_OFFSET_68(C), C1
  addps 0x10+C_OFFSET_68(C), C2
  addps 0x20+C_OFFSET_68(C), C3
  addps 0x30+C_OFFSET_68(C), C4

  # Write out C(6,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_68(C)
  movaps C2, 0x10+C_OFFSET_68(C)
  movaps C3, 0x20+C_OFFSET_68(C)
  movaps C4, 0x30+C_OFFSET_68(C)

  .align 16
block_481:

  # Check norm of product A(7,5)*B(5,5).
  movss 0xe8(multiply_stream, base_pointer), B1
  mulss 0x1a8(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_482

  # Reset C(7,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,5) = A(7,5)*B(5,5).
  movaps 0x0+B_OFFSET_55(B), B1
  movaps 0x10+B_OFFSET_55(B), B2
  movaps 0x20+B_OFFSET_55(B), B3
  movaps 0x30+B_OFFSET_55(B), B4
  movaps 0x0+A_OFFSET_75(A), A11
  movaps 0x10+A_OFFSET_75(A), A12
  movaps 0x20+A_OFFSET_75(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_75(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_75(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_75(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_75(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_75(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_75(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_75(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_75(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_75(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_75(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_75(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_75(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_75(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,5) to already existing.
  addps 0x0+C_OFFSET_75(C), C1
  addps 0x10+C_OFFSET_75(C), C2
  addps 0x20+C_OFFSET_75(C), C3
  addps 0x30+C_OFFSET_75(C), C4

  # Write out C(7,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_75(C)
  movaps C2, 0x10+C_OFFSET_75(C)
  movaps C3, 0x20+C_OFFSET_75(C)
  movaps C4, 0x30+C_OFFSET_75(C)

  .align 16
block_482:

  # Check norm of product A(7,6)*B(6,5).
  movss 0xec(multiply_stream, base_pointer), B1
  mulss 0x1c8(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_483

  # Reset C(7,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,5) = A(7,6)*B(6,5).
  movaps 0x0+B_OFFSET_65(B), B1
  movaps 0x10+B_OFFSET_65(B), B2
  movaps 0x20+B_OFFSET_65(B), B3
  movaps 0x30+B_OFFSET_65(B), B4
  movaps 0x0+A_OFFSET_76(A), A11
  movaps 0x10+A_OFFSET_76(A), A12
  movaps 0x20+A_OFFSET_76(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_76(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_76(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_76(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_76(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_76(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_76(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_76(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_76(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_76(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_76(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_76(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_76(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_76(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,5) to already existing.
  addps 0x0+C_OFFSET_75(C), C1
  addps 0x10+C_OFFSET_75(C), C2
  addps 0x20+C_OFFSET_75(C), C3
  addps 0x30+C_OFFSET_75(C), C4

  # Write out C(7,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_75(C)
  movaps C2, 0x10+C_OFFSET_75(C)
  movaps C3, 0x20+C_OFFSET_75(C)
  movaps C4, 0x30+C_OFFSET_75(C)

  .align 16
block_483:

  # Check norm of product A(7,5)*B(5,6).
  movss 0xe8(multiply_stream, base_pointer), B1
  mulss 0x1ac(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_484

  # Reset C(7,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,6) = A(7,5)*B(5,6).
  movaps 0x0+B_OFFSET_56(B), B1
  movaps 0x10+B_OFFSET_56(B), B2
  movaps 0x20+B_OFFSET_56(B), B3
  movaps 0x30+B_OFFSET_56(B), B4
  movaps 0x0+A_OFFSET_75(A), A11
  movaps 0x10+A_OFFSET_75(A), A12
  movaps 0x20+A_OFFSET_75(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_75(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_75(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_75(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_75(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_75(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_75(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_75(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_75(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_75(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_75(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_75(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_75(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_75(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,6) to already existing.
  addps 0x0+C_OFFSET_76(C), C1
  addps 0x10+C_OFFSET_76(C), C2
  addps 0x20+C_OFFSET_76(C), C3
  addps 0x30+C_OFFSET_76(C), C4

  # Write out C(7,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_76(C)
  movaps C2, 0x10+C_OFFSET_76(C)
  movaps C3, 0x20+C_OFFSET_76(C)
  movaps C4, 0x30+C_OFFSET_76(C)

  .align 16
block_484:

  # Check norm of product A(7,6)*B(6,6).
  movss 0xec(multiply_stream, base_pointer), B1
  mulss 0x1cc(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_485

  # Reset C(7,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,6) = A(7,6)*B(6,6).
  movaps 0x0+B_OFFSET_66(B), B1
  movaps 0x10+B_OFFSET_66(B), B2
  movaps 0x20+B_OFFSET_66(B), B3
  movaps 0x30+B_OFFSET_66(B), B4
  movaps 0x0+A_OFFSET_76(A), A11
  movaps 0x10+A_OFFSET_76(A), A12
  movaps 0x20+A_OFFSET_76(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_76(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_76(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_76(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_76(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_76(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_76(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_76(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_76(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_76(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_76(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_76(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_76(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_76(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,6) to already existing.
  addps 0x0+C_OFFSET_76(C), C1
  addps 0x10+C_OFFSET_76(C), C2
  addps 0x20+C_OFFSET_76(C), C3
  addps 0x30+C_OFFSET_76(C), C4

  # Write out C(7,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_76(C)
  movaps C2, 0x10+C_OFFSET_76(C)
  movaps C3, 0x20+C_OFFSET_76(C)
  movaps C4, 0x30+C_OFFSET_76(C)

  .align 16
block_485:

  # Check norm of product A(8,5)*B(5,5).
  movss 0x108(multiply_stream, base_pointer), B1
  mulss 0x1a8(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_486

  # Reset C(8,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,5) = A(8,5)*B(5,5).
  movaps 0x0+B_OFFSET_55(B), B1
  movaps 0x10+B_OFFSET_55(B), B2
  movaps 0x20+B_OFFSET_55(B), B3
  movaps 0x30+B_OFFSET_55(B), B4
  movaps 0x0+A_OFFSET_85(A), A11
  movaps 0x10+A_OFFSET_85(A), A12
  movaps 0x20+A_OFFSET_85(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_85(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_85(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_85(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_85(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_85(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_85(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_85(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_85(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_85(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_85(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_85(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_85(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_85(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,5) to already existing.
  addps 0x0+C_OFFSET_85(C), C1
  addps 0x10+C_OFFSET_85(C), C2
  addps 0x20+C_OFFSET_85(C), C3
  addps 0x30+C_OFFSET_85(C), C4

  # Write out C(8,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_85(C)
  movaps C2, 0x10+C_OFFSET_85(C)
  movaps C3, 0x20+C_OFFSET_85(C)
  movaps C4, 0x30+C_OFFSET_85(C)

  .align 16
block_486:

  # Check norm of product A(8,6)*B(6,5).
  movss 0x10c(multiply_stream, base_pointer), B1
  mulss 0x1c8(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_487

  # Reset C(8,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,5) = A(8,6)*B(6,5).
  movaps 0x0+B_OFFSET_65(B), B1
  movaps 0x10+B_OFFSET_65(B), B2
  movaps 0x20+B_OFFSET_65(B), B3
  movaps 0x30+B_OFFSET_65(B), B4
  movaps 0x0+A_OFFSET_86(A), A11
  movaps 0x10+A_OFFSET_86(A), A12
  movaps 0x20+A_OFFSET_86(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_86(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_86(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_86(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_86(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_86(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_86(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_86(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_86(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_86(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_86(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_86(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_86(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_86(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,5) to already existing.
  addps 0x0+C_OFFSET_85(C), C1
  addps 0x10+C_OFFSET_85(C), C2
  addps 0x20+C_OFFSET_85(C), C3
  addps 0x30+C_OFFSET_85(C), C4

  # Write out C(8,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_85(C)
  movaps C2, 0x10+C_OFFSET_85(C)
  movaps C3, 0x20+C_OFFSET_85(C)
  movaps C4, 0x30+C_OFFSET_85(C)

  .align 16
block_487:

  # Check norm of product A(8,5)*B(5,6).
  movss 0x108(multiply_stream, base_pointer), B1
  mulss 0x1ac(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_488

  # Reset C(8,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,6) = A(8,5)*B(5,6).
  movaps 0x0+B_OFFSET_56(B), B1
  movaps 0x10+B_OFFSET_56(B), B2
  movaps 0x20+B_OFFSET_56(B), B3
  movaps 0x30+B_OFFSET_56(B), B4
  movaps 0x0+A_OFFSET_85(A), A11
  movaps 0x10+A_OFFSET_85(A), A12
  movaps 0x20+A_OFFSET_85(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_85(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_85(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_85(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_85(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_85(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_85(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_85(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_85(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_85(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_85(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_85(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_85(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_85(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,6) to already existing.
  addps 0x0+C_OFFSET_86(C), C1
  addps 0x10+C_OFFSET_86(C), C2
  addps 0x20+C_OFFSET_86(C), C3
  addps 0x30+C_OFFSET_86(C), C4

  # Write out C(8,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_86(C)
  movaps C2, 0x10+C_OFFSET_86(C)
  movaps C3, 0x20+C_OFFSET_86(C)
  movaps C4, 0x30+C_OFFSET_86(C)

  .align 16
block_488:

  # Check norm of product A(8,6)*B(6,6).
  movss 0x10c(multiply_stream, base_pointer), B1
  mulss 0x1cc(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_489

  # Reset C(8,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,6) = A(8,6)*B(6,6).
  movaps 0x0+B_OFFSET_66(B), B1
  movaps 0x10+B_OFFSET_66(B), B2
  movaps 0x20+B_OFFSET_66(B), B3
  movaps 0x30+B_OFFSET_66(B), B4
  movaps 0x0+A_OFFSET_86(A), A11
  movaps 0x10+A_OFFSET_86(A), A12
  movaps 0x20+A_OFFSET_86(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_86(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_86(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_86(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_86(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_86(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_86(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_86(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_86(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_86(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_86(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_86(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_86(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_86(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,6) to already existing.
  addps 0x0+C_OFFSET_86(C), C1
  addps 0x10+C_OFFSET_86(C), C2
  addps 0x20+C_OFFSET_86(C), C3
  addps 0x30+C_OFFSET_86(C), C4

  # Write out C(8,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_86(C)
  movaps C2, 0x10+C_OFFSET_86(C)
  movaps C3, 0x20+C_OFFSET_86(C)
  movaps C4, 0x30+C_OFFSET_86(C)

  .align 16
block_489:

  # Check norm of product A(7,7)*B(7,5).
  movss 0xf0(multiply_stream, base_pointer), B1
  mulss 0x1e8(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_490

  # Reset C(7,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,5) = A(7,7)*B(7,5).
  movaps 0x0+B_OFFSET_75(B), B1
  movaps 0x10+B_OFFSET_75(B), B2
  movaps 0x20+B_OFFSET_75(B), B3
  movaps 0x30+B_OFFSET_75(B), B4
  movaps 0x0+A_OFFSET_77(A), A11
  movaps 0x10+A_OFFSET_77(A), A12
  movaps 0x20+A_OFFSET_77(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_77(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_77(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_77(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_77(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_77(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_77(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_77(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_77(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_77(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_77(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_77(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_77(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_77(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,5) to already existing.
  addps 0x0+C_OFFSET_75(C), C1
  addps 0x10+C_OFFSET_75(C), C2
  addps 0x20+C_OFFSET_75(C), C3
  addps 0x30+C_OFFSET_75(C), C4

  # Write out C(7,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_75(C)
  movaps C2, 0x10+C_OFFSET_75(C)
  movaps C3, 0x20+C_OFFSET_75(C)
  movaps C4, 0x30+C_OFFSET_75(C)

  .align 16
block_490:

  # Check norm of product A(7,8)*B(8,5).
  movss 0xf4(multiply_stream, base_pointer), B1
  mulss 0x208(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_491

  # Reset C(7,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,5) = A(7,8)*B(8,5).
  movaps 0x0+B_OFFSET_85(B), B1
  movaps 0x10+B_OFFSET_85(B), B2
  movaps 0x20+B_OFFSET_85(B), B3
  movaps 0x30+B_OFFSET_85(B), B4
  movaps 0x0+A_OFFSET_78(A), A11
  movaps 0x10+A_OFFSET_78(A), A12
  movaps 0x20+A_OFFSET_78(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_78(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_78(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_78(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_78(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_78(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_78(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_78(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_78(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_78(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_78(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_78(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_78(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_78(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,5) to already existing.
  addps 0x0+C_OFFSET_75(C), C1
  addps 0x10+C_OFFSET_75(C), C2
  addps 0x20+C_OFFSET_75(C), C3
  addps 0x30+C_OFFSET_75(C), C4

  # Write out C(7,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_75(C)
  movaps C2, 0x10+C_OFFSET_75(C)
  movaps C3, 0x20+C_OFFSET_75(C)
  movaps C4, 0x30+C_OFFSET_75(C)

  .align 16
block_491:

  # Check norm of product A(7,7)*B(7,6).
  movss 0xf0(multiply_stream, base_pointer), B1
  mulss 0x1ec(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_492

  # Reset C(7,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,6) = A(7,7)*B(7,6).
  movaps 0x0+B_OFFSET_76(B), B1
  movaps 0x10+B_OFFSET_76(B), B2
  movaps 0x20+B_OFFSET_76(B), B3
  movaps 0x30+B_OFFSET_76(B), B4
  movaps 0x0+A_OFFSET_77(A), A11
  movaps 0x10+A_OFFSET_77(A), A12
  movaps 0x20+A_OFFSET_77(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_77(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_77(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_77(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_77(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_77(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_77(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_77(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_77(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_77(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_77(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_77(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_77(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_77(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,6) to already existing.
  addps 0x0+C_OFFSET_76(C), C1
  addps 0x10+C_OFFSET_76(C), C2
  addps 0x20+C_OFFSET_76(C), C3
  addps 0x30+C_OFFSET_76(C), C4

  # Write out C(7,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_76(C)
  movaps C2, 0x10+C_OFFSET_76(C)
  movaps C3, 0x20+C_OFFSET_76(C)
  movaps C4, 0x30+C_OFFSET_76(C)

  .align 16
block_492:

  # Check norm of product A(7,8)*B(8,6).
  movss 0xf4(multiply_stream, base_pointer), B1
  mulss 0x20c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_493

  # Reset C(7,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,6) = A(7,8)*B(8,6).
  movaps 0x0+B_OFFSET_86(B), B1
  movaps 0x10+B_OFFSET_86(B), B2
  movaps 0x20+B_OFFSET_86(B), B3
  movaps 0x30+B_OFFSET_86(B), B4
  movaps 0x0+A_OFFSET_78(A), A11
  movaps 0x10+A_OFFSET_78(A), A12
  movaps 0x20+A_OFFSET_78(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_78(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_78(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_78(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_78(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_78(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_78(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_78(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_78(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_78(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_78(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_78(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_78(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_78(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,6) to already existing.
  addps 0x0+C_OFFSET_76(C), C1
  addps 0x10+C_OFFSET_76(C), C2
  addps 0x20+C_OFFSET_76(C), C3
  addps 0x30+C_OFFSET_76(C), C4

  # Write out C(7,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_76(C)
  movaps C2, 0x10+C_OFFSET_76(C)
  movaps C3, 0x20+C_OFFSET_76(C)
  movaps C4, 0x30+C_OFFSET_76(C)

  .align 16
block_493:

  # Check norm of product A(8,7)*B(7,5).
  movss 0x110(multiply_stream, base_pointer), B1
  mulss 0x1e8(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_494

  # Reset C(8,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,5) = A(8,7)*B(7,5).
  movaps 0x0+B_OFFSET_75(B), B1
  movaps 0x10+B_OFFSET_75(B), B2
  movaps 0x20+B_OFFSET_75(B), B3
  movaps 0x30+B_OFFSET_75(B), B4
  movaps 0x0+A_OFFSET_87(A), A11
  movaps 0x10+A_OFFSET_87(A), A12
  movaps 0x20+A_OFFSET_87(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_87(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_87(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_87(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_87(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_87(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_87(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_87(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_87(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_87(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_87(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_87(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_87(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_87(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,5) to already existing.
  addps 0x0+C_OFFSET_85(C), C1
  addps 0x10+C_OFFSET_85(C), C2
  addps 0x20+C_OFFSET_85(C), C3
  addps 0x30+C_OFFSET_85(C), C4

  # Write out C(8,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_85(C)
  movaps C2, 0x10+C_OFFSET_85(C)
  movaps C3, 0x20+C_OFFSET_85(C)
  movaps C4, 0x30+C_OFFSET_85(C)

  .align 16
block_494:

  # Check norm of product A(8,8)*B(8,5).
  movss 0x114(multiply_stream, base_pointer), B1
  mulss 0x208(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_495

  # Reset C(8,5) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,5) = A(8,8)*B(8,5).
  movaps 0x0+B_OFFSET_85(B), B1
  movaps 0x10+B_OFFSET_85(B), B2
  movaps 0x20+B_OFFSET_85(B), B3
  movaps 0x30+B_OFFSET_85(B), B4
  movaps 0x0+A_OFFSET_88(A), A11
  movaps 0x10+A_OFFSET_88(A), A12
  movaps 0x20+A_OFFSET_88(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_88(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_88(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_88(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_88(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_88(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_88(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_88(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_88(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_88(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_88(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_88(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_88(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_88(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,5) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,5) to already existing.
  addps 0x0+C_OFFSET_85(C), C1
  addps 0x10+C_OFFSET_85(C), C2
  addps 0x20+C_OFFSET_85(C), C3
  addps 0x30+C_OFFSET_85(C), C4

  # Write out C(8,5) submatrix block.
  movaps C1, 0x0+C_OFFSET_85(C)
  movaps C2, 0x10+C_OFFSET_85(C)
  movaps C3, 0x20+C_OFFSET_85(C)
  movaps C4, 0x30+C_OFFSET_85(C)

  .align 16
block_495:

  # Check norm of product A(8,7)*B(7,6).
  movss 0x110(multiply_stream, base_pointer), B1
  mulss 0x1ec(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_496

  # Reset C(8,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,6) = A(8,7)*B(7,6).
  movaps 0x0+B_OFFSET_76(B), B1
  movaps 0x10+B_OFFSET_76(B), B2
  movaps 0x20+B_OFFSET_76(B), B3
  movaps 0x30+B_OFFSET_76(B), B4
  movaps 0x0+A_OFFSET_87(A), A11
  movaps 0x10+A_OFFSET_87(A), A12
  movaps 0x20+A_OFFSET_87(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_87(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_87(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_87(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_87(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_87(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_87(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_87(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_87(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_87(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_87(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_87(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_87(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_87(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,6) to already existing.
  addps 0x0+C_OFFSET_86(C), C1
  addps 0x10+C_OFFSET_86(C), C2
  addps 0x20+C_OFFSET_86(C), C3
  addps 0x30+C_OFFSET_86(C), C4

  # Write out C(8,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_86(C)
  movaps C2, 0x10+C_OFFSET_86(C)
  movaps C3, 0x20+C_OFFSET_86(C)
  movaps C4, 0x30+C_OFFSET_86(C)

  .align 16
block_496:

  # Check norm of product A(8,8)*B(8,6).
  movss 0x114(multiply_stream, base_pointer), B1
  mulss 0x20c(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_497

  # Reset C(8,6) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,6) = A(8,8)*B(8,6).
  movaps 0x0+B_OFFSET_86(B), B1
  movaps 0x10+B_OFFSET_86(B), B2
  movaps 0x20+B_OFFSET_86(B), B3
  movaps 0x30+B_OFFSET_86(B), B4
  movaps 0x0+A_OFFSET_88(A), A11
  movaps 0x10+A_OFFSET_88(A), A12
  movaps 0x20+A_OFFSET_88(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_88(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_88(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_88(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_88(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_88(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_88(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_88(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_88(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_88(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_88(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_88(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_88(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_88(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,6) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,6) to already existing.
  addps 0x0+C_OFFSET_86(C), C1
  addps 0x10+C_OFFSET_86(C), C2
  addps 0x20+C_OFFSET_86(C), C3
  addps 0x30+C_OFFSET_86(C), C4

  # Write out C(8,6) submatrix block.
  movaps C1, 0x0+C_OFFSET_86(C)
  movaps C2, 0x10+C_OFFSET_86(C)
  movaps C3, 0x20+C_OFFSET_86(C)
  movaps C4, 0x30+C_OFFSET_86(C)

  .align 16
block_497:

  # Check norm of product A(7,5)*B(5,7).
  movss 0xe8(multiply_stream, base_pointer), B1
  mulss 0x1b0(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_498

  # Reset C(7,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,7) = A(7,5)*B(5,7).
  movaps 0x0+B_OFFSET_57(B), B1
  movaps 0x10+B_OFFSET_57(B), B2
  movaps 0x20+B_OFFSET_57(B), B3
  movaps 0x30+B_OFFSET_57(B), B4
  movaps 0x0+A_OFFSET_75(A), A11
  movaps 0x10+A_OFFSET_75(A), A12
  movaps 0x20+A_OFFSET_75(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_75(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_75(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_75(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_75(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_75(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_75(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_75(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_75(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_75(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_75(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_75(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_75(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_75(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,7) to already existing.
  addps 0x0+C_OFFSET_77(C), C1
  addps 0x10+C_OFFSET_77(C), C2
  addps 0x20+C_OFFSET_77(C), C3
  addps 0x30+C_OFFSET_77(C), C4

  # Write out C(7,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_77(C)
  movaps C2, 0x10+C_OFFSET_77(C)
  movaps C3, 0x20+C_OFFSET_77(C)
  movaps C4, 0x30+C_OFFSET_77(C)

  .align 16
block_498:

  # Check norm of product A(7,6)*B(6,7).
  movss 0xec(multiply_stream, base_pointer), B1
  mulss 0x1d0(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_499

  # Reset C(7,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,7) = A(7,6)*B(6,7).
  movaps 0x0+B_OFFSET_67(B), B1
  movaps 0x10+B_OFFSET_67(B), B2
  movaps 0x20+B_OFFSET_67(B), B3
  movaps 0x30+B_OFFSET_67(B), B4
  movaps 0x0+A_OFFSET_76(A), A11
  movaps 0x10+A_OFFSET_76(A), A12
  movaps 0x20+A_OFFSET_76(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_76(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_76(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_76(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_76(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_76(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_76(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_76(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_76(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_76(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_76(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_76(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_76(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_76(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,7) to already existing.
  addps 0x0+C_OFFSET_77(C), C1
  addps 0x10+C_OFFSET_77(C), C2
  addps 0x20+C_OFFSET_77(C), C3
  addps 0x30+C_OFFSET_77(C), C4

  # Write out C(7,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_77(C)
  movaps C2, 0x10+C_OFFSET_77(C)
  movaps C3, 0x20+C_OFFSET_77(C)
  movaps C4, 0x30+C_OFFSET_77(C)

  .align 16
block_499:

  # Check norm of product A(7,5)*B(5,8).
  movss 0xe8(multiply_stream, base_pointer), B1
  mulss 0x1b4(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_500

  # Reset C(7,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,8) = A(7,5)*B(5,8).
  movaps 0x0+B_OFFSET_58(B), B1
  movaps 0x10+B_OFFSET_58(B), B2
  movaps 0x20+B_OFFSET_58(B), B3
  movaps 0x30+B_OFFSET_58(B), B4
  movaps 0x0+A_OFFSET_75(A), A11
  movaps 0x10+A_OFFSET_75(A), A12
  movaps 0x20+A_OFFSET_75(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_75(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_75(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_75(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_75(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_75(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_75(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_75(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_75(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_75(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_75(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_75(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_75(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_75(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,8) to already existing.
  addps 0x0+C_OFFSET_78(C), C1
  addps 0x10+C_OFFSET_78(C), C2
  addps 0x20+C_OFFSET_78(C), C3
  addps 0x30+C_OFFSET_78(C), C4

  # Write out C(7,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_78(C)
  movaps C2, 0x10+C_OFFSET_78(C)
  movaps C3, 0x20+C_OFFSET_78(C)
  movaps C4, 0x30+C_OFFSET_78(C)

  .align 16
block_500:

  # Check norm of product A(7,6)*B(6,8).
  movss 0xec(multiply_stream, base_pointer), B1
  mulss 0x1d4(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_501

  # Reset C(7,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,8) = A(7,6)*B(6,8).
  movaps 0x0+B_OFFSET_68(B), B1
  movaps 0x10+B_OFFSET_68(B), B2
  movaps 0x20+B_OFFSET_68(B), B3
  movaps 0x30+B_OFFSET_68(B), B4
  movaps 0x0+A_OFFSET_76(A), A11
  movaps 0x10+A_OFFSET_76(A), A12
  movaps 0x20+A_OFFSET_76(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_76(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_76(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_76(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_76(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_76(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_76(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_76(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_76(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_76(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_76(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_76(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_76(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_76(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,8) to already existing.
  addps 0x0+C_OFFSET_78(C), C1
  addps 0x10+C_OFFSET_78(C), C2
  addps 0x20+C_OFFSET_78(C), C3
  addps 0x30+C_OFFSET_78(C), C4

  # Write out C(7,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_78(C)
  movaps C2, 0x10+C_OFFSET_78(C)
  movaps C3, 0x20+C_OFFSET_78(C)
  movaps C4, 0x30+C_OFFSET_78(C)

  .align 16
block_501:

  # Check norm of product A(8,5)*B(5,7).
  movss 0x108(multiply_stream, base_pointer), B1
  mulss 0x1b0(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_502

  # Reset C(8,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,7) = A(8,5)*B(5,7).
  movaps 0x0+B_OFFSET_57(B), B1
  movaps 0x10+B_OFFSET_57(B), B2
  movaps 0x20+B_OFFSET_57(B), B3
  movaps 0x30+B_OFFSET_57(B), B4
  movaps 0x0+A_OFFSET_85(A), A11
  movaps 0x10+A_OFFSET_85(A), A12
  movaps 0x20+A_OFFSET_85(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_85(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_85(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_85(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_85(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_85(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_85(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_85(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_85(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_85(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_85(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_85(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_85(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_85(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,7) to already existing.
  addps 0x0+C_OFFSET_87(C), C1
  addps 0x10+C_OFFSET_87(C), C2
  addps 0x20+C_OFFSET_87(C), C3
  addps 0x30+C_OFFSET_87(C), C4

  # Write out C(8,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_87(C)
  movaps C2, 0x10+C_OFFSET_87(C)
  movaps C3, 0x20+C_OFFSET_87(C)
  movaps C4, 0x30+C_OFFSET_87(C)

  .align 16
block_502:

  # Check norm of product A(8,6)*B(6,7).
  movss 0x10c(multiply_stream, base_pointer), B1
  mulss 0x1d0(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_503

  # Reset C(8,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,7) = A(8,6)*B(6,7).
  movaps 0x0+B_OFFSET_67(B), B1
  movaps 0x10+B_OFFSET_67(B), B2
  movaps 0x20+B_OFFSET_67(B), B3
  movaps 0x30+B_OFFSET_67(B), B4
  movaps 0x0+A_OFFSET_86(A), A11
  movaps 0x10+A_OFFSET_86(A), A12
  movaps 0x20+A_OFFSET_86(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_86(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_86(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_86(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_86(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_86(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_86(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_86(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_86(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_86(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_86(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_86(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_86(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_86(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,7) to already existing.
  addps 0x0+C_OFFSET_87(C), C1
  addps 0x10+C_OFFSET_87(C), C2
  addps 0x20+C_OFFSET_87(C), C3
  addps 0x30+C_OFFSET_87(C), C4

  # Write out C(8,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_87(C)
  movaps C2, 0x10+C_OFFSET_87(C)
  movaps C3, 0x20+C_OFFSET_87(C)
  movaps C4, 0x30+C_OFFSET_87(C)

  .align 16
block_503:

  # Check norm of product A(8,5)*B(5,8).
  movss 0x108(multiply_stream, base_pointer), B1
  mulss 0x1b4(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_504

  # Reset C(8,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,8) = A(8,5)*B(5,8).
  movaps 0x0+B_OFFSET_58(B), B1
  movaps 0x10+B_OFFSET_58(B), B2
  movaps 0x20+B_OFFSET_58(B), B3
  movaps 0x30+B_OFFSET_58(B), B4
  movaps 0x0+A_OFFSET_85(A), A11
  movaps 0x10+A_OFFSET_85(A), A12
  movaps 0x20+A_OFFSET_85(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_85(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_85(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_85(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_85(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_85(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_85(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_85(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_85(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_85(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_85(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_85(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_85(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_85(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,8) to already existing.
  addps 0x0+C_OFFSET_88(C), C1
  addps 0x10+C_OFFSET_88(C), C2
  addps 0x20+C_OFFSET_88(C), C3
  addps 0x30+C_OFFSET_88(C), C4

  # Write out C(8,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_88(C)
  movaps C2, 0x10+C_OFFSET_88(C)
  movaps C3, 0x20+C_OFFSET_88(C)
  movaps C4, 0x30+C_OFFSET_88(C)

  .align 16
block_504:

  # Check norm of product A(8,6)*B(6,8).
  movss 0x10c(multiply_stream, base_pointer), B1
  mulss 0x1d4(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_505

  # Reset C(8,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,8) = A(8,6)*B(6,8).
  movaps 0x0+B_OFFSET_68(B), B1
  movaps 0x10+B_OFFSET_68(B), B2
  movaps 0x20+B_OFFSET_68(B), B3
  movaps 0x30+B_OFFSET_68(B), B4
  movaps 0x0+A_OFFSET_86(A), A11
  movaps 0x10+A_OFFSET_86(A), A12
  movaps 0x20+A_OFFSET_86(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_86(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_86(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_86(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_86(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_86(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_86(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_86(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_86(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_86(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_86(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_86(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_86(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_86(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,8) to already existing.
  addps 0x0+C_OFFSET_88(C), C1
  addps 0x10+C_OFFSET_88(C), C2
  addps 0x20+C_OFFSET_88(C), C3
  addps 0x30+C_OFFSET_88(C), C4

  # Write out C(8,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_88(C)
  movaps C2, 0x10+C_OFFSET_88(C)
  movaps C3, 0x20+C_OFFSET_88(C)
  movaps C4, 0x30+C_OFFSET_88(C)

  .align 16
block_505:

  # Check norm of product A(7,7)*B(7,7).
  movss 0xf0(multiply_stream, base_pointer), B1
  mulss 0x1f0(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_506

  # Reset C(7,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,7) = A(7,7)*B(7,7).
  movaps 0x0+B_OFFSET_77(B), B1
  movaps 0x10+B_OFFSET_77(B), B2
  movaps 0x20+B_OFFSET_77(B), B3
  movaps 0x30+B_OFFSET_77(B), B4
  movaps 0x0+A_OFFSET_77(A), A11
  movaps 0x10+A_OFFSET_77(A), A12
  movaps 0x20+A_OFFSET_77(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_77(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_77(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_77(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_77(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_77(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_77(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_77(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_77(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_77(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_77(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_77(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_77(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_77(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,7) to already existing.
  addps 0x0+C_OFFSET_77(C), C1
  addps 0x10+C_OFFSET_77(C), C2
  addps 0x20+C_OFFSET_77(C), C3
  addps 0x30+C_OFFSET_77(C), C4

  # Write out C(7,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_77(C)
  movaps C2, 0x10+C_OFFSET_77(C)
  movaps C3, 0x20+C_OFFSET_77(C)
  movaps C4, 0x30+C_OFFSET_77(C)

  .align 16
block_506:

  # Check norm of product A(7,8)*B(8,7).
  movss 0xf4(multiply_stream, base_pointer), B1
  mulss 0x210(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_507

  # Reset C(7,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,7) = A(7,8)*B(8,7).
  movaps 0x0+B_OFFSET_87(B), B1
  movaps 0x10+B_OFFSET_87(B), B2
  movaps 0x20+B_OFFSET_87(B), B3
  movaps 0x30+B_OFFSET_87(B), B4
  movaps 0x0+A_OFFSET_78(A), A11
  movaps 0x10+A_OFFSET_78(A), A12
  movaps 0x20+A_OFFSET_78(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_78(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_78(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_78(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_78(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_78(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_78(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_78(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_78(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_78(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_78(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_78(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_78(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_78(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,7) to already existing.
  addps 0x0+C_OFFSET_77(C), C1
  addps 0x10+C_OFFSET_77(C), C2
  addps 0x20+C_OFFSET_77(C), C3
  addps 0x30+C_OFFSET_77(C), C4

  # Write out C(7,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_77(C)
  movaps C2, 0x10+C_OFFSET_77(C)
  movaps C3, 0x20+C_OFFSET_77(C)
  movaps C4, 0x30+C_OFFSET_77(C)

  .align 16
block_507:

  # Check norm of product A(7,7)*B(7,8).
  movss 0xf0(multiply_stream, base_pointer), B1
  mulss 0x1f4(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_508

  # Reset C(7,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,8) = A(7,7)*B(7,8).
  movaps 0x0+B_OFFSET_78(B), B1
  movaps 0x10+B_OFFSET_78(B), B2
  movaps 0x20+B_OFFSET_78(B), B3
  movaps 0x30+B_OFFSET_78(B), B4
  movaps 0x0+A_OFFSET_77(A), A11
  movaps 0x10+A_OFFSET_77(A), A12
  movaps 0x20+A_OFFSET_77(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_77(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_77(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_77(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_77(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_77(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_77(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_77(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_77(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_77(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_77(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_77(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_77(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_77(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,8) to already existing.
  addps 0x0+C_OFFSET_78(C), C1
  addps 0x10+C_OFFSET_78(C), C2
  addps 0x20+C_OFFSET_78(C), C3
  addps 0x30+C_OFFSET_78(C), C4

  # Write out C(7,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_78(C)
  movaps C2, 0x10+C_OFFSET_78(C)
  movaps C3, 0x20+C_OFFSET_78(C)
  movaps C4, 0x30+C_OFFSET_78(C)

  .align 16
block_508:

  # Check norm of product A(7,8)*B(8,8).
  movss 0xf4(multiply_stream, base_pointer), B1
  mulss 0x214(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_509

  # Reset C(7,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(7,8) = A(7,8)*B(8,8).
  movaps 0x0+B_OFFSET_88(B), B1
  movaps 0x10+B_OFFSET_88(B), B2
  movaps 0x20+B_OFFSET_88(B), B3
  movaps 0x30+B_OFFSET_88(B), B4
  movaps 0x0+A_OFFSET_78(A), A11
  movaps 0x10+A_OFFSET_78(A), A12
  movaps 0x20+A_OFFSET_78(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_78(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_78(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_78(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_78(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_78(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_78(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_78(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_78(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_78(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_78(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_78(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_78(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_78(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(7,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(7,8) to already existing.
  addps 0x0+C_OFFSET_78(C), C1
  addps 0x10+C_OFFSET_78(C), C2
  addps 0x20+C_OFFSET_78(C), C3
  addps 0x30+C_OFFSET_78(C), C4

  # Write out C(7,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_78(C)
  movaps C2, 0x10+C_OFFSET_78(C)
  movaps C3, 0x20+C_OFFSET_78(C)
  movaps C4, 0x30+C_OFFSET_78(C)

  .align 16
block_509:

  # Check norm of product A(8,7)*B(7,7).
  movss 0x110(multiply_stream, base_pointer), B1
  mulss 0x1f0(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_510

  # Reset C(8,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,7) = A(8,7)*B(7,7).
  movaps 0x0+B_OFFSET_77(B), B1
  movaps 0x10+B_OFFSET_77(B), B2
  movaps 0x20+B_OFFSET_77(B), B3
  movaps 0x30+B_OFFSET_77(B), B4
  movaps 0x0+A_OFFSET_87(A), A11
  movaps 0x10+A_OFFSET_87(A), A12
  movaps 0x20+A_OFFSET_87(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_87(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_87(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_87(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_87(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_87(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_87(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_87(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_87(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_87(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_87(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_87(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_87(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_87(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,7) to already existing.
  addps 0x0+C_OFFSET_87(C), C1
  addps 0x10+C_OFFSET_87(C), C2
  addps 0x20+C_OFFSET_87(C), C3
  addps 0x30+C_OFFSET_87(C), C4

  # Write out C(8,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_87(C)
  movaps C2, 0x10+C_OFFSET_87(C)
  movaps C3, 0x20+C_OFFSET_87(C)
  movaps C4, 0x30+C_OFFSET_87(C)

  .align 16
block_510:

  # Check norm of product A(8,8)*B(8,7).
  movss 0x114(multiply_stream, base_pointer), B1
  mulss 0x210(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_511

  # Reset C(8,7) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,7) = A(8,8)*B(8,7).
  movaps 0x0+B_OFFSET_87(B), B1
  movaps 0x10+B_OFFSET_87(B), B2
  movaps 0x20+B_OFFSET_87(B), B3
  movaps 0x30+B_OFFSET_87(B), B4
  movaps 0x0+A_OFFSET_88(A), A11
  movaps 0x10+A_OFFSET_88(A), A12
  movaps 0x20+A_OFFSET_88(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_88(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_88(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_88(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_88(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_88(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_88(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_88(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_88(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_88(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_88(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_88(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_88(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_88(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,7) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,7) to already existing.
  addps 0x0+C_OFFSET_87(C), C1
  addps 0x10+C_OFFSET_87(C), C2
  addps 0x20+C_OFFSET_87(C), C3
  addps 0x30+C_OFFSET_87(C), C4

  # Write out C(8,7) submatrix block.
  movaps C1, 0x0+C_OFFSET_87(C)
  movaps C2, 0x10+C_OFFSET_87(C)
  movaps C3, 0x20+C_OFFSET_87(C)
  movaps C4, 0x30+C_OFFSET_87(C)

  .align 16
block_511:

  # Check norm of product A(8,7)*B(7,8).
  movss 0x110(multiply_stream, base_pointer), B1
  mulss 0x1f4(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_512

  # Reset C(8,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,8) = A(8,7)*B(7,8).
  movaps 0x0+B_OFFSET_78(B), B1
  movaps 0x10+B_OFFSET_78(B), B2
  movaps 0x20+B_OFFSET_78(B), B3
  movaps 0x30+B_OFFSET_78(B), B4
  movaps 0x0+A_OFFSET_87(A), A11
  movaps 0x10+A_OFFSET_87(A), A12
  movaps 0x20+A_OFFSET_87(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_87(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_87(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_87(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_87(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_87(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_87(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_87(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_87(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_87(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_87(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_87(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_87(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_87(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,8) to already existing.
  addps 0x0+C_OFFSET_88(C), C1
  addps 0x10+C_OFFSET_88(C), C2
  addps 0x20+C_OFFSET_88(C), C3
  addps 0x30+C_OFFSET_88(C), C4

  # Write out C(8,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_88(C)
  movaps C2, 0x10+C_OFFSET_88(C)
  movaps C3, 0x20+C_OFFSET_88(C)
  movaps C4, 0x30+C_OFFSET_88(C)

  .align 16
block_512:

  # Check norm of product A(8,8)*B(8,8).
  movss 0x114(multiply_stream, base_pointer), B1
  mulss 0x214(multiply_stream, base_pointer), B1
  comiss tolerance, B1
  jb block_513

  # Reset C(8,8) matrix block accumulators.
  xorps C1, C1
  xorps C2, C2
  xorps C3, C3
  xorps C4, C4

  # Calculate C(8,8) = A(8,8)*B(8,8).
  movaps 0x0+B_OFFSET_88(B), B1
  movaps 0x10+B_OFFSET_88(B), B2
  movaps 0x20+B_OFFSET_88(B), B3
  movaps 0x30+B_OFFSET_88(B), B4
  movaps 0x0+A_OFFSET_88(A), A11
  movaps 0x10+A_OFFSET_88(A), A12
  movaps 0x20+A_OFFSET_88(A), A13
  mulps B1, A11
  mulps B2, A12
  addps A11, C1
  movaps 0x30+A_OFFSET_88(A), A14
  mulps B3, A13
  addps A12, C1
  movaps 0x40+A_OFFSET_88(A), A21
  mulps B4, A14
  addps A13, C1
  movaps 0x50+A_OFFSET_88(A), A22
  mulps B1, A21
  addps A14, C1
  movaps 0x60+A_OFFSET_88(A), A23
  mulps B2, A22
  addps A21, C2
  movaps 0x70+A_OFFSET_88(A), A24
  mulps B3, A23
  addps A22, C2
  movaps 0x80+A_OFFSET_88(A), A31
  mulps B4, A24
  addps A23, C2
  movaps 0x90+A_OFFSET_88(A), A32
  mulps B1, A31
  addps A24, C2
  movaps 0xa0+A_OFFSET_88(A), A33
  mulps B2, A32
  addps A31, C3
  movaps 0xb0+A_OFFSET_88(A), A34
  mulps B3, A33
  addps A32, C3
  movaps 0xc0+A_OFFSET_88(A), A41
  mulps B4, A34
  addps A33, C3
  movaps 0xd0+A_OFFSET_88(A), A42
  mulps B1, A41
  addps A34, C3
  movaps 0xe0+A_OFFSET_88(A), A43
  mulps B2, A42
  addps A41, C4
  movaps 0xf0+A_OFFSET_88(A), A44
  mulps B3, A43
  addps A42, C4
  mulps B4, A44
  addps A43, C4
  addps A44, C4

  # Multiply C(8,8) by alpha.
  mulps alpha, C1
  mulps alpha, C2
  mulps alpha, C3
  mulps alpha, C4

  # Add accumulated C(8,8) to already existing.
  addps 0x0+C_OFFSET_88(C), C1
  addps 0x10+C_OFFSET_88(C), C2
  addps 0x20+C_OFFSET_88(C), C3
  addps 0x30+C_OFFSET_88(C), C4

  # Write out C(8,8) submatrix block.
  movaps C1, 0x0+C_OFFSET_88(C)
  movaps C2, 0x10+C_OFFSET_88(C)
  movaps C3, 0x20+C_OFFSET_88(C)
  movaps C4, 0x30+C_OFFSET_88(C)

  .align 16
block_513:

  # Loop end.
  inc index
  mov index, base_pointer
  cmp number_stream_elements, index
  jb loop

  .align 16
done:

  # Pop registers from stack.
  pop C
  pop B
  pop A
  pop base_pointer
  pop index

  ret

  # Function epilog.
  .size stream_kernel_22, .-stream_kernel_22
