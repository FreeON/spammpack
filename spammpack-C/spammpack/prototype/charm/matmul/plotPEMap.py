#!/usr/bin/env python

## @file
#
# Plot a PEMap. The PEMap is generated by running matmul with the
# --print-PEMap command line option.
#
# @author Nicolas Bock <nicolas.bock@freeon.org>
# @author Matt Challacombe <matt.challacombe@freeon.org>

import argparse
import math
import numpy as np
import re
import subprocess
import sys
import tempfile

##############################################

## Print a line in the POVRay script.
#
# @param line The line to print.
def script (line):
  global script_file
  global python_version
  if python_version.major == 2:
    script_file.write(line)
  else:
    script_file.write(bytes(line, "UTF-8"))

## Open a script file.
#
# @param iteration The current iteration.
# @param suffix The script filename suffix.
def openScriptFile (iteration, suffix):
  global basename
  global script_file
  if basename != None:
    script_file = open("{:s}.{:d}.{:s}".format(
      basename, iteration, suffix), "w+b")
  else:
    script_file = tempfile.NamedTemporaryFile(
        suffix = ".{:d}.{:s}".format(iteration, suffix), delete = False)
  print("writing script into {:s}".format(script_file.name))

## Get a color vector given a PE.
#
# @param value The value of the PE.
# @param N The total number of PEs.
#
# @return The color vector as RGB values between [ 0, 1 ].
def getColor (value, N):
  return [
      math.cos(value/float(N-1)*math.pi/2.),
      math.sin(value/float(N-1)*math.pi/2.),
      0 ]

## Call POVRay to render the PEMaps.
#
# @param iteration The current iteration.
# @param filename The filename of the POVRay script.
def render (iteration, filename):
  try:
    cmd = [
        "povray",
        "-d",
        "Verbose=false",
        "+OPEMap_{:d}.png".format(iteration),
        "+H1080",
        "+W1920",
        filename ]
    povray = subprocess.Popen(
        cmd, stdout = subprocess.PIPE, stderr = subprocess.PIPE)
    povray.wait()
  except subprocess.CalledProcessError as e:
    print("error spawning povray using: " + e.cmd)

  if povray.returncode != 0:
    print("POVRAY: " + cmd.__str__())
    for line in povray.stdout:
      print("POVRAY: " + line.rstrip().decode())
    for line in povray.stderr:
      print("POVRAY: " + line.rstrip().decode())

## POVRay helper. Open a box.
#
# @param xmin Lower corner.
# @param ymin Lower corner.
# @param zmin Lower corner.
# @param xmax Upper corner.
# @param ymax Upper corner.
# @param zmax Upper corner.
def box_open (xmin, ymin, zmin, xmax, ymax, zmax):
  script("box {\n")
  script("  < {:f}, {:f}, {:f} >, < {:f}, {:f}, {:f} >\n".format(
    xmin, ymin, zmin, xmax, ymax, zmax))

## POVRay helper. Draw a wire.
#
# @param xmin Starting point.
# @param ymin Starting point.
# @param zmin Starting point.
# @param xmax End point.
# @param ymax End point.
# @param zmax End point.
def wire (xmin, ymin, zmin, xmax, ymax, zmax):
  script("cylinder {\n")
  script("  < {:f}, {:f}, {:f} >, < {:f}, {:f}, {:f} >, {:f}\n".format(
    xmin, ymin, zmin, xmax, ymax, zmax, 0.1))
  script("  pigment { color White }\n")
  script("}\n")
  return

## Print a label.
#
# @param text The text to print.
# @param x The x offset.
# @param y The y offset.
# @param z The z offset.
def label (text, x, y, z):
  script("text {\n")
  script("  ttf \"/usr/share/fonts/droid/DroidSans.ttf\" \"{:s}\" 0.5, 0\n".format(text))
  script("  translate < {:f}, {:f}, {:f} >\n".format(x, y, z))
  script("  pigment { White }\n")
  script("}\n")

## Generate a POVRay script and render it.
#
# @param iteration The current iteration.
# @param numPEs The total number of PEs.
# @param PEMap_A The PEMap for matrix A.
# @param PEMap_C The PEMap for matrix C.
# @param PEMap_convolution The PEMap for the convolution.
# @param norms_convolution The product norms of the convolution.
def generatePOVRay (
    iteration, numPEs, PEMap_A, PEMap_C, PEMap_convolution,
    norms_convolution):
  global script_file
  openScriptFile(iteration, "pov")

  ( N, _ ) = PEMap_A.shape

  script("/* Automatically generated... */\n")
  script("#include \"colors.inc\"\n")

  # Place the camera.
  script("camera {\n")
  script("  location  < {:e}, {:e}, {:e} >\n".format(
    2*N/1.5, 2*N, 2*N))
  script("  look_at < 0, 0, 0 >\n")
  script("}\n")

  # Add a few light sources.
  script("light_source {\n")
  script("  < {:d}, {:d}, {:d} >, White\n".format(2*N, 2*N, 2*N))
  script("  parallel\n")
  script("  point_at < 0, 0, 0 >\n")
  script("}\n")

  script("light_source {\n")
  script("  < {:f}, {:f}, {:f} >, White\n".format(2*N, 2*N, N/2.))
  script("  parallel\n")
  script("  point_at < {:f}, {:f}, {:f} >\n".format(2*N, 2*N, 0))
  script("}\n")

  script("light_source {\n")
  script("  < {:f}, {:f}, {:f} >, White\n".format(2*N, N/2., 2*N))
  script("  parallel\n")
  script("  point_at < {:f}, {:f}, {:f} >\n".format(2*N, 0, 2*N))
  script("}\n")

  script("light_source {\n")
  script("  < {:f}, {:f}, {:f} >, White\n".format(N/2., 2*N, 2*N))
  script("  parallel\n")
  script("  point_at < {:f}, {:f}, {:f} >\n".format(0, 2*N, 2*N))
  script("}\n")

  # Plot axes.
  wire(0, -N/2., -N/2., N, -N/2., -N/2.)
  label("X-axis", N+1, -N/2., -N/2.)

  wire(-N/2., 0, -N/2., -N/2., N, -N/2.)
  label("Y-axis", -N/2., N+1, -N/2.)

  wire(-N/2., -N/2., 0, -N/2., -N/2., N)
  label("Z-axis", -N/2., -N/2., N+1)

  # Plot A map on x-y plane.
  box_open(0, 0, -N/2., N, N, -N/2.)
  script("  pigment { color White }\n")
  script("}\n")

  for i in range(N):
    for j in range(N):
      box_open(0.1+i, 0.1+j, -N/2.+0.1, 0.9+i, 0.9+j, -N/2.+0.1)
      color_vector = getColor(PEMap_A[i, j], numPEs)
      script("  pigment {{ color red {:f} green {:f} blue {:f} }}\n".format(
        color_vector[0],
        color_vector[1],
        color_vector[2]))
      script("}\n")

  # Plot B map on x-z plane.
  box_open(0, -N/2., 0, N, -N/2., N)
  script("  pigment { color White }\n")
  script("}\n")

  for i in range(N):
    for j in range(N):
      box_open(0.1+i, -N/2.+0.1, 0.1+j, 0.9+i, -N/2.+0.1, 0.9+j)
      color_vector = getColor(PEMap_A[i, j], numPEs)
      script("  pigment {{ color red {:f} green {:f} blue {:f} }}\n".format(
        color_vector[0],
        color_vector[1],
        color_vector[2]))
      script("}\n")

  # Plot C map on y-z plane.
  box_open(-N/2., 0, 0, -N/2., N, N)
  script("  pigment { color White }\n")
  script("}\n")

  for i in range(N):
    for j in range(N):
      box_open(-N/2.+0.1, 0.1+i, 0.1+j, -N/2.+0.1, 0.9+i, 0.9+j)
      color_vector = getColor(PEMap_C[i, j], numPEs)
      script("  pigment {{ color red {:f} green {:f} blue {:f} }}\n".format(
        color_vector[0],
        color_vector[1],
        color_vector[2]))
      script("}\n")

  # Plot convolution.
  maxNorm = np.amax(norm_convolution)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if PEMap_convolution[i, j, k] >= 0:
          box_open(0.1+i, 0.1+j, 0.1+k, 0.9+i, 0.9+j, 0.9+k)
          color_vector = getColor(
              PEMap_convolution[i, j, k], numPEs)
          script("  pigment {{ color red {:f} green {:f} blue {:f} ".format(
            color_vector[0],
            color_vector[1],
            color_vector[2]))
          script("transmit {:f} }}\n".format(1-norm_convolution[i,j,k]/maxNorm))
          script("  finish { metallic 0.4 }\n")
          script("  hollow\n")
          script("}\n")

  script_file.close()
  render(iteration, script_file.name)

## Generate a POVRay script and render it.
#
# @param iteration The current iteration.
# @param numPEs The total number of PEs.
# @param PEMap_A The PEMap for matrix A.
# @param PEMap_C The PEMap for matrix C.
# @param PEMap_convolution The PEMap for the convolution.
# @param norms_convolution The product norms of the convolution.
def generateBlender (
    iteration, numPEs, PEMap_A, PEMap_C, PEMap_convolution,
    norms_convolution):
  global script_file
  openScriptFile(iteration, "py")

  script("import bpy\n")

  script("bpy.ops.object.select_all(action = 'SELECT')\n")
  script("bpy.ops.object.delete()\n");

  script("bpy.ops.object.camera_add("
      + "location = ({:d}, {:d}, {:d}))\n".format(N, N, N))

  script("bpy.ops.mesh.primitive_plane_add(radius = {:d}, ".format(N)
      + "location = ({:d}, {:d}, {:d}))\n".format(0, 0, 0))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if PEMap_convolution[i, j, k] >= 0:
          script("bpy.ops.mesh.primitive_cube_add(radius=0.45, "
              + "location=({:d}, {:d}, {:d}))\n".format(i, j, k))
          script("bpy.ops.material.new()\n")

  script_file.close()

## Generate a Mathematica script.
#
# @param iteration The current iteration.
# @param numPEs The total number of PEs.
# @param PEMap_A The PEMap for matrix A.
# @param PEMap_C The PEMap for matrix C.
# @param PEMap_convolution The PEMap for the convolution.
# @param norms_convolution The product norms of the convolution.
def generateMathematica (
    iteration, numPEs, PEMap_A, PEMap_C, PEMap_convolution,
    norms_convolution):
  global script_file
  openScriptFile(iteration, "nb")

  # Plot convolution.
  maxNorm = np.amax(norm_convolution)
  script("Graphics3D[ {\n");
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if PEMap_convolution[i, j, k] >= 0:
          color_vector = getColor(
              PEMap_convolution[i, j, k], numPEs)
          script("  RGBColor[ {:f}, {:f}, {:f} ], ".format(
                color_vector[0],
                color_vector[1],
                color_vector[2]))
          script("Opacity[ {:f} ], Cuboid[".format(
            norm_convolution[i,j,k]/maxNorm))
          script("{{ {:f}, {:f}, {:f} }}, ".format(0.1+i, 0.1+j, 0.1+k))
          script("{{ {:f}, {:f}, {:f} }} ],\n".format(0.9+i, 0.9+j, 0.9+k))
  script("} ]\n")

  script_file.close()

##############################################

## The python version.
global python_version
python_version = sys.version_info

if python_version.major == 2 and python_version.minor < 7:
  print("need at least python 2.7 (running {:d}.{:d})".format(
    python_version.major, python_version.minor))
  sys.exit(1)

## The parser object.
parser = argparse.ArgumentParser()

parser.add_argument("FILE",
    help = "The output file to plot. A value of '-' means standard input.")

parser.add_argument("--output",
    help = "The output file base name, i.e. OUTPUT.${ITERATION}.${SUFFIX}")

parser.add_argument("--print",
    help = "Print the PEMaps to stdout",
    dest = "printPEMap",
    action = "store_true",
    default = False)

parser.add_argument("--aligned-print",
    help = "Print the convolution PEs aligned with their matrix PEs",
    action = "store_true",
    default = False)

parser.add_argument("--render",
    help = "Render the PEMaps",
    action = "store_true",
    default = False)

parser.add_argument("--blender",
    help = "Print out a blender script",
    action = "store_true",
    default = False)

parser.add_argument("--mathematica",
    help = "Generate Mathematic statements",
    action = "store_true",
    default = False)

parser.add_argument("--tolerance",
    help = "When printing the convolution, filter with TOLERANCE",
    type = float,
    default = 0)

parser.add_argument("--debug",
    help = "Print debugging stuff",
    action = "store_true",
    default = False)

options = parser.parse_args()

if options.FILE == "-":
  fd = sys.stdin
else:
  fd = open(options.FILE)

global basename
if options.output:
  basename = options.output
else:
  basename = None

iteration = -1

inMap = False
currentMap = ""

PEMap = {}
numPEs = -1
line_number = 0

for line in fd:
  line_number += 1
  if options.debug:
    print("PLOT: read ({:d})".format(line_number), line.rstrip())

  result = re.compile("iteration ([0-9]+) on").search(line)
  if result:
    iteration = int(result.group(1))
    print("iteration {:d}".format(iteration))
    continue

  result = re.compile("PEMap for (.*):").search(line)
  if result:
    mapName = result.group(1)
    if inMap and mapName != currentMap:
      raise(Exception("line {:d}: map {:s} already open for reading".format(
        line_number, mapName)))
    if not inMap:
      N = 0
      elementBuffer = []
    inMap = True
    currentMap = mapName
    if options.debug:
      print("PLOT: opening map {:s}".format(currentMap))

  result = re.compile("PEMap\(([0-9]+),([0-9]+)\) = ([0-9]+) \(norm = ([0-9.e+-]+)\)").search(line)
  if result:
    i = int(result.group(1))
    j = int(result.group(2))
    PE = int(result.group(3))
    norm = float(result.group(4))
    if not inMap:
      raise(Exception("line {:d}: no map open for reading".format(line_number)))
    elementBuffer.append( (i, j, PE, norm) )
    if i+1 > N:
      N = i+1
    if j+1 > N:
      N = j+1
    if PE+1 > numPEs:
      numPEs = PE+1
    continue

  result = re.compile("PEMap\(([0-9]+),([0-9]+),([0-9]+)\) = ([0-9]+) \(norm = ([0-9.e+-]+)\)").search(line)
  if result:
    i = int(result.group(1))
    j = int(result.group(2))
    k = int(result.group(3))
    PE = int(result.group(4))
    norm = float(result.group(5))
    if not inMap:
      raise(Exception("line {:d}: no map open for reading".format(line_number)))
    elementBuffer.append( (i, j, k, PE, norm) )
    if i+1 > N:
      N = i+1
    if j+1 > N:
      N = j+1
    if k+1 > N:
      N = k+1
    if PE+1 > numPEs:
      numPEs = PE+1
    continue

  result = re.compile("end of PEMap for (.*)").search(line)
  if result:
    if currentMap == "convolution":
      PEMap[currentMap] = np.empty([N, N, N], dtype = np.int16)
      PEMap[currentMap].fill(-1)
      norm_convolution = np.empty([N, N, N], dtype = np.float)
      norm_convolution.fill(0)
      for (i, j, k, PE, norm) in elementBuffer:
        if norm > options.tolerance:
          PEMap[currentMap][i,j,k] = PE
        norm_convolution[i,j,k] = norm
      if options.printPEMap:
        for label in PEMap:
          print("PEMap for {:s}".format(label))
          print(PEMap[label])
        print("convolution norms")
        print(norm_convolution)
      if options.aligned_print:
        for i in range(N):
          for j in range(N):
            for k in range(N):
              if PEMap["convolution"][i, j, k] >= 0:
                print("convolution({:2d},{:2d},{:2d}): ".format(i, j, k)
                    +"C({:2d},{:2d}) += ".format(i, j)
                    +"A({:2d},{:2d}) x ".format(i, k)
                    +"B({:2d},{:2d}): ".format(k, j)
                    +"{:2d} <-- {:2d} {:2d} {:2d}".format(
                      PEMap["convolution"][i, j, k],
                      PEMap["matrix A"][i, k],
                      PEMap["matrix A"][k, j],
                      PEMap["matrix C"][i, j]))
      if options.render:
        generatePOVRay(
            iteration, numPEs, PEMap["matrix A"], PEMap["matrix C"],
            PEMap["convolution"], norm_convolution)
      if options.blender:
        generateBlender(
            iteration, numPEs, PEMap["matrix A"], PEMap["matrix C"],
            PEMap["convolution"], norm_convolution)
      if options.mathematica:
        generateMathematica(
            iteration, numPEs, PEMap["matrix A"], PEMap["matrix C"],
            PEMap["convolution"], norm_convolution)
    else:
      PEMap[currentMap] = np.empty([N, N], dtype = np.int16)
      PEMap[currentMap].fill(-1)
      for (i, j, PE, norm) in elementBuffer:
        PEMap[currentMap][i,j] = PE
    inMap = False
    if options.debug:
      print("PLOT: closing map {:s}".format(currentMap))
    continue

fd.close()
